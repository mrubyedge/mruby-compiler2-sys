/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(transparent)]
pub struct __BindgenFloat16(pub u16);
pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __has_bounds_safety_attributes: u32 = 0;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &[u8; 9] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const USE_CLANG_LIMITS: u32 = 0;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_KERNELKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_13_7: u32 = 130700;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_14_6: u32 = 140600;
pub const __MAC_14_7: u32 = 140700;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __MAC_15_2: u32 = 150200;
pub const __MAC_15_3: u32 = 150300;
pub const __MAC_15_4: u32 = 150400;
pub const __MAC_15_5: u32 = 150500;
pub const __MAC_15_6: u32 = 150600;
pub const __MAC_16_0: u32 = 160000;
pub const __MAC_26_0: u32 = 260000;
pub const __MAC_26_1: u32 = 260100;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_17_6: u32 = 170600;
pub const __IPHONE_17_7: u32 = 170700;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __IPHONE_18_2: u32 = 180200;
pub const __IPHONE_18_3: u32 = 180300;
pub const __IPHONE_18_4: u32 = 180400;
pub const __IPHONE_18_5: u32 = 180500;
pub const __IPHONE_18_6: u32 = 180600;
pub const __IPHONE_19_0: u32 = 190000;
pub const __IPHONE_26_0: u32 = 260000;
pub const __IPHONE_26_1: u32 = 260100;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_10_6: u32 = 100600;
pub const __WATCHOS_10_7: u32 = 100700;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __WATCHOS_11_2: u32 = 110200;
pub const __WATCHOS_11_3: u32 = 110300;
pub const __WATCHOS_11_4: u32 = 110400;
pub const __WATCHOS_11_5: u32 = 110500;
pub const __WATCHOS_11_6: u32 = 110600;
pub const __WATCHOS_12_0: u32 = 120000;
pub const __WATCHOS_26_0: u32 = 260000;
pub const __WATCHOS_26_1: u32 = 260100;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_17_6: u32 = 170600;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __TVOS_18_2: u32 = 180200;
pub const __TVOS_18_3: u32 = 180300;
pub const __TVOS_18_4: u32 = 180400;
pub const __TVOS_18_5: u32 = 180500;
pub const __TVOS_18_6: u32 = 180600;
pub const __TVOS_19_0: u32 = 190000;
pub const __TVOS_26_0: u32 = 260000;
pub const __TVOS_26_1: u32 = 260100;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_8_6: u32 = 80600;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __BRIDGEOS_9_2: u32 = 90200;
pub const __BRIDGEOS_9_3: u32 = 90300;
pub const __BRIDGEOS_9_4: u32 = 90400;
pub const __BRIDGEOS_9_5: u32 = 90500;
pub const __BRIDGEOS_9_6: u32 = 90600;
pub const __BRIDGEOS_10_0: u32 = 100000;
pub const __BRIDGEOS_10_1: u32 = 100100;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_23_6: u32 = 230600;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __DRIVERKIT_24_2: u32 = 240200;
pub const __DRIVERKIT_24_3: u32 = 240300;
pub const __DRIVERKIT_24_4: u32 = 240400;
pub const __DRIVERKIT_24_5: u32 = 240500;
pub const __DRIVERKIT_24_6: u32 = 240600;
pub const __DRIVERKIT_25_0: u32 = 250000;
pub const __DRIVERKIT_25_1: u32 = 250100;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_1_3: u32 = 10300;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const __VISIONOS_2_2: u32 = 20200;
pub const __VISIONOS_2_3: u32 = 20300;
pub const __VISIONOS_2_4: u32 = 20400;
pub const __VISIONOS_2_5: u32 = 20500;
pub const __VISIONOS_2_6: u32 = 20600;
pub const __VISIONOS_3_0: u32 = 30000;
pub const __VISIONOS_26_0: u32 = 260000;
pub const __VISIONOS_26_1: u32 = 260100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_13_7: u32 = 130700;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_14_6: u32 = 140600;
pub const MAC_OS_VERSION_14_7: u32 = 140700;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const MAC_OS_VERSION_15_2: u32 = 150200;
pub const MAC_OS_VERSION_15_3: u32 = 150300;
pub const MAC_OS_VERSION_15_4: u32 = 150400;
pub const MAC_OS_VERSION_15_5: u32 = 150500;
pub const MAC_OS_VERSION_15_6: u32 = 150600;
pub const MAC_OS_VERSION_16_0: u32 = 160000;
pub const MAC_OS_VERSION_26_0: u32 = 260000;
pub const MAC_OS_VERSION_26_1: u32 = 260100;
pub const __AVAILABILITY_VERSIONS_VERSION_HASH: u32 = 93585900;
pub const __AVAILABILITY_VERSIONS_VERSION_STRING: &[u8; 6] = b"Local\0";
pub const __AVAILABILITY_FILE: &[u8; 23] = b"AvailabilityVersions.h\0";
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 260100;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const FP_NAN: u32 = 1;
pub const FP_INFINITE: u32 = 2;
pub const FP_ZERO: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 5;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_FAST_FMAL: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const USE_CLANG_STDARG: u32 = 0;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const RENAME_RESOLVE_BENEATH: u32 = 32;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const PRISM_DEPTH_MAXIMUM: u32 = 10000;
pub const _POSIX_VERSION: u32 = 200112;
pub const _POSIX2_VERSION: u32 = 200112;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _READ_OK: u32 = 512;
pub const _WRITE_OK: u32 = 1024;
pub const _EXECUTE_OK: u32 = 2048;
pub const _DELETE_OK: u32 = 4096;
pub const _APPEND_OK: u32 = 8192;
pub const _RMFILE_OK: u32 = 16384;
pub const _RATTR_OK: u32 = 32768;
pub const _WATTR_OK: u32 = 65536;
pub const _REXT_OK: u32 = 131072;
pub const _WEXT_OK: u32 = 262144;
pub const _RPERM_OK: u32 = 524288;
pub const _WPERM_OK: u32 = 1048576;
pub const _CHOWN_OK: u32 = 2097152;
pub const _ACCESS_EXTENDED_MASK: u32 = 4193792;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ACCESSX_MAX_DESCRIPTORS: u32 = 100;
pub const ACCESSX_MAX_TABLESIZE: u32 = 16384;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_NAME_CHARS_MAX: u32 = 10;
pub const _PC_CASE_SENSITIVE: u32 = 11;
pub const _PC_CASE_PRESERVING: u32 = 12;
pub const _PC_EXTENDED_SECURITY_NP: u32 = 13;
pub const _PC_AUTH_OPAQUE_NP: u32 = 14;
pub const _PC_2_SYMLINKS: u32 = 15;
pub const _PC_ALLOC_SIZE_MIN: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_FILESIZEBITS: u32 = 18;
pub const _PC_PRIO_IO: u32 = 19;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 20;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 21;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 22;
pub const _PC_REC_XFER_ALIGN: u32 = 23;
pub const _PC_SYMLINK_MAX: u32 = 24;
pub const _PC_SYNC_IO: u32 = 25;
pub const _PC_XATTR_SIZE_BITS: u32 = 26;
pub const _PC_MIN_HOLE_SIZE: u32 = 27;
pub const _CS_PATH: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _XOPEN_VERSION: u32 = 600;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _POSIX_ADVISORY_INFO: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_BARRIERS: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: i32 = -1;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 200112;
pub const _POSIX_JOB_CONTROL: u32 = 200112;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: i32 = -1;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: i32 = -1;
pub const _POSIX_NO_TRUNC: u32 = 200112;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_RAW_SOCKETS: i32 = -1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_REGEXP: u32 = 200112;
pub const _POSIX_SAVED_IDS: u32 = 200112;
pub const _POSIX_SEMAPHORES: i32 = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 200112;
pub const _POSIX_SPAWN: u32 = 200112;
pub const _POSIX_SPIN_LOCKS: i32 = -1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200112;
pub const _POSIX_THREAD_CPUTIME: i32 = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_TIMEOUTS: i32 = -1;
pub const _POSIX_TIMERS: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX2_C_BIND: u32 = 200112;
pub const _POSIX2_C_DEV: u32 = 200112;
pub const _POSIX2_CHAR_TERM: u32 = 200112;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: u32 = 200112;
pub const _POSIX2_LOCALEDEF: u32 = 200112;
pub const _POSIX2_PBS: i32 = -1;
pub const _POSIX2_PBS_ACCOUNTING: i32 = -1;
pub const _POSIX2_PBS_CHECKPOINT: i32 = -1;
pub const _POSIX2_PBS_LOCATE: i32 = -1;
pub const _POSIX2_PBS_MESSAGE: i32 = -1;
pub const _POSIX2_PBS_TRACK: i32 = -1;
pub const _POSIX2_SW_DEV: u32 = 200112;
pub const _POSIX2_UPE: u32 = 200112;
pub const __ILP32_OFF32: i32 = -1;
pub const __ILP32_OFFBIG: i32 = -1;
pub const __LP64_OFF64: u32 = 1;
pub const __LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: i32 = -1;
pub const _POSIX_V6_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _V6_ILP32_OFF32: i32 = -1;
pub const _V6_ILP32_OFFBIG: i32 = -1;
pub const _V6_LP64_OFF64: u32 = 1;
pub const _V6_LPBIG_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: i32 = -1;
pub const _XBS5_ILP32_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const _XBS5_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: i32 = -1;
pub const _XOPEN_REALTIME_THREADS: i32 = -1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_BC_BASE_MAX: u32 = 9;
pub const _SC_BC_DIM_MAX: u32 = 10;
pub const _SC_BC_SCALE_MAX: u32 = 11;
pub const _SC_BC_STRING_MAX: u32 = 12;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 13;
pub const _SC_EXPR_NEST_MAX: u32 = 14;
pub const _SC_LINE_MAX: u32 = 15;
pub const _SC_RE_DUP_MAX: u32 = 16;
pub const _SC_2_VERSION: u32 = 17;
pub const _SC_2_C_BIND: u32 = 18;
pub const _SC_2_C_DEV: u32 = 19;
pub const _SC_2_CHAR_TERM: u32 = 20;
pub const _SC_2_FORT_DEV: u32 = 21;
pub const _SC_2_FORT_RUN: u32 = 22;
pub const _SC_2_LOCALEDEF: u32 = 23;
pub const _SC_2_SW_DEV: u32 = 24;
pub const _SC_2_UPE: u32 = 25;
pub const _SC_STREAM_MAX: u32 = 26;
pub const _SC_TZNAME_MAX: u32 = 27;
pub const _SC_ASYNCHRONOUS_IO: u32 = 28;
pub const _SC_PAGESIZE: u32 = 29;
pub const _SC_MEMLOCK: u32 = 30;
pub const _SC_MEMLOCK_RANGE: u32 = 31;
pub const _SC_MEMORY_PROTECTION: u32 = 32;
pub const _SC_MESSAGE_PASSING: u32 = 33;
pub const _SC_PRIORITIZED_IO: u32 = 34;
pub const _SC_PRIORITY_SCHEDULING: u32 = 35;
pub const _SC_REALTIME_SIGNALS: u32 = 36;
pub const _SC_SEMAPHORES: u32 = 37;
pub const _SC_FSYNC: u32 = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 39;
pub const _SC_SYNCHRONIZED_IO: u32 = 40;
pub const _SC_TIMERS: u32 = 41;
pub const _SC_AIO_LISTIO_MAX: u32 = 42;
pub const _SC_AIO_MAX: u32 = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 44;
pub const _SC_DELAYTIMER_MAX: u32 = 45;
pub const _SC_MQ_OPEN_MAX: u32 = 46;
pub const _SC_MAPPED_FILES: u32 = 47;
pub const _SC_RTSIG_MAX: u32 = 48;
pub const _SC_SEM_NSEMS_MAX: u32 = 49;
pub const _SC_SEM_VALUE_MAX: u32 = 50;
pub const _SC_SIGQUEUE_MAX: u32 = 51;
pub const _SC_TIMER_MAX: u32 = 52;
pub const _SC_NPROCESSORS_CONF: u32 = 57;
pub const _SC_NPROCESSORS_ONLN: u32 = 58;
pub const _SC_2_PBS: u32 = 59;
pub const _SC_2_PBS_ACCOUNTING: u32 = 60;
pub const _SC_2_PBS_CHECKPOINT: u32 = 61;
pub const _SC_2_PBS_LOCATE: u32 = 62;
pub const _SC_2_PBS_MESSAGE: u32 = 63;
pub const _SC_2_PBS_TRACK: u32 = 64;
pub const _SC_ADVISORY_INFO: u32 = 65;
pub const _SC_BARRIERS: u32 = 66;
pub const _SC_CLOCK_SELECTION: u32 = 67;
pub const _SC_CPUTIME: u32 = 68;
pub const _SC_FILE_LOCKING: u32 = 69;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 70;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 71;
pub const _SC_HOST_NAME_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_MONOTONIC_CLOCK: u32 = 74;
pub const _SC_MQ_PRIO_MAX: u32 = 75;
pub const _SC_READER_WRITER_LOCKS: u32 = 76;
pub const _SC_REGEXP: u32 = 77;
pub const _SC_SHELL: u32 = 78;
pub const _SC_SPAWN: u32 = 79;
pub const _SC_SPIN_LOCKS: u32 = 80;
pub const _SC_SPORADIC_SERVER: u32 = 81;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 83;
pub const _SC_THREAD_CPUTIME: u32 = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 85;
pub const _SC_THREAD_KEYS_MAX: u32 = 86;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 87;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 89;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 91;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 92;
pub const _SC_THREAD_STACK_MIN: u32 = 93;
pub const _SC_THREAD_THREADS_MAX: u32 = 94;
pub const _SC_TIMEOUTS: u32 = 95;
pub const _SC_THREADS: u32 = 96;
pub const _SC_TRACE: u32 = 97;
pub const _SC_TRACE_EVENT_FILTER: u32 = 98;
pub const _SC_TRACE_INHERIT: u32 = 99;
pub const _SC_TRACE_LOG: u32 = 100;
pub const _SC_TTY_NAME_MAX: u32 = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 102;
pub const _SC_V6_ILP32_OFF32: u32 = 103;
pub const _SC_V6_ILP32_OFFBIG: u32 = 104;
pub const _SC_V6_LP64_OFF64: u32 = 105;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 106;
pub const _SC_IPV6: u32 = 118;
pub const _SC_RAW_SOCKETS: u32 = 119;
pub const _SC_SYMLOOP_MAX: u32 = 120;
pub const _SC_ATEXIT_MAX: u32 = 107;
pub const _SC_IOV_MAX: u32 = 56;
pub const _SC_PAGE_SIZE: u32 = 29;
pub const _SC_XOPEN_CRYPT: u32 = 108;
pub const _SC_XOPEN_ENH_I18N: u32 = 109;
pub const _SC_XOPEN_LEGACY: u32 = 110;
pub const _SC_XOPEN_REALTIME: u32 = 111;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 112;
pub const _SC_XOPEN_SHM: u32 = 113;
pub const _SC_XOPEN_STREAMS: u32 = 114;
pub const _SC_XOPEN_UNIX: u32 = 115;
pub const _SC_XOPEN_VERSION: u32 = 116;
pub const _SC_XOPEN_XCU_VERSION: u32 = 121;
pub const _SC_XBS5_ILP32_OFF32: u32 = 122;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 123;
pub const _SC_XBS5_LP64_OFF64: u32 = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 125;
pub const _SC_SS_REPL_MAX: u32 = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 127;
pub const _SC_TRACE_NAME_MAX: u32 = 128;
pub const _SC_TRACE_SYS_MAX: u32 = 129;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 130;
pub const _SC_PASS_MAX: u32 = 131;
pub const _SC_PHYS_PAGES: u32 = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 35;
pub const _CS_DARWIN_USER_DIR: u32 = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: u32 = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: u32 = 65538;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const SYNC_VOLUME_FULLSYNC: u32 = 1;
pub const SYNC_VOLUME_WAIT: u32 = 2;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const SIGEV_KEVENT: u32 = 4;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_TYPE_VFS_ENTITLED_RESERVE_ACCESS: u32 = 14;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ORIG: u32 = 4;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_BASIC_MASK: u32 = 3;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE: u32 = 2;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const IOPOL_VFS_ENTITLED_RESERVE_ACCESS_OFF: u32 = 0;
pub const IOPOL_VFS_ENTITLED_RESERVE_ACCESS_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const _MALLOC_TYPE_MALLOC_BACKDEPLOY_PUBLIC: u32 = 1;
pub const PRISM_ENCODING_ALPHABETIC_BIT: u32 = 1;
pub const PRISM_ENCODING_ALPHANUMERIC_BIT: u32 = 2;
pub const PRISM_ENCODING_UPPERCASE_BIT: u32 = 4;
pub const PM_CONSTANT_ID_UNSET: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ENOTCAPABLE: u32 = 107;
pub const ELAST: u32 = 107;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_ACCMODE: u32 = 3;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const O_NONBLOCK: u32 = 4;
pub const O_APPEND: u32 = 8;
pub const O_SYNC: u32 = 128;
pub const O_SHLOCK: u32 = 16;
pub const O_EXLOCK: u32 = 32;
pub const O_ASYNC: u32 = 64;
pub const O_FSYNC: u32 = 128;
pub const O_NOFOLLOW: u32 = 256;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const O_RESOLVE_BENEATH: u32 = 4096;
pub const O_UNIQUE: u32 = 8192;
pub const O_EVTONLY: u32 = 32768;
pub const O_NOCTTY: u32 = 131072;
pub const O_DIRECTORY: u32 = 1048576;
pub const O_SYMLINK: u32 = 2097152;
pub const O_DSYNC: u32 = 4194304;
pub const O_CLOEXEC: u32 = 16777216;
pub const O_NOFOLLOW_ANY: u32 = 536870912;
pub const O_EXEC: u32 = 1073741824;
pub const O_SEARCH: u32 = 1074790400;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 16;
pub const AT_SYMLINK_NOFOLLOW: u32 = 32;
pub const AT_SYMLINK_FOLLOW: u32 = 64;
pub const AT_REMOVEDIR: u32 = 128;
pub const AT_REALDEV: u32 = 512;
pub const AT_FDONLY: u32 = 1024;
pub const AT_SYMLINK_NOFOLLOW_ANY: u32 = 2048;
pub const AT_RESOLVE_BENEATH: u32 = 8192;
pub const AT_NODELETEBUSY: u32 = 16384;
pub const AT_UNIQUE: u32 = 32768;
pub const O_DP_GETRAWENCRYPTED: u32 = 1;
pub const O_DP_GETRAWUNENCRYPTED: u32 = 2;
pub const O_DP_AUTHENTICATE: u32 = 4;
pub const AUTH_OPEN_NOAUTHFD: i32 = -1;
pub const FAPPEND: u32 = 8;
pub const FASYNC: u32 = 64;
pub const FFSYNC: u32 = 128;
pub const FFDSYNC: u32 = 4194304;
pub const FNONBLOCK: u32 = 4;
pub const FNDELAY: u32 = 4;
pub const O_NDELAY: u32 = 4;
pub const CPF_OVERWRITE: u32 = 1;
pub const CPF_IGNORE_MODE: u32 = 2;
pub const CPF_MASK: u32 = 3;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_SETLKWTIMEOUT: u32 = 10;
pub const F_FLUSH_DATA: u32 = 40;
pub const F_CHKCLEAN: u32 = 41;
pub const F_PREALLOCATE: u32 = 42;
pub const F_SETSIZE: u32 = 43;
pub const F_RDADVISE: u32 = 44;
pub const F_RDAHEAD: u32 = 45;
pub const F_NOCACHE: u32 = 48;
pub const F_LOG2PHYS: u32 = 49;
pub const F_GETPATH: u32 = 50;
pub const F_FULLFSYNC: u32 = 51;
pub const F_PATHPKG_CHECK: u32 = 52;
pub const F_FREEZE_FS: u32 = 53;
pub const F_THAW_FS: u32 = 54;
pub const F_GLOBAL_NOCACHE: u32 = 55;
pub const F_ADDSIGS: u32 = 59;
pub const F_ADDFILESIGS: u32 = 61;
pub const F_NODIRECT: u32 = 62;
pub const F_GETPROTECTIONCLASS: u32 = 63;
pub const F_SETPROTECTIONCLASS: u32 = 64;
pub const F_LOG2PHYS_EXT: u32 = 65;
pub const F_GETLKPID: u32 = 66;
pub const F_SETBACKINGSTORE: u32 = 70;
pub const F_GETPATH_MTMINFO: u32 = 71;
pub const F_GETCODEDIR: u32 = 72;
pub const F_SETNOSIGPIPE: u32 = 73;
pub const F_GETNOSIGPIPE: u32 = 74;
pub const F_TRANSCODEKEY: u32 = 75;
pub const F_SINGLE_WRITER: u32 = 76;
pub const F_GETPROTECTIONLEVEL: u32 = 77;
pub const F_FINDSIGS: u32 = 78;
pub const F_ADDFILESIGS_FOR_DYLD_SIM: u32 = 83;
pub const F_BARRIERFSYNC: u32 = 85;
pub const F_OFD_SETLK: u32 = 90;
pub const F_OFD_SETLKW: u32 = 91;
pub const F_OFD_GETLK: u32 = 92;
pub const F_OFD_SETLKWTIMEOUT: u32 = 93;
pub const F_ADDFILESIGS_RETURN: u32 = 97;
pub const F_CHECK_LV: u32 = 98;
pub const F_PUNCHHOLE: u32 = 99;
pub const F_TRIM_ACTIVE_FILE: u32 = 100;
pub const F_SPECULATIVE_READ: u32 = 101;
pub const F_GETPATH_NOFIRMLINK: u32 = 102;
pub const F_ADDFILESIGS_INFO: u32 = 103;
pub const F_ADDFILESUPPL: u32 = 104;
pub const F_GETSIGSINFO: u32 = 105;
pub const F_SETLEASE: u32 = 106;
pub const F_GETLEASE: u32 = 107;
pub const F_TRANSFEREXTENTS: u32 = 110;
pub const F_ATTRIBUTION_TAG: u32 = 111;
pub const F_NOCACHE_EXT: u32 = 112;
pub const F_ADDSIGS_MAIN_BINARY: u32 = 113;
pub const FCNTL_FS_SPECIFIC_BASE: u32 = 65536;
pub const F_DUPFD_CLOEXEC: u32 = 67;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_WRLCK: u32 = 3;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const F_ALLOCATECONTIG: u32 = 2;
pub const F_ALLOCATEALL: u32 = 4;
pub const F_ALLOCATEPERSIST: u32 = 8;
pub const F_PEOFPOSMODE: u32 = 3;
pub const F_VOLPOSMODE: u32 = 4;
pub const USER_FSIGNATURES_CDHASH_LEN: u32 = 20;
pub const GETSIGSINFO_PLATFORM_BINARY: u32 = 1;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const ATTRIBUTION_NAME_MAX: u32 = 255;
pub const F_CREATE_TAG: u32 = 1;
pub const F_DELETE_TAG: u32 = 2;
pub const F_QUERY_TAG: u32 = 4;
pub const O_POPUP: u32 = 2147483648;
pub const O_ALERT: u32 = 536870912;
pub const PROT_NONE: u32 = 0;
pub const PROT_READ: u32 = 1;
pub const PROT_WRITE: u32 = 2;
pub const PROT_EXEC: u32 = 4;
pub const MAP_SHARED: u32 = 1;
pub const MAP_PRIVATE: u32 = 2;
pub const MAP_COPY: u32 = 2;
pub const MAP_FIXED: u32 = 16;
pub const MAP_RENAME: u32 = 32;
pub const MAP_NORESERVE: u32 = 64;
pub const MAP_RESERVED0080: u32 = 128;
pub const MAP_NOEXTEND: u32 = 256;
pub const MAP_HASSEMAPHORE: u32 = 512;
pub const MAP_NOCACHE: u32 = 1024;
pub const MAP_JIT: u32 = 2048;
pub const MAP_FILE: u32 = 0;
pub const MAP_ANON: u32 = 4096;
pub const MAP_ANONYMOUS: u32 = 4096;
pub const MAP_RESILIENT_CODESIGN: u32 = 8192;
pub const MAP_RESILIENT_MEDIA: u32 = 16384;
pub const MAP_32BIT: u32 = 32768;
pub const MAP_TRANSLATED_ALLOW_EXECUTE: u32 = 131072;
pub const MAP_UNIX03: u32 = 262144;
pub const MAP_TPRO: u32 = 524288;
pub const MCL_CURRENT: u32 = 1;
pub const MCL_FUTURE: u32 = 2;
pub const MS_ASYNC: u32 = 1;
pub const MS_INVALIDATE: u32 = 2;
pub const MS_SYNC: u32 = 16;
pub const MS_KILLPAGES: u32 = 4;
pub const MS_DEACTIVATE: u32 = 8;
pub const POSIX_MADV_NORMAL: u32 = 0;
pub const POSIX_MADV_RANDOM: u32 = 1;
pub const POSIX_MADV_SEQUENTIAL: u32 = 2;
pub const POSIX_MADV_WILLNEED: u32 = 3;
pub const POSIX_MADV_DONTNEED: u32 = 4;
pub const MADV_NORMAL: u32 = 0;
pub const MADV_RANDOM: u32 = 1;
pub const MADV_SEQUENTIAL: u32 = 2;
pub const MADV_WILLNEED: u32 = 3;
pub const MADV_DONTNEED: u32 = 4;
pub const MADV_FREE: u32 = 5;
pub const MADV_ZERO_WIRED_PAGES: u32 = 6;
pub const MADV_FREE_REUSABLE: u32 = 7;
pub const MADV_FREE_REUSE: u32 = 8;
pub const MADV_CAN_REUSE: u32 = 9;
pub const MADV_PAGEOUT: u32 = 10;
pub const MADV_ZERO: u32 = 11;
pub const MINCORE_INCORE: u32 = 1;
pub const MINCORE_REFERENCED: u32 = 2;
pub const MINCORE_MODIFIED: u32 = 4;
pub const MINCORE_REFERENCED_OTHER: u32 = 8;
pub const MINCORE_MODIFIED_OTHER: u32 = 16;
pub const MINCORE_PAGED_OUT: u32 = 32;
pub const MINCORE_COPIED: u32 = 64;
pub const MINCORE_ANONYMOUS: u32 = 128;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const UF_SETTABLE: u32 = 65535;
pub const UF_NODUMP: u32 = 1;
pub const UF_IMMUTABLE: u32 = 2;
pub const UF_APPEND: u32 = 4;
pub const UF_OPAQUE: u32 = 8;
pub const UF_COMPRESSED: u32 = 32;
pub const UF_TRACKED: u32 = 64;
pub const UF_DATAVAULT: u32 = 128;
pub const UF_HIDDEN: u32 = 32768;
pub const SF_SUPPORTED: u32 = 10420224;
pub const SF_SETTABLE: u32 = 1073676288;
pub const SF_SYNTHETIC: u32 = 3221225472;
pub const SF_ARCHIVED: u32 = 65536;
pub const SF_IMMUTABLE: u32 = 131072;
pub const SF_APPEND: u32 = 262144;
pub const SF_RESTRICTED: u32 = 524288;
pub const SF_NOUNLINK: u32 = 1048576;
pub const SF_FIRMLINK: u32 = 8388608;
pub const SF_DATALESS: u32 = 1073741824;
pub const EF_MAY_SHARE_BLOCKS: u32 = 1;
pub const EF_NO_XATTRS: u32 = 2;
pub const EF_IS_SYNC_ROOT: u32 = 4;
pub const EF_IS_PURGEABLE: u32 = 8;
pub const EF_IS_SPARSE: u32 = 16;
pub const EF_IS_SYNTHETIC: u32 = 32;
pub const EF_SHARES_ALL_BLOCKS: u32 = 64;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const PRISM_SERIALIZE_ONLY_SEMANTICS_FIELDS: u32 = 0;
pub const PM_LEX_STACK_SIZE: u32 = 4;
pub const PRISM_VERSION_MAJOR: u32 = 1;
pub const PRISM_VERSION_MINOR: u32 = 4;
pub const PRISM_VERSION_PATCH: u32 = 0;
pub const PRISM_VERSION: &[u8; 6] = b"1.4.0\0";
pub const LC_COLLATE_MASK: u32 = 1;
pub const LC_CTYPE_MASK: u32 = 2;
pub const LC_MESSAGES_MASK: u32 = 4;
pub const LC_MONETARY_MASK: u32 = 8;
pub const LC_NUMERIC_MASK: u32 = 16;
pub const LC_TIME_MASK: u32 = 32;
pub const _LC_NUM_MASK: u32 = 6;
pub const _LC_LAST_MASK: u32 = 32;
pub const LC_ALL: u32 = 0;
pub const LC_COLLATE: u32 = 1;
pub const LC_CTYPE: u32 = 2;
pub const LC_MONETARY: u32 = 3;
pub const LC_NUMERIC: u32 = 4;
pub const LC_TIME: u32 = 5;
pub const LC_MESSAGES: u32 = 6;
pub const _LC_LAST: u32 = 7;
pub const MRC_RELEASE_YEAR: u32 = 2024;
pub const MRC_RELEASE_MONTH: u32 = 9;
pub const MRC_RELEASE_DAY: u32 = 9;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const MRC_INT64: u32 = 1;
pub const MRC_64BIT: u32 = 1;
pub const MRC_INT_BIT: u32 = 64;
pub const MRC_INT_MIN: i64 = -9223372036854775808;
pub const MRC_INT_MAX: u64 = 9223372036854775807;
pub const MRC_PRIo: &[u8; 4] = b"llo\0";
pub const MRC_PRId: &[u8; 4] = b"lld\0";
pub const MRC_PRIx: &[u8; 4] = b"llx\0";
pub const _JBLEN: u32 = 48;
pub const IREP_TT_NFLAG: u32 = 1;
pub const IREP_TT_SFLAG: u32 = 2;
pub const MRC_ISEQ_NO_FREE: u32 = 1;
pub const MRC_IREP_NO_FREE: u32 = 2;
pub const MRC_DUMP_DEBUG_INFO: u32 = 1;
pub const MRC_DUMP_STATIC: u32 = 2;
pub const MRC_DUMP_OK: u32 = 0;
pub const MRC_DUMP_GENERAL_FAILURE: i32 = -1;
pub const MRC_DUMP_WRITE_FAULT: i32 = -2;
pub const MRC_DUMP_READ_FAULT: i32 = -3;
pub const MRC_DUMP_INVALID_FILE_HEADER: i32 = -4;
pub const MRC_DUMP_INVALID_IREP: i32 = -5;
pub const MRC_DUMP_INVALID_ARGUMENT: i32 = -6;
pub const MRC_DUMP_NULL_SYM_LEN: u32 = 65535;
pub const RITE_BINARY_IDENT: &[u8; 5] = b"RITE\0";
pub const RITE_BINARY_MAJOR_VER: &[u8; 3] = b"03\0";
pub const RITE_BINARY_MINOR_VER: &[u8; 3] = b"00\0";
pub const RITE_BINARY_FORMAT_VER: &[u8; 5] = b"0300\0";
pub const RITE_COMPILER_NAME: &[u8; 5] = b"HSMK\0";
pub const RITE_PARSER_NAME: &[u8; 6] = b"Prism\0";
pub const RITE_COMPILER_VERSION: &[u8; 5] = b"0000\0";
pub const RITE_VM_VER: &[u8; 5] = b"0300\0";
pub const RITE_BINARY_EOF: &[u8; 5] = b"END\0\0";
pub const RITE_SECTION_IREP_IDENT: &[u8; 5] = b"IREP\0";
pub const RITE_SECTION_DEBUG_IDENT: &[u8; 5] = b"DBG\0\0";
pub const RITE_SECTION_LV_IDENT: &[u8; 5] = b"LVAR\0";
pub const MRC_DUMP_DEFAULT_STR_LEN: u32 = 128;
pub const RITE_LV_NULL_MARK: u32 = 65535;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RuneEntry"][::std::mem::size_of::<_RuneEntry>() - 24usize];
    ["Alignment of _RuneEntry"][::std::mem::align_of::<_RuneEntry>() - 8usize];
    ["Offset of field: _RuneEntry::__min"][::std::mem::offset_of!(_RuneEntry, __min) - 0usize];
    ["Offset of field: _RuneEntry::__max"][::std::mem::offset_of!(_RuneEntry, __max) - 4usize];
    ["Offset of field: _RuneEntry::__map"][::std::mem::offset_of!(_RuneEntry, __map) - 8usize];
    ["Offset of field: _RuneEntry::__types"][::std::mem::offset_of!(_RuneEntry, __types) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RuneRange"][::std::mem::size_of::<_RuneRange>() - 16usize];
    ["Alignment of _RuneRange"][::std::mem::align_of::<_RuneRange>() - 8usize];
    ["Offset of field: _RuneRange::__nranges"]
        [::std::mem::offset_of!(_RuneRange, __nranges) - 0usize];
    ["Offset of field: _RuneRange::__ranges"]
        [::std::mem::offset_of!(_RuneRange, __ranges) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RuneCharClass"][::std::mem::size_of::<_RuneCharClass>() - 20usize];
    ["Alignment of _RuneCharClass"][::std::mem::align_of::<_RuneCharClass>() - 4usize];
    ["Offset of field: _RuneCharClass::__name"]
        [::std::mem::offset_of!(_RuneCharClass, __name) - 0usize];
    ["Offset of field: _RuneCharClass::__mask"]
        [::std::mem::offset_of!(_RuneCharClass, __mask) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            __string: *const ::std::os::raw::c_char,
            __n: __darwin_size_t,
            arg1: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            __string: *mut ::std::os::raw::c_char,
            __n: __darwin_size_t,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _RuneLocale"][::std::mem::size_of::<_RuneLocale>() - 3208usize];
    ["Alignment of _RuneLocale"][::std::mem::align_of::<_RuneLocale>() - 8usize];
    ["Offset of field: _RuneLocale::__magic"]
        [::std::mem::offset_of!(_RuneLocale, __magic) - 0usize];
    ["Offset of field: _RuneLocale::__encoding"]
        [::std::mem::offset_of!(_RuneLocale, __encoding) - 8usize];
    ["Offset of field: _RuneLocale::__sgetrune"]
        [::std::mem::offset_of!(_RuneLocale, __sgetrune) - 40usize];
    ["Offset of field: _RuneLocale::__sputrune"]
        [::std::mem::offset_of!(_RuneLocale, __sputrune) - 48usize];
    ["Offset of field: _RuneLocale::__invalid_rune"]
        [::std::mem::offset_of!(_RuneLocale, __invalid_rune) - 56usize];
    ["Offset of field: _RuneLocale::__runetype"]
        [::std::mem::offset_of!(_RuneLocale, __runetype) - 60usize];
    ["Offset of field: _RuneLocale::__maplower"]
        [::std::mem::offset_of!(_RuneLocale, __maplower) - 1084usize];
    ["Offset of field: _RuneLocale::__mapupper"]
        [::std::mem::offset_of!(_RuneLocale, __mapupper) - 2108usize];
    ["Offset of field: _RuneLocale::__runetype_ext"]
        [::std::mem::offset_of!(_RuneLocale, __runetype_ext) - 3136usize];
    ["Offset of field: _RuneLocale::__maplower_ext"]
        [::std::mem::offset_of!(_RuneLocale, __maplower_ext) - 3152usize];
    ["Offset of field: _RuneLocale::__mapupper_ext"]
        [::std::mem::offset_of!(_RuneLocale, __mapupper_ext) - 3168usize];
    ["Offset of field: _RuneLocale::__variable"]
        [::std::mem::offset_of!(_RuneLocale, __variable) - 3184usize];
    ["Offset of field: _RuneLocale::__variable_len"]
        [::std::mem::offset_of!(_RuneLocale, __variable_len) - 3192usize];
    ["Offset of field: _RuneLocale::__ncharclasses"]
        [::std::mem::offset_of!(_RuneLocale, __ncharclasses) - 3196usize];
    ["Offset of field: _RuneLocale::__charclasses"]
        [::std::mem::offset_of!(_RuneLocale, __charclasses) - 3200usize];
};
unsafe extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
unsafe extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
unsafe extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
unsafe extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
unsafe extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
unsafe extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
pub type float_t = f32;
pub type double_t = f64;
unsafe extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn round(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
unsafe extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fabsf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __hypotf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __sqrtf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __ceilf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __floorf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __rintf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __roundf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __truncf16(arg1: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __copysignf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __nextafterf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __fmaxf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __fminf16(arg1: __BindgenFloat16, arg2: __BindgenFloat16) -> __BindgenFloat16;
}
unsafe extern "C" {
    pub fn __fmaf16(
        arg1: __BindgenFloat16,
        arg2: __BindgenFloat16,
        arg3: __BindgenFloat16,
    ) -> __BindgenFloat16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __float2"][::std::mem::size_of::<__float2>() - 8usize];
    ["Alignment of __float2"][::std::mem::align_of::<__float2>() - 4usize];
    ["Offset of field: __float2::__sinval"][::std::mem::offset_of!(__float2, __sinval) - 0usize];
    ["Offset of field: __float2::__cosval"][::std::mem::offset_of!(__float2, __cosval) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __double2"][::std::mem::size_of::<__double2>() - 16usize];
    ["Alignment of __double2"][::std::mem::align_of::<__double2>() - 8usize];
    ["Offset of field: __double2::__sinval"][::std::mem::offset_of!(__double2, __sinval) - 0usize];
    ["Offset of field: __double2::__cosval"][::std::mem::offset_of!(__double2, __cosval) - 8usize];
};
unsafe extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
unsafe extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
unsafe extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
unsafe extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of exception"][::std::mem::size_of::<exception>() - 40usize];
    ["Alignment of exception"][::std::mem::align_of::<exception>() - 8usize];
    ["Offset of field: exception::type_"][::std::mem::offset_of!(exception, type_) - 0usize];
    ["Offset of field: exception::name"][::std::mem::offset_of!(exception, name) - 8usize];
    ["Offset of field: exception::arg1"][::std::mem::offset_of!(exception, arg1) - 16usize];
    ["Offset of field: exception::arg2"][::std::mem::offset_of!(exception, arg2) - 24usize];
    ["Offset of field: exception::retval"][::std::mem::offset_of!(exception, retval) - 32usize];
};
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type max_align_t = f64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
unsafe extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sbuf"][::std::mem::size_of::<__sbuf>() - 16usize];
    ["Alignment of __sbuf"][::std::mem::align_of::<__sbuf>() - 8usize];
    ["Offset of field: __sbuf::_base"][::std::mem::offset_of!(__sbuf, _base) - 0usize];
    ["Offset of field: __sbuf::_size"][::std::mem::offset_of!(__sbuf, _size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            __n: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            __n: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sFILE"][::std::mem::size_of::<__sFILE>() - 152usize];
    ["Alignment of __sFILE"][::std::mem::align_of::<__sFILE>() - 8usize];
    ["Offset of field: __sFILE::_p"][::std::mem::offset_of!(__sFILE, _p) - 0usize];
    ["Offset of field: __sFILE::_r"][::std::mem::offset_of!(__sFILE, _r) - 8usize];
    ["Offset of field: __sFILE::_w"][::std::mem::offset_of!(__sFILE, _w) - 12usize];
    ["Offset of field: __sFILE::_flags"][::std::mem::offset_of!(__sFILE, _flags) - 16usize];
    ["Offset of field: __sFILE::_file"][::std::mem::offset_of!(__sFILE, _file) - 18usize];
    ["Offset of field: __sFILE::_bf"][::std::mem::offset_of!(__sFILE, _bf) - 24usize];
    ["Offset of field: __sFILE::_lbfsize"][::std::mem::offset_of!(__sFILE, _lbfsize) - 40usize];
    ["Offset of field: __sFILE::_cookie"][::std::mem::offset_of!(__sFILE, _cookie) - 48usize];
    ["Offset of field: __sFILE::_close"][::std::mem::offset_of!(__sFILE, _close) - 56usize];
    ["Offset of field: __sFILE::_read"][::std::mem::offset_of!(__sFILE, _read) - 64usize];
    ["Offset of field: __sFILE::_seek"][::std::mem::offset_of!(__sFILE, _seek) - 72usize];
    ["Offset of field: __sFILE::_write"][::std::mem::offset_of!(__sFILE, _write) - 80usize];
    ["Offset of field: __sFILE::_ub"][::std::mem::offset_of!(__sFILE, _ub) - 88usize];
    ["Offset of field: __sFILE::_extra"][::std::mem::offset_of!(__sFILE, _extra) - 104usize];
    ["Offset of field: __sFILE::_ur"][::std::mem::offset_of!(__sFILE, _ur) - 112usize];
    ["Offset of field: __sFILE::_ubuf"][::std::mem::offset_of!(__sFILE, _ubuf) - 116usize];
    ["Offset of field: __sFILE::_nbuf"][::std::mem::offset_of!(__sFILE, _nbuf) - 119usize];
    ["Offset of field: __sFILE::_lb"][::std::mem::offset_of!(__sFILE, _lb) - 120usize];
    ["Offset of field: __sFILE::_blksize"][::std::mem::offset_of!(__sFILE, _blksize) - 136usize];
    ["Offset of field: __sFILE::_offset"][::std::mem::offset_of!(__sFILE, _offset) - 144usize];
};
pub type FILE = __sFILE;
unsafe extern "C" {
    pub static mut __stdinp: *mut FILE;
}
unsafe extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
unsafe extern "C" {
    pub static mut __stderrp: *mut FILE;
}
unsafe extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_int,
        arg2: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
unsafe extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
unsafe extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
unsafe extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
unsafe extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fgetln(arg1: *mut FILE, __len: *mut usize) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type errno_t = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
unsafe extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        __len: isize,
    );
}
unsafe extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::fds_bits"][::std::mem::offset_of!(fd_set, fds_bits) - 0usize];
};
unsafe extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
unsafe extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of accessx_descriptor"][::std::mem::size_of::<accessx_descriptor>() - 16usize];
    ["Alignment of accessx_descriptor"][::std::mem::align_of::<accessx_descriptor>() - 4usize];
    ["Offset of field: accessx_descriptor::ad_name_offset"]
        [::std::mem::offset_of!(accessx_descriptor, ad_name_offset) - 0usize];
    ["Offset of field: accessx_descriptor::ad_flags"]
        [::std::mem::offset_of!(accessx_descriptor, ad_flags) - 4usize];
    ["Offset of field: accessx_descriptor::ad_pad"]
        [::std::mem::offset_of!(accessx_descriptor, ad_pad) - 8usize];
};
unsafe extern "C" {
    pub fn getattrlistbulk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: usize,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: usize,
        arg6: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn freadlink(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fork() -> pid_t;
}
unsafe extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, __size: usize) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getegid() -> gid_t;
}
unsafe extern "C" {
    pub fn geteuid() -> uid_t;
}
unsafe extern "C" {
    pub fn getgid() -> gid_t;
}
unsafe extern "C" {
    pub fn getgroups(
        __gidsetsize: ::std::os::raw::c_int,
        arg1: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getpgrp() -> pid_t;
}
unsafe extern "C" {
    pub fn getpid() -> pid_t;
}
unsafe extern "C" {
    pub fn getppid() -> pid_t;
}
unsafe extern "C" {
    pub fn getuid() -> uid_t;
}
unsafe extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
unsafe extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        __nbyte: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsid() -> pid_t;
}
unsafe extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
unsafe extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn getopt(
        __argc: ::std::os::raw::c_int,
        arg1: *const *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn brk(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
unsafe extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
unsafe extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getwd(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: usize,
        __offset: off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: usize,
        __offset: off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn setpgrp() -> pid_t;
}
unsafe extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sync();
}
unsafe extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
unsafe extern "C" {
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, __namelen: usize)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostname(
        arg1: *mut ::std::os::raw::c_char,
        __namelen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        __bufsize: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
pub type sigset_t = __darwin_sigset_t;
unsafe extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
pub type uuid_t = __darwin_uuid_t;
unsafe extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn accessx_np(
        arg1: *const accessx_descriptor,
        __sz: usize,
        arg2: *mut ::std::os::raw::c_int,
        arg3: uid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn add_profil(
        arg1: *mut ::std::os::raw::c_char,
        __bufsiz: usize,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn endusershell();
}
unsafe extern "C" {
    pub fn execvP(
        __file: *const ::std::os::raw::c_char,
        __searchpath: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getdomainname(
        arg1: *mut ::std::os::raw::c_char,
        __namelen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getgrouplist(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        __ngroups: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostuuid(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t) -> mode_t;
}
unsafe extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getwgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initgroups(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkpath_np(path: *const ::std::os::raw::c_char, omode: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkpathat_np(
        dfd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkostemp(
        path: *mut ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostemps(
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemp_dprotected_np(
        path: *mut ::std::os::raw::c_char,
        dpclass: ::std::os::raw::c_int,
        dpflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtempat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkostempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nfssvc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn profil(
        arg1: *mut ::std::os::raw::c_char,
        __bufsiz: usize,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn revoke(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rcmd(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rcmd_af(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rresvport_af(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iruserok(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iruserok_sa(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ruserok(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setdomainname(
        arg1: *const ::std::os::raw::c_char,
        __namelen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setgroups(arg1: ::std::os::raw::c_int, arg2: *const gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn sethostname(
        arg1: *const ::std::os::raw::c_char,
        __namelen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setlogin(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setmode(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setusershell();
}
unsafe extern "C" {
    pub fn setwgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strtofflags(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn swapon(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn undelete(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        __attrBufSize: usize,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        __attrBufSize: usize,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        __attrBufSize: usize,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        __attrBufSize: usize,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exchangedata(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdirentriesattr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        __attrBufSize: usize,
        arg4: *mut ::std::os::raw::c_uint,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn searchfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fssearchblock,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut searchstate,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsctl(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsync_volume_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sync_volume_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> !;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state"]
        [::std::mem::size_of::<__darwin_arm_exception_state>() - 12usize];
    ["Alignment of __darwin_arm_exception_state"]
        [::std::mem::align_of::<__darwin_arm_exception_state>() - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__exception"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __exception) - 0usize];
    ["Offset of field: __darwin_arm_exception_state::__fsr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __fsr) - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __far) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64"]
        [::std::mem::size_of::<__darwin_arm_exception_state64>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64"]
        [::std::mem::align_of::<__darwin_arm_exception_state64>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64::__esr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __esr) - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__exception"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __exception) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64_v2 {
    pub __far: __uint64_t,
    pub __esr: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64_v2"]
        [::std::mem::size_of::<__darwin_arm_exception_state64_v2>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64_v2"]
        [::std::mem::align_of::<__darwin_arm_exception_state64_v2>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64_v2, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__esr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64_v2, __esr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state"]
        [::std::mem::size_of::<__darwin_arm_thread_state>() - 68usize];
    ["Alignment of __darwin_arm_thread_state"]
        [::std::mem::align_of::<__darwin_arm_thread_state>() - 4usize];
    ["Offset of field: __darwin_arm_thread_state::__r"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_thread_state::__sp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __sp) - 52usize];
    ["Offset of field: __darwin_arm_thread_state::__lr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __lr) - 56usize];
    ["Offset of field: __darwin_arm_thread_state::__pc"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __pc) - 60usize];
    ["Offset of field: __darwin_arm_thread_state::__cpsr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __cpsr) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state64"]
        [::std::mem::size_of::<__darwin_arm_thread_state64>() - 272usize];
    ["Alignment of __darwin_arm_thread_state64"]
        [::std::mem::align_of::<__darwin_arm_thread_state64>() - 8usize];
    ["Offset of field: __darwin_arm_thread_state64::__x"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __x) - 0usize];
    ["Offset of field: __darwin_arm_thread_state64::__fp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __fp) - 232usize];
    ["Offset of field: __darwin_arm_thread_state64::__lr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __lr) - 240usize];
    ["Offset of field: __darwin_arm_thread_state64::__sp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __sp) - 248usize];
    ["Offset of field: __darwin_arm_thread_state64::__pc"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __pc) - 256usize];
    ["Offset of field: __darwin_arm_thread_state64::__cpsr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __cpsr) - 264usize];
    ["Offset of field: __darwin_arm_thread_state64::__pad"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __pad) - 268usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_vfp_state"][::std::mem::size_of::<__darwin_arm_vfp_state>() - 260usize];
    ["Alignment of __darwin_arm_vfp_state"]
        [::std::mem::align_of::<__darwin_arm_vfp_state>() - 4usize];
    ["Offset of field: __darwin_arm_vfp_state::__r"]
        [::std::mem::offset_of!(__darwin_arm_vfp_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_vfp_state::__fpscr"]
        [::std::mem::offset_of!(__darwin_arm_vfp_state, __fpscr) - 256usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state64"]
        [::std::mem::size_of::<__darwin_arm_neon_state64>() - 528usize];
    ["Alignment of __darwin_arm_neon_state64"]
        [::std::mem::align_of::<__darwin_arm_neon_state64>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state64::__v"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpsr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __fpsr) - 512usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpcr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __fpcr) - 516usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state"]
        [::std::mem::size_of::<__darwin_arm_neon_state>() - 272usize];
    ["Alignment of __darwin_arm_neon_state"]
        [::std::mem::align_of::<__darwin_arm_neon_state>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state::__v"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state::__fpsr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __fpsr) - 256usize];
    ["Offset of field: __darwin_arm_neon_state::__fpcr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __fpcr) - 260usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_pagein_state"][::std::mem::size_of::<__arm_pagein_state>() - 4usize];
    ["Alignment of __arm_pagein_state"][::std::mem::align_of::<__arm_pagein_state>() - 4usize];
    ["Offset of field: __arm_pagein_state::__pagein_error"]
        [::std::mem::offset_of!(__arm_pagein_state, __pagein_error) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sme_state {
    pub __svcr: __uint64_t,
    pub __tpidr2_el0: __uint64_t,
    pub __svl_b: __uint16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme_state"][::std::mem::size_of::<__darwin_arm_sme_state>() - 24usize];
    ["Alignment of __darwin_arm_sme_state"]
        [::std::mem::align_of::<__darwin_arm_sme_state>() - 8usize];
    ["Offset of field: __darwin_arm_sme_state::__svcr"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __svcr) - 0usize];
    ["Offset of field: __darwin_arm_sme_state::__tpidr2_el0"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __tpidr2_el0) - 8usize];
    ["Offset of field: __darwin_arm_sme_state::__svl_b"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __svl_b) - 16usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sve_z_state {
    pub __z: [[::std::os::raw::c_char; 256usize]; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sve_z_state"]
        [::std::mem::size_of::<__darwin_arm_sve_z_state>() - 4096usize];
    ["Alignment of __darwin_arm_sve_z_state"]
        [::std::mem::align_of::<__darwin_arm_sve_z_state>() - 4usize];
    ["Offset of field: __darwin_arm_sve_z_state::__z"]
        [::std::mem::offset_of!(__darwin_arm_sve_z_state, __z) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sve_p_state {
    pub __p: [[::std::os::raw::c_char; 32usize]; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sve_p_state"]
        [::std::mem::size_of::<__darwin_arm_sve_p_state>() - 512usize];
    ["Alignment of __darwin_arm_sve_p_state"]
        [::std::mem::align_of::<__darwin_arm_sve_p_state>() - 4usize];
    ["Offset of field: __darwin_arm_sve_p_state::__p"]
        [::std::mem::offset_of!(__darwin_arm_sve_p_state, __p) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sme_za_state {
    pub __za: [::std::os::raw::c_char; 4096usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme_za_state"]
        [::std::mem::size_of::<__darwin_arm_sme_za_state>() - 4096usize];
    ["Alignment of __darwin_arm_sme_za_state"]
        [::std::mem::align_of::<__darwin_arm_sme_za_state>() - 4usize];
    ["Offset of field: __darwin_arm_sme_za_state::__za"]
        [::std::mem::offset_of!(__darwin_arm_sme_za_state, __za) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sme2_state {
    pub __zt0: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme2_state"][::std::mem::size_of::<__darwin_arm_sme2_state>() - 64usize];
    ["Alignment of __darwin_arm_sme2_state"]
        [::std::mem::align_of::<__darwin_arm_sme2_state>() - 4usize];
    ["Offset of field: __darwin_arm_sme2_state::__zt0"]
        [::std::mem::offset_of!(__darwin_arm_sme2_state, __zt0) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_legacy_debug_state"]
        [::std::mem::size_of::<__arm_legacy_debug_state>() - 256usize];
    ["Alignment of __arm_legacy_debug_state"]
        [::std::mem::align_of::<__arm_legacy_debug_state>() - 4usize];
    ["Offset of field: __arm_legacy_debug_state::__bvr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __bvr) - 0usize];
    ["Offset of field: __arm_legacy_debug_state::__bcr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __bcr) - 64usize];
    ["Offset of field: __arm_legacy_debug_state::__wvr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __wvr) - 128usize];
    ["Offset of field: __arm_legacy_debug_state::__wcr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __wcr) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state32"]
        [::std::mem::size_of::<__darwin_arm_debug_state32>() - 264usize];
    ["Alignment of __darwin_arm_debug_state32"]
        [::std::mem::align_of::<__darwin_arm_debug_state32>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state32::__bvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state32::__bcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __bcr) - 64usize];
    ["Offset of field: __darwin_arm_debug_state32::__wvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __wvr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state32::__wcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __wcr) - 192usize];
    ["Offset of field: __darwin_arm_debug_state32::__mdscr_el1"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __mdscr_el1) - 256usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state64"]
        [::std::mem::size_of::<__darwin_arm_debug_state64>() - 520usize];
    ["Alignment of __darwin_arm_debug_state64"]
        [::std::mem::align_of::<__darwin_arm_debug_state64>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state64::__bvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state64::__bcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __bcr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state64::__wvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __wvr) - 256usize];
    ["Offset of field: __darwin_arm_debug_state64::__wcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __wcr) - 384usize];
    ["Offset of field: __darwin_arm_debug_state64::__mdscr_el1"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __mdscr_el1) - 512usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_cpmu_state64"]
        [::std::mem::size_of::<__darwin_arm_cpmu_state64>() - 128usize];
    ["Alignment of __darwin_arm_cpmu_state64"]
        [::std::mem::align_of::<__darwin_arm_cpmu_state64>() - 8usize];
    ["Offset of field: __darwin_arm_cpmu_state64::__ctrs"]
        [::std::mem::offset_of!(__darwin_arm_cpmu_state64, __ctrs) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext32"][::std::mem::size_of::<__darwin_mcontext32>() - 340usize];
    ["Alignment of __darwin_mcontext32"][::std::mem::align_of::<__darwin_mcontext32>() - 4usize];
    ["Offset of field: __darwin_mcontext32::__es"]
        [::std::mem::offset_of!(__darwin_mcontext32, __es) - 0usize];
    ["Offset of field: __darwin_mcontext32::__ss"]
        [::std::mem::offset_of!(__darwin_mcontext32, __ss) - 12usize];
    ["Offset of field: __darwin_mcontext32::__fs"]
        [::std::mem::offset_of!(__darwin_mcontext32, __fs) - 80usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext64"][::std::mem::size_of::<__darwin_mcontext64>() - 816usize];
    ["Alignment of __darwin_mcontext64"][::std::mem::align_of::<__darwin_mcontext64>() - 16usize];
    ["Offset of field: __darwin_mcontext64::__es"]
        [::std::mem::offset_of!(__darwin_mcontext64, __es) - 0usize];
    ["Offset of field: __darwin_mcontext64::__ss"]
        [::std::mem::offset_of!(__darwin_mcontext64, __ss) - 16usize];
    ["Offset of field: __darwin_mcontext64::__ns"]
        [::std::mem::offset_of!(__darwin_mcontext64, __ns) - 288usize];
};
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_sigaltstack"][::std::mem::size_of::<__darwin_sigaltstack>() - 24usize];
    ["Alignment of __darwin_sigaltstack"][::std::mem::align_of::<__darwin_sigaltstack>() - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_sp"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_sp) - 0usize];
    ["Offset of field: __darwin_sigaltstack::ss_size"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_size) - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_flags"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_flags) - 16usize];
};
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_ucontext"][::std::mem::size_of::<__darwin_ucontext>() - 56usize];
    ["Alignment of __darwin_ucontext"][::std::mem::align_of::<__darwin_ucontext>() - 8usize];
    ["Offset of field: __darwin_ucontext::uc_onstack"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_onstack) - 0usize];
    ["Offset of field: __darwin_ucontext::uc_sigmask"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_sigmask) - 4usize];
    ["Offset of field: __darwin_ucontext::uc_stack"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_stack) - 8usize];
    ["Offset of field: __darwin_ucontext::uc_link"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_link) - 32usize];
    ["Offset of field: __darwin_ucontext::uc_mcsize"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_mcsize) - 40usize];
    ["Offset of field: __darwin_ucontext::uc_mcontext"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_mcontext) - 48usize];
};
pub type ucontext_t = __darwin_ucontext;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 32usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 4usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 8usize];
    ["Offset of field: sigevent::sigev_notify_function"]
        [::std::mem::offset_of!(sigevent, sigev_notify_function) - 16usize];
    ["Offset of field: sigevent::sigev_notify_attributes"]
        [::std::mem::offset_of!(sigevent, sigev_notify_attributes) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __siginfo"][::std::mem::size_of::<__siginfo>() - 104usize];
    ["Alignment of __siginfo"][::std::mem::align_of::<__siginfo>() - 8usize];
    ["Offset of field: __siginfo::si_signo"][::std::mem::offset_of!(__siginfo, si_signo) - 0usize];
    ["Offset of field: __siginfo::si_errno"][::std::mem::offset_of!(__siginfo, si_errno) - 4usize];
    ["Offset of field: __siginfo::si_code"][::std::mem::offset_of!(__siginfo, si_code) - 8usize];
    ["Offset of field: __siginfo::si_pid"][::std::mem::offset_of!(__siginfo, si_pid) - 12usize];
    ["Offset of field: __siginfo::si_uid"][::std::mem::offset_of!(__siginfo, si_uid) - 16usize];
    ["Offset of field: __siginfo::si_status"]
        [::std::mem::offset_of!(__siginfo, si_status) - 20usize];
    ["Offset of field: __siginfo::si_addr"][::std::mem::offset_of!(__siginfo, si_addr) - 24usize];
    ["Offset of field: __siginfo::si_value"][::std::mem::offset_of!(__siginfo, si_value) - 32usize];
    ["Offset of field: __siginfo::si_band"][::std::mem::offset_of!(__siginfo, si_band) - 40usize];
    ["Offset of field: __siginfo::__pad"][::std::mem::offset_of!(__siginfo, __pad) - 48usize];
};
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction_u"][::std::mem::size_of::<__sigaction_u>() - 8usize];
    ["Alignment of __sigaction_u"][::std::mem::align_of::<__sigaction_u>() - 8usize];
    ["Offset of field: __sigaction_u::__sa_handler"]
        [::std::mem::offset_of!(__sigaction_u, __sa_handler) - 0usize];
    ["Offset of field: __sigaction_u::__sa_sigaction"]
        [::std::mem::offset_of!(__sigaction_u, __sa_sigaction) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction"][::std::mem::size_of::<__sigaction>() - 24usize];
    ["Alignment of __sigaction"][::std::mem::align_of::<__sigaction>() - 8usize];
    ["Offset of field: __sigaction::__sigaction_u"]
        [::std::mem::offset_of!(__sigaction, __sigaction_u) - 0usize];
    ["Offset of field: __sigaction::sa_tramp"]
        [::std::mem::offset_of!(__sigaction, sa_tramp) - 8usize];
    ["Offset of field: __sigaction::sa_mask"]
        [::std::mem::offset_of!(__sigaction, sa_mask) - 16usize];
    ["Offset of field: __sigaction::sa_flags"]
        [::std::mem::offset_of!(__sigaction, sa_flags) - 20usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 16usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_u"]
        [::std::mem::offset_of!(sigaction, __sigaction_u) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"][::std::mem::offset_of!(sigaction, sa_flags) - 12usize];
};
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigvec"][::std::mem::size_of::<sigvec>() - 16usize];
    ["Alignment of sigvec"][::std::mem::align_of::<sigvec>() - 8usize];
    ["Offset of field: sigvec::sv_handler"][::std::mem::offset_of!(sigvec, sv_handler) - 0usize];
    ["Offset of field: sigvec::sv_mask"][::std::mem::offset_of!(sigvec, sv_mask) - 8usize];
    ["Offset of field: sigvec::sv_flags"][::std::mem::offset_of!(sigvec, sv_flags) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::std::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::std::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::std::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::std::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
unsafe extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage"][::std::mem::size_of::<rusage>() - 144usize];
    ["Alignment of rusage"][::std::mem::align_of::<rusage>() - 8usize];
    ["Offset of field: rusage::ru_utime"][::std::mem::offset_of!(rusage, ru_utime) - 0usize];
    ["Offset of field: rusage::ru_stime"][::std::mem::offset_of!(rusage, ru_stime) - 16usize];
    ["Offset of field: rusage::ru_maxrss"][::std::mem::offset_of!(rusage, ru_maxrss) - 32usize];
    ["Offset of field: rusage::ru_ixrss"][::std::mem::offset_of!(rusage, ru_ixrss) - 40usize];
    ["Offset of field: rusage::ru_idrss"][::std::mem::offset_of!(rusage, ru_idrss) - 48usize];
    ["Offset of field: rusage::ru_isrss"][::std::mem::offset_of!(rusage, ru_isrss) - 56usize];
    ["Offset of field: rusage::ru_minflt"][::std::mem::offset_of!(rusage, ru_minflt) - 64usize];
    ["Offset of field: rusage::ru_majflt"][::std::mem::offset_of!(rusage, ru_majflt) - 72usize];
    ["Offset of field: rusage::ru_nswap"][::std::mem::offset_of!(rusage, ru_nswap) - 80usize];
    ["Offset of field: rusage::ru_inblock"][::std::mem::offset_of!(rusage, ru_inblock) - 88usize];
    ["Offset of field: rusage::ru_oublock"][::std::mem::offset_of!(rusage, ru_oublock) - 96usize];
    ["Offset of field: rusage::ru_msgsnd"][::std::mem::offset_of!(rusage, ru_msgsnd) - 104usize];
    ["Offset of field: rusage::ru_msgrcv"][::std::mem::offset_of!(rusage, ru_msgrcv) - 112usize];
    ["Offset of field: rusage::ru_nsignals"]
        [::std::mem::offset_of!(rusage, ru_nsignals) - 120usize];
    ["Offset of field: rusage::ru_nvcsw"][::std::mem::offset_of!(rusage, ru_nvcsw) - 128usize];
    ["Offset of field: rusage::ru_nivcsw"][::std::mem::offset_of!(rusage, ru_nivcsw) - 136usize];
};
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v0"][::std::mem::size_of::<rusage_info_v0>() - 96usize];
    ["Alignment of rusage_info_v0"][::std::mem::align_of::<rusage_info_v0>() - 8usize];
    ["Offset of field: rusage_info_v0::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v0, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v0::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v0, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v0::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v0, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v0::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v0, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v0::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v0, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v0::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v0, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v0::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v0, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v0::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v0, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v0::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v0, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v0::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v0, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v0::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v0, ri_proc_exit_abstime) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v1"][::std::mem::size_of::<rusage_info_v1>() - 144usize];
    ["Alignment of rusage_info_v1"][::std::mem::align_of::<rusage_info_v1>() - 8usize];
    ["Offset of field: rusage_info_v1::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v1, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v1::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v1::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v1::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v1::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v1::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v1, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v1::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v1, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v1::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v1, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v1::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v1, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v1::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v1::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v1::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v1::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v1::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v1::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v1::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v1::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_elapsed_abstime) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v2"][::std::mem::size_of::<rusage_info_v2>() - 160usize];
    ["Alignment of rusage_info_v2"][::std::mem::align_of::<rusage_info_v2>() - 8usize];
    ["Offset of field: rusage_info_v2::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v2, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v2::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v2::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v2::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v2::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v2::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v2, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v2::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v2, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v2::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v2, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v2::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v2, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v2::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v2::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v2::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v2::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v2::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v2::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v2::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v2::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v2::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v2, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v2::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v2, ri_diskio_byteswritten) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v3"][::std::mem::size_of::<rusage_info_v3>() - 232usize];
    ["Alignment of rusage_info_v3"][::std::mem::align_of::<rusage_info_v3>() - 8usize];
    ["Offset of field: rusage_info_v3::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v3, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v3::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v3::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v3::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v3::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v3::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v3, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v3::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v3, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v3::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v3, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v3::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v3, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v3::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v3::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v3::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v3::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v3::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v3::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v3::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v3::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v3::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v3, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v3::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v3, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v3::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v3::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_serviced_system_time) - 224usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v4"][::std::mem::size_of::<rusage_info_v4>() - 296usize];
    ["Alignment of rusage_info_v4"][::std::mem::align_of::<rusage_info_v4>() - 8usize];
    ["Offset of field: rusage_info_v4::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v4, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v4::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v4::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v4::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v4::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v4::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v4, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v4::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v4, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v4::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v4, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v4::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v4::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v4::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v4::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v4::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v4::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v4::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v4::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v4::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v4::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v4, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v4::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v4, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v4::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v4::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v4::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v4, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v4::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v4::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v4, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v4::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v4::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v4::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v4::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v4::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_runnable_time) - 288usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v5"][::std::mem::size_of::<rusage_info_v5>() - 304usize];
    ["Alignment of rusage_info_v5"][::std::mem::align_of::<rusage_info_v5>() - 8usize];
    ["Offset of field: rusage_info_v5::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v5, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v5::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v5::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v5::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v5::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v5::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v5, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v5::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v5, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v5::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v5, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v5::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v5::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v5::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v5::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v5::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v5::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v5::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v5::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v5::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v5::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v5, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v5::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v5, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v5::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v5::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v5::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v5, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v5::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v5::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v5, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v5::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v5::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v5::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v5::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v5::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v5::ri_flags"]
        [::std::mem::offset_of!(rusage_info_v5, ri_flags) - 296usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_neural_footprint: u64,
    pub ri_lifetime_max_neural_footprint: u64,
    pub ri_interval_max_neural_footprint: u64,
    pub ri_reserved: [u64; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v6"][::std::mem::size_of::<rusage_info_v6>() - 464usize];
    ["Alignment of rusage_info_v6"][::std::mem::align_of::<rusage_info_v6>() - 8usize];
    ["Offset of field: rusage_info_v6::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v6, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v6::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v6::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v6::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v6::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v6::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v6::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v6, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v6::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v6, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v6::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v6::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v6::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v6::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v6::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v6::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v6::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v6::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v6::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v6::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v6, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v6::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v6, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v6::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v6::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v6::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v6, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v6::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v6, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v6::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v6::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v6::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v6::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v6::ri_flags"]
        [::std::mem::offset_of!(rusage_info_v6, ri_flags) - 296usize];
    ["Offset of field: rusage_info_v6::ri_user_ptime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_user_ptime) - 304usize];
    ["Offset of field: rusage_info_v6::ri_system_ptime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_system_ptime) - 312usize];
    ["Offset of field: rusage_info_v6::ri_pinstructions"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pinstructions) - 320usize];
    ["Offset of field: rusage_info_v6::ri_pcycles"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pcycles) - 328usize];
    ["Offset of field: rusage_info_v6::ri_energy_nj"]
        [::std::mem::offset_of!(rusage_info_v6, ri_energy_nj) - 336usize];
    ["Offset of field: rusage_info_v6::ri_penergy_nj"]
        [::std::mem::offset_of!(rusage_info_v6, ri_penergy_nj) - 344usize];
    ["Offset of field: rusage_info_v6::ri_secure_time_in_system"]
        [::std::mem::offset_of!(rusage_info_v6, ri_secure_time_in_system) - 352usize];
    ["Offset of field: rusage_info_v6::ri_secure_ptime_in_system"]
        [::std::mem::offset_of!(rusage_info_v6, ri_secure_ptime_in_system) - 360usize];
    ["Offset of field: rusage_info_v6::ri_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_neural_footprint) - 368usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_lifetime_max_neural_footprint) - 376usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interval_max_neural_footprint) - 384usize];
    ["Offset of field: rusage_info_v6::ri_reserved"]
        [::std::mem::offset_of!(rusage_info_v6, ri_reserved) - 392usize];
};
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rlimit"][::std::mem::size_of::<rlimit>() - 16usize];
    ["Alignment of rlimit"][::std::mem::align_of::<rlimit>() - 8usize];
    ["Offset of field: rlimit::rlim_cur"][::std::mem::offset_of!(rlimit, rlim_cur) - 0usize];
    ["Offset of field: rlimit::rlim_max"][::std::mem::offset_of!(rlimit, rlim_max) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of proc_rlimit_control_wakeupmon"]
        [::std::mem::size_of::<proc_rlimit_control_wakeupmon>() - 8usize];
    ["Alignment of proc_rlimit_control_wakeupmon"]
        [::std::mem::align_of::<proc_rlimit_control_wakeupmon>() - 4usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_flags"]
        [::std::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_flags) - 0usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_rate"]
        [::std::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_rate) - 4usize];
};
unsafe extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_1"][::std::mem::size_of::<wait__bindgen_ty_1>() - 4usize];
    ["Alignment of wait__bindgen_ty_1"][::std::mem::align_of::<wait__bindgen_ty_1>() - 4usize];
};
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Termsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Termsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Coredump_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Coredump_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Retcode_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Retcode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_2"][::std::mem::size_of::<wait__bindgen_ty_2>() - 4usize];
    ["Alignment of wait__bindgen_ty_2"][::std::mem::align_of::<wait__bindgen_ty_2>() - 4usize];
};
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopval_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopval_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait"][::std::mem::size_of::<wait>() - 4usize];
    ["Alignment of wait"][::std::mem::align_of::<wait>() - 4usize];
    ["Offset of field: wait::w_status"][::std::mem::offset_of!(wait, w_status) - 0usize];
    ["Offset of field: wait::w_T"][::std::mem::offset_of!(wait, w_T) - 0usize];
    ["Offset of field: wait::w_S"][::std::mem::offset_of!(wait, w_S) - 0usize];
};
unsafe extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
unsafe extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
unsafe extern "C" {
    pub fn malloc_type_malloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
unsafe extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_valloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
unsafe extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
unsafe extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        __size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> u32;
}
unsafe extern "C" {
    pub fn arc4random_addrandom(
        arg1: *mut ::std::os::raw::c_uchar,
        __datlen: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
unsafe extern "C" {
    pub fn arc4random_stir();
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
unsafe extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getloadavg(arg1: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sranddev();
}
unsafe extern "C" {
    pub fn srandomdev();
}
unsafe extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
#[doc = " A list of offsets of newlines in a string. The offsets are assumed to be\n sorted/inserted in ascending order."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_newline_list_t {
    #[doc = " A pointer to the start of the source string."]
    pub start: *const u8,
    #[doc = " The number of offsets in the list."]
    pub size: usize,
    #[doc = " The capacity of the list that has been allocated."]
    pub capacity: usize,
    #[doc = " The list of offsets."]
    pub offsets: *mut usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_newline_list_t"][::std::mem::size_of::<pm_newline_list_t>() - 32usize];
    ["Alignment of pm_newline_list_t"][::std::mem::align_of::<pm_newline_list_t>() - 8usize];
    ["Offset of field: pm_newline_list_t::start"]
        [::std::mem::offset_of!(pm_newline_list_t, start) - 0usize];
    ["Offset of field: pm_newline_list_t::size"]
        [::std::mem::offset_of!(pm_newline_list_t, size) - 8usize];
    ["Offset of field: pm_newline_list_t::capacity"]
        [::std::mem::offset_of!(pm_newline_list_t, capacity) - 16usize];
    ["Offset of field: pm_newline_list_t::offsets"]
        [::std::mem::offset_of!(pm_newline_list_t, offsets) - 24usize];
};
#[doc = " A line and column in a string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_line_column_t {
    #[doc = " The line number."]
    pub line: i32,
    #[doc = " The column number."]
    pub column: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_line_column_t"][::std::mem::size_of::<pm_line_column_t>() - 8usize];
    ["Alignment of pm_line_column_t"][::std::mem::align_of::<pm_line_column_t>() - 4usize];
    ["Offset of field: pm_line_column_t::line"]
        [::std::mem::offset_of!(pm_line_column_t, line) - 0usize];
    ["Offset of field: pm_line_column_t::column"]
        [::std::mem::offset_of!(pm_line_column_t, column) - 4usize];
};
unsafe extern "C" {
    #[doc = " Initialize a new newline list with the given capacity. Returns true if the\n allocation of the offsets succeeds, otherwise returns false.\n\n @param list The list to initialize.\n @param start A pointer to the start of the source string.\n @param capacity The initial capacity of the list.\n @return True if the allocation of the offsets succeeds, otherwise false."]
    pub fn pm_newline_list_init(
        list: *mut pm_newline_list_t,
        start: *const u8,
        capacity: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Clear out the newlines that have been appended to the list.\n\n @param list The list to clear."]
    pub fn pm_newline_list_clear(list: *mut pm_newline_list_t);
}
unsafe extern "C" {
    #[doc = " Append a new offset to the newline list. Returns true if the reallocation of\n the offsets succeeds (if one was necessary), otherwise returns false.\n\n @param list The list to append to.\n @param cursor A pointer to the offset to append.\n @return True if the reallocation of the offsets succeeds (if one was\n     necessary), otherwise false."]
    pub fn pm_newline_list_append(list: *mut pm_newline_list_t, cursor: *const u8) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the line of the given offset. If the offset is not in the list, the\n line of the closest offset less than the given offset is returned.\n\n @param list The list to search.\n @param cursor A pointer to the offset to search for.\n @param start_line The line to start counting from.\n @return The line of the given offset."]
    pub fn pm_newline_list_line(
        list: *const pm_newline_list_t,
        cursor: *const u8,
        start_line: i32,
    ) -> i32;
}
unsafe extern "C" {
    #[doc = " Returns the line and column of the given offset. If the offset is not in the\n list, the line and column of the closest offset less than the given offset\n are returned.\n\n @param list The list to search.\n @param cursor A pointer to the offset to search for.\n @param start_line The line to start counting from.\n @return The line and column of the given offset."]
    pub fn pm_newline_list_line_column(
        list: *const pm_newline_list_t,
        cursor: *const u8,
        start_line: i32,
    ) -> pm_line_column_t;
}
unsafe extern "C" {
    #[doc = " Free the internal memory allocated for the newline list.\n\n @param list The list to free."]
    pub fn pm_newline_list_free(list: *mut pm_newline_list_t);
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are\n whitespace. Disallows searching past the given maximum number of characters.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @return The number of characters at the start of the string that are\n     whitespace."]
    pub fn pm_strspn_whitespace(string: *const u8, length: isize) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are\n whitespace while also tracking the location of each newline. Disallows\n searching past the given maximum number of characters.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @param newline_list The list of newlines to populate.\n @return The number of characters at the start of the string that are\n     whitespace."]
    pub fn pm_strspn_whitespace_newlines(
        string: *const u8,
        length: isize,
        newline_list: *mut pm_newline_list_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are inline\n whitespace. Disallows searching past the given maximum number of characters.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @return The number of characters at the start of the string that are inline\n     whitespace."]
    pub fn pm_strspn_inline_whitespace(string: *const u8, length: isize) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are decimal\n digits. Disallows searching past the given maximum number of characters.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @return The number of characters at the start of the string that are decimal\n     digits."]
    pub fn pm_strspn_decimal_digit(string: *const u8, length: isize) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are\n hexadecimal digits. Disallows searching past the given maximum number of\n characters.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @return The number of characters at the start of the string that are\n     hexadecimal digits."]
    pub fn pm_strspn_hexadecimal_digit(string: *const u8, length: isize) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are octal\n digits or underscores. Disallows searching past the given maximum number of\n characters.\n\n If multiple underscores are found in a row or if an underscore is\n found at the end of the number, then the invalid pointer is set to the index\n of the first invalid underscore.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @param invalid The pointer to set to the index of the first invalid\n     underscore.\n @return The number of characters at the start of the string that are octal\n     digits or underscores."]
    pub fn pm_strspn_octal_number(
        string: *const u8,
        length: isize,
        invalid: *mut *const u8,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are decimal\n digits or underscores. Disallows searching past the given maximum number of\n characters.\n\n If multiple underscores are found in a row or if an underscore is\n found at the end of the number, then the invalid pointer is set to the index\n of the first invalid underscore.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @param invalid The pointer to set to the index of the first invalid\n     underscore.\n @return The number of characters at the start of the string that are decimal\n     digits or underscores."]
    pub fn pm_strspn_decimal_number(
        string: *const u8,
        length: isize,
        invalid: *mut *const u8,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are\n hexadecimal digits or underscores. Disallows searching past the given maximum\n number of characters.\n\n If multiple underscores are found in a row or if an underscore is\n found at the end of the number, then the invalid pointer is set to the index\n of the first invalid underscore.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @param invalid The pointer to set to the index of the first invalid\n     underscore.\n @return The number of characters at the start of the string that are\n     hexadecimal digits or underscores."]
    pub fn pm_strspn_hexadecimal_number(
        string: *const u8,
        length: isize,
        invalid: *mut *const u8,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are regexp\n options. Disallows searching past the given maximum number of characters.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @return The number of characters at the start of the string that are regexp\n     options."]
    pub fn pm_strspn_regexp_option(string: *const u8, length: isize) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the number of characters at the start of the string that are binary\n digits or underscores. Disallows searching past the given maximum number of\n characters.\n\n If multiple underscores are found in a row or if an underscore is\n found at the end of the number, then the invalid pointer is set to the index\n of the first invalid underscore.\n\n @param string The string to search.\n @param length The maximum number of characters to search.\n @param invalid The pointer to set to the index of the first invalid\n     underscore.\n @return The number of characters at the start of the string that are binary\n     digits or underscores."]
    pub fn pm_strspn_binary_number(
        string: *const u8,
        length: isize,
        invalid: *mut *const u8,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns true if the given character is a whitespace character.\n\n @param b The character to check.\n @return True if the given character is a whitespace character."]
    pub fn pm_char_is_whitespace(b: u8) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns true if the given character is an inline whitespace character.\n\n @param b The character to check.\n @return True if the given character is an inline whitespace character."]
    pub fn pm_char_is_inline_whitespace(b: u8) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns true if the given character is a binary digit.\n\n @param b The character to check.\n @return True if the given character is a binary digit."]
    pub fn pm_char_is_binary_digit(b: u8) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns true if the given character is an octal digit.\n\n @param b The character to check.\n @return True if the given character is an octal digit."]
    pub fn pm_char_is_octal_digit(b: u8) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns true if the given character is a decimal digit.\n\n @param b The character to check.\n @return True if the given character is a decimal digit."]
    pub fn pm_char_is_decimal_digit(b: u8) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns true if the given character is a hexadecimal digit.\n\n @param b The character to check.\n @return True if the given character is a hexadecimal digit."]
    pub fn pm_char_is_hexadecimal_digit(b: u8) -> bool;
}
#[doc = " A pm_buffer_t is a simple memory buffer that stores data in a contiguous\n block of memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_buffer_t {
    #[doc = " The length of the buffer in bytes."]
    pub length: usize,
    #[doc = " The capacity of the buffer in bytes that has been allocated."]
    pub capacity: usize,
    #[doc = " A pointer to the start of the buffer."]
    pub value: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_buffer_t"][::std::mem::size_of::<pm_buffer_t>() - 24usize];
    ["Alignment of pm_buffer_t"][::std::mem::align_of::<pm_buffer_t>() - 8usize];
    ["Offset of field: pm_buffer_t::length"][::std::mem::offset_of!(pm_buffer_t, length) - 0usize];
    ["Offset of field: pm_buffer_t::capacity"]
        [::std::mem::offset_of!(pm_buffer_t, capacity) - 8usize];
    ["Offset of field: pm_buffer_t::value"][::std::mem::offset_of!(pm_buffer_t, value) - 16usize];
};
unsafe extern "C" {
    #[doc = " Return the size of the pm_buffer_t struct.\n\n @returns The size of the pm_buffer_t struct."]
    pub fn pm_buffer_sizeof() -> usize;
}
unsafe extern "C" {
    #[doc = " Initialize a pm_buffer_t with the given capacity.\n\n @param buffer The buffer to initialize.\n @param capacity The capacity of the buffer.\n @returns True if the buffer was initialized successfully, false otherwise."]
    pub fn pm_buffer_init_capacity(buffer: *mut pm_buffer_t, capacity: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Initialize a pm_buffer_t with its default values.\n\n @param buffer The buffer to initialize.\n @returns True if the buffer was initialized successfully, false otherwise."]
    pub fn pm_buffer_init(buffer: *mut pm_buffer_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Return the value of the buffer.\n\n @param buffer The buffer to get the value of.\n @returns The value of the buffer."]
    pub fn pm_buffer_value(buffer: *const pm_buffer_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return the length of the buffer.\n\n @param buffer The buffer to get the length of.\n @returns The length of the buffer."]
    pub fn pm_buffer_length(buffer: *const pm_buffer_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Append the given amount of space as zeroes to the buffer.\n\n @param buffer The buffer to append to.\n @param length The amount of space to append and zero."]
    pub fn pm_buffer_append_zeroes(buffer: *mut pm_buffer_t, length: usize);
}
unsafe extern "C" {
    #[doc = " Append a formatted string to the buffer.\n\n @param buffer The buffer to append to.\n @param format The format string to append.\n @param ... The arguments to the format string."]
    pub fn pm_buffer_append_format(
        buffer: *mut pm_buffer_t,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " Append a string to the buffer.\n\n @param buffer The buffer to append to.\n @param value The string to append.\n @param length The length of the string to append."]
    pub fn pm_buffer_append_string(
        buffer: *mut pm_buffer_t,
        value: *const ::std::os::raw::c_char,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Append a list of bytes to the buffer.\n\n @param buffer The buffer to append to.\n @param value The bytes to append.\n @param length The length of the bytes to append."]
    pub fn pm_buffer_append_bytes(buffer: *mut pm_buffer_t, value: *const u8, length: usize);
}
unsafe extern "C" {
    #[doc = " Append a single byte to the buffer.\n\n @param buffer The buffer to append to.\n @param value The byte to append."]
    pub fn pm_buffer_append_byte(buffer: *mut pm_buffer_t, value: u8);
}
unsafe extern "C" {
    #[doc = " Append a 32-bit unsigned integer to the buffer as a variable-length integer.\n\n @param buffer The buffer to append to.\n @param value The integer to append."]
    pub fn pm_buffer_append_varuint(buffer: *mut pm_buffer_t, value: u32);
}
unsafe extern "C" {
    #[doc = " Append a 32-bit signed integer to the buffer as a variable-length integer.\n\n @param buffer The buffer to append to.\n @param value The integer to append."]
    pub fn pm_buffer_append_varsint(buffer: *mut pm_buffer_t, value: i32);
}
unsafe extern "C" {
    #[doc = " Append a double to the buffer.\n\n @param buffer The buffer to append to.\n @param value The double to append."]
    pub fn pm_buffer_append_double(buffer: *mut pm_buffer_t, value: f64);
}
unsafe extern "C" {
    #[doc = " Append a unicode codepoint to the buffer.\n\n @param buffer The buffer to append to.\n @param value The character to append.\n @returns True if the codepoint was valid and appended successfully, false\n   otherwise."]
    pub fn pm_buffer_append_unicode_codepoint(buffer: *mut pm_buffer_t, value: u32) -> bool;
}
pub const pm_buffer_escaping_t_PM_BUFFER_ESCAPING_RUBY: pm_buffer_escaping_t = 0;
pub const pm_buffer_escaping_t_PM_BUFFER_ESCAPING_JSON: pm_buffer_escaping_t = 1;
#[doc = " The different types of escaping that can be performed by the buffer when\n appending a slice of Ruby source code."]
pub type pm_buffer_escaping_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Append a slice of source code to the buffer.\n\n @param buffer The buffer to append to.\n @param source The source code to append.\n @param length The length of the source code to append.\n @param escaping The type of escaping to perform."]
    pub fn pm_buffer_append_source(
        buffer: *mut pm_buffer_t,
        source: *const u8,
        length: usize,
        escaping: pm_buffer_escaping_t,
    );
}
unsafe extern "C" {
    #[doc = " Prepend the given string to the buffer.\n\n @param buffer The buffer to prepend to.\n @param value The string to prepend.\n @param length The length of the string to prepend."]
    pub fn pm_buffer_prepend_string(
        buffer: *mut pm_buffer_t,
        value: *const ::std::os::raw::c_char,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Concatenate one buffer onto another.\n\n @param destination The buffer to concatenate onto.\n @param source The buffer to concatenate."]
    pub fn pm_buffer_concat(destination: *mut pm_buffer_t, source: *const pm_buffer_t);
}
unsafe extern "C" {
    #[doc = " Clear the buffer by reducing its size to 0. This does not free the allocated\n memory, but it does allow the buffer to be reused.\n\n @param buffer The buffer to clear."]
    pub fn pm_buffer_clear(buffer: *mut pm_buffer_t);
}
unsafe extern "C" {
    #[doc = " Strip the whitespace from the end of the buffer.\n\n @param buffer The buffer to strip."]
    pub fn pm_buffer_rstrip(buffer: *mut pm_buffer_t);
}
unsafe extern "C" {
    #[doc = " Checks if the buffer includes the given value.\n\n @param buffer The buffer to check.\n @param value The value to check for.\n @returns The index of the first occurrence of the value in the buffer, or\n   SIZE_MAX if the value is not found."]
    pub fn pm_buffer_index(buffer: *const pm_buffer_t, value: ::std::os::raw::c_char) -> usize;
}
unsafe extern "C" {
    #[doc = " Insert the given string into the buffer at the given index.\n\n @param buffer The buffer to insert into.\n @param index The index to insert at.\n @param value The string to insert.\n @param length The length of the string to insert."]
    pub fn pm_buffer_insert(
        buffer: *mut pm_buffer_t,
        index: usize,
        value: *const ::std::os::raw::c_char,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = " Free the memory associated with the buffer.\n\n @param buffer The buffer to free."]
    pub fn pm_buffer_free(buffer: *mut pm_buffer_t);
}
#[doc = " A structure represents an arbitrary-sized integer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_integer_t {
    #[doc = " The number of allocated values. length is set to 0 if the integer fits\n into uint32_t."]
    pub length: usize,
    #[doc = " List of 32-bit integers. Set to NULL if the integer fits into uint32_t."]
    pub values: *mut u32,
    #[doc = " Embedded value for small integer. This value is set to 0 if the value\n does not fit into uint32_t."]
    pub value: u32,
    #[doc = " Whether or not the integer is negative. It is stored this way so that a\n zeroed pm_integer_t is always positive zero."]
    pub negative: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_integer_t"][::std::mem::size_of::<pm_integer_t>() - 24usize];
    ["Alignment of pm_integer_t"][::std::mem::align_of::<pm_integer_t>() - 8usize];
    ["Offset of field: pm_integer_t::length"]
        [::std::mem::offset_of!(pm_integer_t, length) - 0usize];
    ["Offset of field: pm_integer_t::values"]
        [::std::mem::offset_of!(pm_integer_t, values) - 8usize];
    ["Offset of field: pm_integer_t::value"][::std::mem::offset_of!(pm_integer_t, value) - 16usize];
    ["Offset of field: pm_integer_t::negative"]
        [::std::mem::offset_of!(pm_integer_t, negative) - 20usize];
};
#[doc = " The default decimal base, with no prefix. Leading 0s will be ignored."]
pub const pm_integer_base_t_PM_INTEGER_BASE_DEFAULT: pm_integer_base_t = 0;
#[doc = " The binary base, indicated by a 0b or 0B prefix."]
pub const pm_integer_base_t_PM_INTEGER_BASE_BINARY: pm_integer_base_t = 1;
#[doc = " The octal base, indicated by a 0, 0o, or 0O prefix."]
pub const pm_integer_base_t_PM_INTEGER_BASE_OCTAL: pm_integer_base_t = 2;
#[doc = " The decimal base, indicated by a 0d, 0D, or empty prefix."]
pub const pm_integer_base_t_PM_INTEGER_BASE_DECIMAL: pm_integer_base_t = 3;
#[doc = " The hexadecimal base, indicated by a 0x or 0X prefix."]
pub const pm_integer_base_t_PM_INTEGER_BASE_HEXADECIMAL: pm_integer_base_t = 4;
#[doc = " An unknown base, in which case pm_integer_parse will derive it based on\n the content of the string. This is less efficient and does more\n comparisons, so if callers know the base ahead of time, they should use\n that instead."]
pub const pm_integer_base_t_PM_INTEGER_BASE_UNKNOWN: pm_integer_base_t = 5;
#[doc = " An enum controlling the base of an integer. It is expected that the base is\n already known before parsing the integer, even though it could be derived\n from the string itself."]
pub type pm_integer_base_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Parse an integer from a string. This assumes that the format of the integer\n has already been validated, as internal validation checks are not performed\n here.\n\n @param integer The integer to parse into.\n @param base The base of the integer.\n @param start The start of the string.\n @param end The end of the string."]
    pub fn pm_integer_parse(
        integer: *mut pm_integer_t,
        base: pm_integer_base_t,
        start: *const u8,
        end: *const u8,
    );
}
unsafe extern "C" {
    #[doc = " Compare two integers. This function returns -1 if the left integer is less\n than the right integer, 0 if they are equal, and 1 if the left integer is\n greater than the right integer.\n\n @param left The left integer to compare.\n @param right The right integer to compare.\n @return The result of the comparison."]
    pub fn pm_integer_compare(
        left: *const pm_integer_t,
        right: *const pm_integer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reduce a ratio of integers to its simplest form.\n\n If either the numerator or denominator do not fit into a 32-bit integer, then\n this function is a no-op. In the future, we may consider reducing even the\n larger numbers, but for now we're going to keep it simple.\n\n @param numerator The numerator of the ratio.\n @param denominator The denominator of the ratio."]
    pub fn pm_integers_reduce(numerator: *mut pm_integer_t, denominator: *mut pm_integer_t);
}
unsafe extern "C" {
    #[doc = " Convert an integer to a decimal string.\n\n @param buffer The buffer to append the string to.\n @param integer The integer to convert to a string."]
    pub fn pm_integer_string(buffer: *mut pm_buffer_t, integer: *const pm_integer_t);
}
unsafe extern "C" {
    #[doc = " Free the internal memory of an integer. This memory will only be allocated if\n the integer exceeds the size of a single node in the linked list.\n\n @param integer The integer to free."]
    pub fn pm_integer_free(integer: *mut pm_integer_t);
}
unsafe extern "C" {
    #[doc = " Compare two strings, ignoring case, up to the given length. Returns 0 if the\n strings are equal, a negative number if string1 is less than string2, or a\n positive number if string1 is greater than string2.\n\n Note that this is effectively our own implementation of strncasecmp, but it's\n not available on all of the platforms we want to support so we're rolling it\n here.\n\n @param string1 The first string to compare.\n @param string2 The second string to compare\n @param length The maximum number of characters to compare.\n @return 0 if the strings are equal, a negative number if string1 is less than\n     string2, or a positive number if string1 is greater than string2."]
    pub fn pm_strncasecmp(
        string1: *const u8,
        string2: *const u8,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This struct defines the functions necessary to implement the encoding\n interface so we can determine how many bytes the subsequent character takes.\n Each callback should return the number of bytes, or 0 if the next bytes are\n invalid for the encoding and type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_encoding_t {
    #[doc = " Return the number of bytes that the next character takes if it is valid\n in the encoding. Does not read more than n bytes. It is assumed that n is\n at least 1."]
    pub char_width: ::std::option::Option<unsafe extern "C" fn(b: *const u8, n: isize) -> usize>,
    #[doc = " Return the number of bytes that the next character takes if it is valid\n in the encoding and is alphabetical. Does not read more than n bytes. It\n is assumed that n is at least 1."]
    pub alpha_char: ::std::option::Option<unsafe extern "C" fn(b: *const u8, n: isize) -> usize>,
    #[doc = " Return the number of bytes that the next character takes if it is valid\n in the encoding and is alphanumeric. Does not read more than n bytes. It\n is assumed that n is at least 1."]
    pub alnum_char: ::std::option::Option<unsafe extern "C" fn(b: *const u8, n: isize) -> usize>,
    #[doc = " Return true if the next character is valid in the encoding and is an\n uppercase character. Does not read more than n bytes. It is assumed that\n n is at least 1."]
    pub isupper_char: ::std::option::Option<unsafe extern "C" fn(b: *const u8, n: isize) -> bool>,
    #[doc = " The name of the encoding. This should correspond to a value that can be\n passed to Encoding.find in Ruby."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Return true if the encoding is a multibyte encoding."]
    pub multibyte: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_encoding_t"][::std::mem::size_of::<pm_encoding_t>() - 48usize];
    ["Alignment of pm_encoding_t"][::std::mem::align_of::<pm_encoding_t>() - 8usize];
    ["Offset of field: pm_encoding_t::char_width"]
        [::std::mem::offset_of!(pm_encoding_t, char_width) - 0usize];
    ["Offset of field: pm_encoding_t::alpha_char"]
        [::std::mem::offset_of!(pm_encoding_t, alpha_char) - 8usize];
    ["Offset of field: pm_encoding_t::alnum_char"]
        [::std::mem::offset_of!(pm_encoding_t, alnum_char) - 16usize];
    ["Offset of field: pm_encoding_t::isupper_char"]
        [::std::mem::offset_of!(pm_encoding_t, isupper_char) - 24usize];
    ["Offset of field: pm_encoding_t::name"][::std::mem::offset_of!(pm_encoding_t, name) - 32usize];
    ["Offset of field: pm_encoding_t::multibyte"]
        [::std::mem::offset_of!(pm_encoding_t, multibyte) - 40usize];
};
unsafe extern "C" {
    #[doc = " Return the size of the next character in the UTF-8 encoding.\n\n @param b The bytes to read.\n @param n The number of bytes that can be read.\n @returns The number of bytes that the next character takes if it is valid in\n     the encoding, or 0 if it is not."]
    pub fn pm_encoding_utf_8_char_width(b: *const u8, n: isize) -> usize;
}
unsafe extern "C" {
    #[doc = " Return the size of the next character in the UTF-8 encoding if it is an\n alphabetical character.\n\n @param b The bytes to read.\n @param n The number of bytes that can be read.\n @returns The number of bytes that the next character takes if it is valid in\n     the encoding, or 0 if it is not."]
    pub fn pm_encoding_utf_8_alpha_char(b: *const u8, n: isize) -> usize;
}
unsafe extern "C" {
    #[doc = " Return the size of the next character in the UTF-8 encoding if it is an\n alphanumeric character.\n\n @param b The bytes to read.\n @param n The number of bytes that can be read.\n @returns The number of bytes that the next character takes if it is valid in\n     the encoding, or 0 if it is not."]
    pub fn pm_encoding_utf_8_alnum_char(b: *const u8, n: isize) -> usize;
}
unsafe extern "C" {
    #[doc = " Return true if the next character in the UTF-8 encoding if it is an uppercase\n character.\n\n @param b The bytes to read.\n @param n The number of bytes that can be read.\n @returns True if the next character is valid in the encoding and is an\n     uppercase character, or false if it is not."]
    pub fn pm_encoding_utf_8_isupper_char(b: *const u8, n: isize) -> bool;
}
unsafe extern "C" {
    #[doc = " This lookup table is referenced in both the UTF-8 encoding file and the\n parser directly in order to speed up the default encoding processing. It is\n used to indicate whether a character is alphabetical, alphanumeric, or\n uppercase in unicode mappings."]
    pub static pm_encoding_unicode_table: [u8; 256usize];
}
pub const pm_encoding_type_t_PM_ENCODING_UTF_8: pm_encoding_type_t = 0;
pub const pm_encoding_type_t_PM_ENCODING_US_ASCII: pm_encoding_type_t = 1;
pub const pm_encoding_type_t_PM_ENCODING_ASCII_8BIT: pm_encoding_type_t = 2;
pub const pm_encoding_type_t_PM_ENCODING_EUC_JP: pm_encoding_type_t = 3;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_31J: pm_encoding_type_t = 4;
pub const pm_encoding_type_t_PM_ENCODING_BIG5: pm_encoding_type_t = 5;
pub const pm_encoding_type_t_PM_ENCODING_BIG5_HKSCS: pm_encoding_type_t = 6;
pub const pm_encoding_type_t_PM_ENCODING_BIG5_UAO: pm_encoding_type_t = 7;
pub const pm_encoding_type_t_PM_ENCODING_CESU_8: pm_encoding_type_t = 8;
pub const pm_encoding_type_t_PM_ENCODING_CP51932: pm_encoding_type_t = 9;
pub const pm_encoding_type_t_PM_ENCODING_CP850: pm_encoding_type_t = 10;
pub const pm_encoding_type_t_PM_ENCODING_CP852: pm_encoding_type_t = 11;
pub const pm_encoding_type_t_PM_ENCODING_CP855: pm_encoding_type_t = 12;
pub const pm_encoding_type_t_PM_ENCODING_CP949: pm_encoding_type_t = 13;
pub const pm_encoding_type_t_PM_ENCODING_CP950: pm_encoding_type_t = 14;
pub const pm_encoding_type_t_PM_ENCODING_CP951: pm_encoding_type_t = 15;
pub const pm_encoding_type_t_PM_ENCODING_EMACS_MULE: pm_encoding_type_t = 16;
pub const pm_encoding_type_t_PM_ENCODING_EUC_JP_MS: pm_encoding_type_t = 17;
pub const pm_encoding_type_t_PM_ENCODING_EUC_JIS_2004: pm_encoding_type_t = 18;
pub const pm_encoding_type_t_PM_ENCODING_EUC_KR: pm_encoding_type_t = 19;
pub const pm_encoding_type_t_PM_ENCODING_EUC_TW: pm_encoding_type_t = 20;
pub const pm_encoding_type_t_PM_ENCODING_GB12345: pm_encoding_type_t = 21;
pub const pm_encoding_type_t_PM_ENCODING_GB18030: pm_encoding_type_t = 22;
pub const pm_encoding_type_t_PM_ENCODING_GB1988: pm_encoding_type_t = 23;
pub const pm_encoding_type_t_PM_ENCODING_GB2312: pm_encoding_type_t = 24;
pub const pm_encoding_type_t_PM_ENCODING_GBK: pm_encoding_type_t = 25;
pub const pm_encoding_type_t_PM_ENCODING_IBM437: pm_encoding_type_t = 26;
pub const pm_encoding_type_t_PM_ENCODING_IBM720: pm_encoding_type_t = 27;
pub const pm_encoding_type_t_PM_ENCODING_IBM737: pm_encoding_type_t = 28;
pub const pm_encoding_type_t_PM_ENCODING_IBM775: pm_encoding_type_t = 29;
pub const pm_encoding_type_t_PM_ENCODING_IBM852: pm_encoding_type_t = 30;
pub const pm_encoding_type_t_PM_ENCODING_IBM855: pm_encoding_type_t = 31;
pub const pm_encoding_type_t_PM_ENCODING_IBM857: pm_encoding_type_t = 32;
pub const pm_encoding_type_t_PM_ENCODING_IBM860: pm_encoding_type_t = 33;
pub const pm_encoding_type_t_PM_ENCODING_IBM861: pm_encoding_type_t = 34;
pub const pm_encoding_type_t_PM_ENCODING_IBM862: pm_encoding_type_t = 35;
pub const pm_encoding_type_t_PM_ENCODING_IBM863: pm_encoding_type_t = 36;
pub const pm_encoding_type_t_PM_ENCODING_IBM864: pm_encoding_type_t = 37;
pub const pm_encoding_type_t_PM_ENCODING_IBM865: pm_encoding_type_t = 38;
pub const pm_encoding_type_t_PM_ENCODING_IBM866: pm_encoding_type_t = 39;
pub const pm_encoding_type_t_PM_ENCODING_IBM869: pm_encoding_type_t = 40;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_1: pm_encoding_type_t = 41;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_2: pm_encoding_type_t = 42;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_3: pm_encoding_type_t = 43;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_4: pm_encoding_type_t = 44;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_5: pm_encoding_type_t = 45;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_6: pm_encoding_type_t = 46;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_7: pm_encoding_type_t = 47;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_8: pm_encoding_type_t = 48;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_9: pm_encoding_type_t = 49;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_10: pm_encoding_type_t = 50;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_11: pm_encoding_type_t = 51;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_13: pm_encoding_type_t = 52;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_14: pm_encoding_type_t = 53;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_15: pm_encoding_type_t = 54;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_16: pm_encoding_type_t = 55;
pub const pm_encoding_type_t_PM_ENCODING_KOI8_R: pm_encoding_type_t = 56;
pub const pm_encoding_type_t_PM_ENCODING_KOI8_U: pm_encoding_type_t = 57;
pub const pm_encoding_type_t_PM_ENCODING_MAC_CENT_EURO: pm_encoding_type_t = 58;
pub const pm_encoding_type_t_PM_ENCODING_MAC_CROATIAN: pm_encoding_type_t = 59;
pub const pm_encoding_type_t_PM_ENCODING_MAC_CYRILLIC: pm_encoding_type_t = 60;
pub const pm_encoding_type_t_PM_ENCODING_MAC_GREEK: pm_encoding_type_t = 61;
pub const pm_encoding_type_t_PM_ENCODING_MAC_ICELAND: pm_encoding_type_t = 62;
pub const pm_encoding_type_t_PM_ENCODING_MAC_JAPANESE: pm_encoding_type_t = 63;
pub const pm_encoding_type_t_PM_ENCODING_MAC_ROMAN: pm_encoding_type_t = 64;
pub const pm_encoding_type_t_PM_ENCODING_MAC_ROMANIA: pm_encoding_type_t = 65;
pub const pm_encoding_type_t_PM_ENCODING_MAC_THAI: pm_encoding_type_t = 66;
pub const pm_encoding_type_t_PM_ENCODING_MAC_TURKISH: pm_encoding_type_t = 67;
pub const pm_encoding_type_t_PM_ENCODING_MAC_UKRAINE: pm_encoding_type_t = 68;
pub const pm_encoding_type_t_PM_ENCODING_SHIFT_JIS: pm_encoding_type_t = 69;
pub const pm_encoding_type_t_PM_ENCODING_SJIS_DOCOMO: pm_encoding_type_t = 70;
pub const pm_encoding_type_t_PM_ENCODING_SJIS_KDDI: pm_encoding_type_t = 71;
pub const pm_encoding_type_t_PM_ENCODING_SJIS_SOFTBANK: pm_encoding_type_t = 72;
pub const pm_encoding_type_t_PM_ENCODING_STATELESS_ISO_2022_JP: pm_encoding_type_t = 73;
pub const pm_encoding_type_t_PM_ENCODING_STATELESS_ISO_2022_JP_KDDI: pm_encoding_type_t = 74;
pub const pm_encoding_type_t_PM_ENCODING_TIS_620: pm_encoding_type_t = 75;
pub const pm_encoding_type_t_PM_ENCODING_UTF8_MAC: pm_encoding_type_t = 76;
pub const pm_encoding_type_t_PM_ENCODING_UTF8_DOCOMO: pm_encoding_type_t = 77;
pub const pm_encoding_type_t_PM_ENCODING_UTF8_KDDI: pm_encoding_type_t = 78;
pub const pm_encoding_type_t_PM_ENCODING_UTF8_SOFTBANK: pm_encoding_type_t = 79;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1250: pm_encoding_type_t = 80;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1251: pm_encoding_type_t = 81;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1252: pm_encoding_type_t = 82;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1253: pm_encoding_type_t = 83;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1254: pm_encoding_type_t = 84;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1255: pm_encoding_type_t = 85;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1256: pm_encoding_type_t = 86;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1257: pm_encoding_type_t = 87;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1258: pm_encoding_type_t = 88;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_874: pm_encoding_type_t = 89;
pub const pm_encoding_type_t_PM_ENCODING_MAXIMUM: pm_encoding_type_t = 90;
#[doc = " These are all of the encodings that prism supports."]
pub type pm_encoding_type_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " This is the table of all of the encodings that prism supports."]
    pub static pm_encodings: [pm_encoding_t; 90usize];
}
unsafe extern "C" {
    #[doc = " Parse the given name of an encoding and return a pointer to the corresponding\n encoding struct if one can be found, otherwise return NULL.\n\n @param start A pointer to the first byte of the name.\n @param end A pointer to the last byte of the name.\n @returns A pointer to the encoding struct if one is found, otherwise NULL."]
    pub fn pm_encoding_find(start: *const u8, end: *const u8) -> *const pm_encoding_t;
}
unsafe extern "C" {
    #[doc = " We need to roll our own memchr to handle cases where the encoding changes and\n we need to search for a character in a buffer that could be the trailing byte\n of a multibyte character.\n\n @param source The source string.\n @param character The character to search for.\n @param number The maximum number of bytes to search.\n @param encoding_changed Whether the encoding changed.\n @param encoding A pointer to the encoding.\n @return A pointer to the first occurrence of the character in the source\n     string, or NULL if no such character exists."]
    pub fn pm_memchr(
        source: *const ::std::os::raw::c_void,
        character: ::std::os::raw::c_int,
        number: usize,
        encoding_changed: bool,
        encoding: *const pm_encoding_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " A constant id is a unique identifier for a constant in the constant pool."]
pub type pm_constant_id_t = u32;
#[doc = " A list of constant IDs. Usually used to represent a set of locals."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_id_list_t {
    #[doc = " The number of constant ids in the list."]
    pub size: usize,
    #[doc = " The number of constant ids that have been allocated in the list."]
    pub capacity: usize,
    #[doc = " The constant ids in the list."]
    pub ids: *mut pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_id_list_t"][::std::mem::size_of::<pm_constant_id_list_t>() - 24usize];
    ["Alignment of pm_constant_id_list_t"]
        [::std::mem::align_of::<pm_constant_id_list_t>() - 8usize];
    ["Offset of field: pm_constant_id_list_t::size"]
        [::std::mem::offset_of!(pm_constant_id_list_t, size) - 0usize];
    ["Offset of field: pm_constant_id_list_t::capacity"]
        [::std::mem::offset_of!(pm_constant_id_list_t, capacity) - 8usize];
    ["Offset of field: pm_constant_id_list_t::ids"]
        [::std::mem::offset_of!(pm_constant_id_list_t, ids) - 16usize];
};
unsafe extern "C" {
    #[doc = " Initialize a list of constant ids.\n\n @param list The list to initialize."]
    pub fn pm_constant_id_list_init(list: *mut pm_constant_id_list_t);
}
unsafe extern "C" {
    #[doc = " Initialize a list of constant ids with a given capacity.\n\n @param list The list to initialize.\n @param capacity The initial capacity of the list."]
    pub fn pm_constant_id_list_init_capacity(list: *mut pm_constant_id_list_t, capacity: usize);
}
unsafe extern "C" {
    #[doc = " Append a constant id to a list of constant ids. Returns false if any\n potential reallocations fail.\n\n @param list The list to append to.\n @param id The id to append.\n @return Whether the append succeeded."]
    pub fn pm_constant_id_list_append(
        list: *mut pm_constant_id_list_t,
        id: pm_constant_id_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Insert a constant id into a list of constant ids at the specified index.\n\n @param list The list to insert into.\n @param index The index at which to insert.\n @param id The id to insert."]
    pub fn pm_constant_id_list_insert(
        list: *mut pm_constant_id_list_t,
        index: usize,
        id: pm_constant_id_t,
    );
}
unsafe extern "C" {
    #[doc = " Checks if the current constant id list includes the given constant id.\n\n @param list The list to check.\n @param id The id to check for.\n @return Whether the list includes the given id."]
    pub fn pm_constant_id_list_includes(
        list: *mut pm_constant_id_list_t,
        id: pm_constant_id_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Free the memory associated with a list of constant ids.\n\n @param list The list to free."]
    pub fn pm_constant_id_list_free(list: *mut pm_constant_id_list_t);
}
#[doc = " The type of bucket in the constant pool hash map. This determines how the\n bucket should be freed."]
pub type pm_constant_pool_bucket_type_t = ::std::os::raw::c_uint;
#[doc = " By default, each constant is a slice of the source."]
pub const PM_CONSTANT_POOL_BUCKET_DEFAULT: pm_constant_pool_bucket_type_t = 0;
#[doc = " An owned constant is one for which memory has been allocated."]
pub const PM_CONSTANT_POOL_BUCKET_OWNED: pm_constant_pool_bucket_type_t = 1;
#[doc = " A constant constant is known at compile time."]
pub const PM_CONSTANT_POOL_BUCKET_CONSTANT: pm_constant_pool_bucket_type_t = 2;
#[doc = " A bucket in the hash map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_pool_bucket_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " The hash of the bucket."]
    pub hash: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_pool_bucket_t"]
        [::std::mem::size_of::<pm_constant_pool_bucket_t>() - 8usize];
    ["Alignment of pm_constant_pool_bucket_t"]
        [::std::mem::align_of::<pm_constant_pool_bucket_t>() - 4usize];
    ["Offset of field: pm_constant_pool_bucket_t::hash"]
        [::std::mem::offset_of!(pm_constant_pool_bucket_t, hash) - 4usize];
};
impl pm_constant_pool_bucket_t {
    #[inline]
    pub fn id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn id_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_id_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> pm_constant_pool_bucket_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: pm_constant_pool_bucket_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> pm_constant_pool_bucket_type_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: pm_constant_pool_bucket_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        id: ::std::os::raw::c_uint,
        type_: pm_constant_pool_bucket_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A constant in the pool which effectively stores a string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_t {
    #[doc = " A pointer to the start of the string."]
    pub start: *const u8,
    #[doc = " The length of the string."]
    pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_t"][::std::mem::size_of::<pm_constant_t>() - 16usize];
    ["Alignment of pm_constant_t"][::std::mem::align_of::<pm_constant_t>() - 8usize];
    ["Offset of field: pm_constant_t::start"]
        [::std::mem::offset_of!(pm_constant_t, start) - 0usize];
    ["Offset of field: pm_constant_t::length"]
        [::std::mem::offset_of!(pm_constant_t, length) - 8usize];
};
#[doc = " The overall constant pool, which stores constants found while parsing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_pool_t {
    #[doc = " The buckets in the hash map."]
    pub buckets: *mut pm_constant_pool_bucket_t,
    #[doc = " The constants that are stored in the buckets."]
    pub constants: *mut pm_constant_t,
    #[doc = " The number of buckets in the hash map."]
    pub size: u32,
    #[doc = " The number of buckets that have been allocated in the hash map."]
    pub capacity: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_pool_t"][::std::mem::size_of::<pm_constant_pool_t>() - 24usize];
    ["Alignment of pm_constant_pool_t"][::std::mem::align_of::<pm_constant_pool_t>() - 8usize];
    ["Offset of field: pm_constant_pool_t::buckets"]
        [::std::mem::offset_of!(pm_constant_pool_t, buckets) - 0usize];
    ["Offset of field: pm_constant_pool_t::constants"]
        [::std::mem::offset_of!(pm_constant_pool_t, constants) - 8usize];
    ["Offset of field: pm_constant_pool_t::size"]
        [::std::mem::offset_of!(pm_constant_pool_t, size) - 16usize];
    ["Offset of field: pm_constant_pool_t::capacity"]
        [::std::mem::offset_of!(pm_constant_pool_t, capacity) - 20usize];
};
unsafe extern "C" {
    #[doc = " Initialize a new constant pool with a given capacity.\n\n @param pool The pool to initialize.\n @param capacity The initial capacity of the pool.\n @return Whether the initialization succeeded."]
    pub fn pm_constant_pool_init(pool: *mut pm_constant_pool_t, capacity: u32) -> bool;
}
unsafe extern "C" {
    #[doc = " Return a pointer to the constant indicated by the given constant id.\n\n @param pool The pool to get the constant from.\n @param constant_id The id of the constant to get.\n @return A pointer to the constant."]
    pub fn pm_constant_pool_id_to_constant(
        pool: *const pm_constant_pool_t,
        constant_id: pm_constant_id_t,
    ) -> *mut pm_constant_t;
}
unsafe extern "C" {
    #[doc = " Find a constant in a constant pool. Returns the id of the constant, or 0 if\n the constant is not found.\n\n @param pool The pool to find the constant in.\n @param start A pointer to the start of the constant.\n @param length The length of the constant.\n @return The id of the constant."]
    pub fn pm_constant_pool_find(
        pool: *const pm_constant_pool_t,
        start: *const u8,
        length: usize,
    ) -> pm_constant_id_t;
}
unsafe extern "C" {
    #[doc = " Insert a constant into a constant pool that is a slice of a source string.\n Returns the id of the constant, or 0 if any potential calls to resize fail.\n\n @param pool The pool to insert the constant into.\n @param start A pointer to the start of the constant.\n @param length The length of the constant.\n @return The id of the constant."]
    pub fn pm_constant_pool_insert_shared(
        pool: *mut pm_constant_pool_t,
        start: *const u8,
        length: usize,
    ) -> pm_constant_id_t;
}
unsafe extern "C" {
    #[doc = " Insert a constant into a constant pool from memory that is now owned by the\n constant pool. Returns the id of the constant, or 0 if any potential calls to\n resize fail.\n\n @param pool The pool to insert the constant into.\n @param start A pointer to the start of the constant.\n @param length The length of the constant.\n @return The id of the constant."]
    pub fn pm_constant_pool_insert_owned(
        pool: *mut pm_constant_pool_t,
        start: *mut u8,
        length: usize,
    ) -> pm_constant_id_t;
}
unsafe extern "C" {
    #[doc = " Insert a constant into a constant pool from memory that is constant. Returns\n the id of the constant, or 0 if any potential calls to resize fail.\n\n @param pool The pool to insert the constant into.\n @param start A pointer to the start of the constant.\n @param length The length of the constant.\n @return The id of the constant."]
    pub fn pm_constant_pool_insert_constant(
        pool: *mut pm_constant_pool_t,
        start: *const u8,
        length: usize,
    ) -> pm_constant_id_t;
}
unsafe extern "C" {
    #[doc = " Free the memory associated with a constant pool.\n\n @param pool The pool to free."]
    pub fn pm_constant_pool_free(pool: *mut pm_constant_pool_t);
}
unsafe extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flock"][::std::mem::size_of::<flock>() - 24usize];
    ["Alignment of flock"][::std::mem::align_of::<flock>() - 8usize];
    ["Offset of field: flock::l_start"][::std::mem::offset_of!(flock, l_start) - 0usize];
    ["Offset of field: flock::l_len"][::std::mem::offset_of!(flock, l_len) - 8usize];
    ["Offset of field: flock::l_pid"][::std::mem::offset_of!(flock, l_pid) - 16usize];
    ["Offset of field: flock::l_type"][::std::mem::offset_of!(flock, l_type) - 20usize];
    ["Offset of field: flock::l_whence"][::std::mem::offset_of!(flock, l_whence) - 22usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flocktimeout {
    pub fl: flock,
    pub timeout: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flocktimeout"][::std::mem::size_of::<flocktimeout>() - 40usize];
    ["Alignment of flocktimeout"][::std::mem::align_of::<flocktimeout>() - 8usize];
    ["Offset of field: flocktimeout::fl"][::std::mem::offset_of!(flocktimeout, fl) - 0usize];
    ["Offset of field: flocktimeout::timeout"]
        [::std::mem::offset_of!(flocktimeout, timeout) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of radvisory"][::std::mem::size_of::<radvisory>() - 16usize];
    ["Alignment of radvisory"][::std::mem::align_of::<radvisory>() - 8usize];
    ["Offset of field: radvisory::ra_offset"]
        [::std::mem::offset_of!(radvisory, ra_offset) - 0usize];
    ["Offset of field: radvisory::ra_count"][::std::mem::offset_of!(radvisory, ra_count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::std::os::raw::c_void,
    pub fs_blob_size: usize,
    pub fs_fsignatures_size: usize,
    pub fs_cdhash: [::std::os::raw::c_char; 20usize],
    pub fs_hash_type: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fsignatures"][::std::mem::size_of::<fsignatures>() - 56usize];
    ["Alignment of fsignatures"][::std::mem::align_of::<fsignatures>() - 8usize];
    ["Offset of field: fsignatures::fs_file_start"]
        [::std::mem::offset_of!(fsignatures, fs_file_start) - 0usize];
    ["Offset of field: fsignatures::fs_blob_start"]
        [::std::mem::offset_of!(fsignatures, fs_blob_start) - 8usize];
    ["Offset of field: fsignatures::fs_blob_size"]
        [::std::mem::offset_of!(fsignatures, fs_blob_size) - 16usize];
    ["Offset of field: fsignatures::fs_fsignatures_size"]
        [::std::mem::offset_of!(fsignatures, fs_fsignatures_size) - 24usize];
    ["Offset of field: fsignatures::fs_cdhash"]
        [::std::mem::offset_of!(fsignatures, fs_cdhash) - 32usize];
    ["Offset of field: fsignatures::fs_hash_type"]
        [::std::mem::offset_of!(fsignatures, fs_hash_type) - 52usize];
};
pub type fsignatures_t = fsignatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsupplement {
    pub fs_file_start: off_t,
    pub fs_blob_start: off_t,
    pub fs_blob_size: usize,
    pub fs_orig_fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fsupplement"][::std::mem::size_of::<fsupplement>() - 32usize];
    ["Alignment of fsupplement"][::std::mem::align_of::<fsupplement>() - 8usize];
    ["Offset of field: fsupplement::fs_file_start"]
        [::std::mem::offset_of!(fsupplement, fs_file_start) - 0usize];
    ["Offset of field: fsupplement::fs_blob_start"]
        [::std::mem::offset_of!(fsupplement, fs_blob_start) - 8usize];
    ["Offset of field: fsupplement::fs_blob_size"]
        [::std::mem::offset_of!(fsupplement, fs_blob_size) - 16usize];
    ["Offset of field: fsupplement::fs_orig_fd"]
        [::std::mem::offset_of!(fsupplement, fs_orig_fd) - 24usize];
};
pub type fsupplement_t = fsupplement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fchecklv {
    pub lv_file_start: off_t,
    pub lv_error_message_size: usize,
    pub lv_error_message: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fchecklv"][::std::mem::size_of::<fchecklv>() - 24usize];
    ["Alignment of fchecklv"][::std::mem::align_of::<fchecklv>() - 8usize];
    ["Offset of field: fchecklv::lv_file_start"]
        [::std::mem::offset_of!(fchecklv, lv_file_start) - 0usize];
    ["Offset of field: fchecklv::lv_error_message_size"]
        [::std::mem::offset_of!(fchecklv, lv_error_message_size) - 8usize];
    ["Offset of field: fchecklv::lv_error_message"]
        [::std::mem::offset_of!(fchecklv, lv_error_message) - 16usize];
};
pub type fchecklv_t = fchecklv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fgetsigsinfo {
    pub fg_file_start: off_t,
    pub fg_info_request: ::std::os::raw::c_int,
    pub fg_sig_is_platform: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fgetsigsinfo"][::std::mem::size_of::<fgetsigsinfo>() - 16usize];
    ["Alignment of fgetsigsinfo"][::std::mem::align_of::<fgetsigsinfo>() - 8usize];
    ["Offset of field: fgetsigsinfo::fg_file_start"]
        [::std::mem::offset_of!(fgetsigsinfo, fg_file_start) - 0usize];
    ["Offset of field: fgetsigsinfo::fg_info_request"]
        [::std::mem::offset_of!(fgetsigsinfo, fg_info_request) - 8usize];
    ["Offset of field: fgetsigsinfo::fg_sig_is_platform"]
        [::std::mem::offset_of!(fgetsigsinfo, fg_sig_is_platform) - 12usize];
};
pub type fgetsigsinfo_t = fgetsigsinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fstore {
    pub fst_flags: ::std::os::raw::c_uint,
    pub fst_posmode: ::std::os::raw::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fstore"][::std::mem::size_of::<fstore>() - 32usize];
    ["Alignment of fstore"][::std::mem::align_of::<fstore>() - 8usize];
    ["Offset of field: fstore::fst_flags"][::std::mem::offset_of!(fstore, fst_flags) - 0usize];
    ["Offset of field: fstore::fst_posmode"][::std::mem::offset_of!(fstore, fst_posmode) - 4usize];
    ["Offset of field: fstore::fst_offset"][::std::mem::offset_of!(fstore, fst_offset) - 8usize];
    ["Offset of field: fstore::fst_length"][::std::mem::offset_of!(fstore, fst_length) - 16usize];
    ["Offset of field: fstore::fst_bytesalloc"]
        [::std::mem::offset_of!(fstore, fst_bytesalloc) - 24usize];
};
pub type fstore_t = fstore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpunchhole {
    pub fp_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fp_offset: off_t,
    pub fp_length: off_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fpunchhole"][::std::mem::size_of::<fpunchhole>() - 24usize];
    ["Alignment of fpunchhole"][::std::mem::align_of::<fpunchhole>() - 8usize];
    ["Offset of field: fpunchhole::fp_flags"]
        [::std::mem::offset_of!(fpunchhole, fp_flags) - 0usize];
    ["Offset of field: fpunchhole::reserved"]
        [::std::mem::offset_of!(fpunchhole, reserved) - 4usize];
    ["Offset of field: fpunchhole::fp_offset"]
        [::std::mem::offset_of!(fpunchhole, fp_offset) - 8usize];
    ["Offset of field: fpunchhole::fp_length"]
        [::std::mem::offset_of!(fpunchhole, fp_length) - 16usize];
};
pub type fpunchhole_t = fpunchhole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrimactivefile {
    pub fta_offset: off_t,
    pub fta_length: off_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ftrimactivefile"][::std::mem::size_of::<ftrimactivefile>() - 16usize];
    ["Alignment of ftrimactivefile"][::std::mem::align_of::<ftrimactivefile>() - 8usize];
    ["Offset of field: ftrimactivefile::fta_offset"]
        [::std::mem::offset_of!(ftrimactivefile, fta_offset) - 0usize];
    ["Offset of field: ftrimactivefile::fta_length"]
        [::std::mem::offset_of!(ftrimactivefile, fta_length) - 8usize];
};
pub type ftrimactivefile_t = ftrimactivefile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspecread {
    pub fsr_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fsr_offset: off_t,
    pub fsr_length: off_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fspecread"][::std::mem::size_of::<fspecread>() - 24usize];
    ["Alignment of fspecread"][::std::mem::align_of::<fspecread>() - 8usize];
    ["Offset of field: fspecread::fsr_flags"]
        [::std::mem::offset_of!(fspecread, fsr_flags) - 0usize];
    ["Offset of field: fspecread::reserved"][::std::mem::offset_of!(fspecread, reserved) - 4usize];
    ["Offset of field: fspecread::fsr_offset"]
        [::std::mem::offset_of!(fspecread, fsr_offset) - 8usize];
    ["Offset of field: fspecread::fsr_length"]
        [::std::mem::offset_of!(fspecread, fsr_length) - 16usize];
};
pub type fspecread_t = fspecread;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fattributiontag {
    pub ft_flags: ::std::os::raw::c_uint,
    pub ft_hash: ::std::os::raw::c_ulonglong,
    pub ft_attribution_name: [::std::os::raw::c_char; 255usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fattributiontag"][::std::mem::size_of::<fattributiontag>() - 272usize];
    ["Alignment of fattributiontag"][::std::mem::align_of::<fattributiontag>() - 8usize];
    ["Offset of field: fattributiontag::ft_flags"]
        [::std::mem::offset_of!(fattributiontag, ft_flags) - 0usize];
    ["Offset of field: fattributiontag::ft_hash"]
        [::std::mem::offset_of!(fattributiontag, ft_hash) - 8usize];
    ["Offset of field: fattributiontag::ft_attribution_name"]
        [::std::mem::offset_of!(fattributiontag, ft_attribution_name) - 16usize];
};
pub type fattributiontag_t = fattributiontag;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct log2phys {
    pub l2p_flags: ::std::os::raw::c_uint,
    pub l2p_contigbytes: off_t,
    pub l2p_devoffset: off_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of log2phys"][::std::mem::size_of::<log2phys>() - 20usize];
    ["Alignment of log2phys"][::std::mem::align_of::<log2phys>() - 4usize];
    ["Offset of field: log2phys::l2p_flags"][::std::mem::offset_of!(log2phys, l2p_flags) - 0usize];
    ["Offset of field: log2phys::l2p_contigbytes"]
        [::std::mem::offset_of!(log2phys, l2p_contigbytes) - 4usize];
    ["Offset of field: log2phys::l2p_devoffset"]
        [::std::mem::offset_of!(log2phys, l2p_devoffset) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
pub const filesec_property_t_FILESEC_OWNER: filesec_property_t = 1;
pub const filesec_property_t_FILESEC_GROUP: filesec_property_t = 2;
pub const filesec_property_t_FILESEC_UUID: filesec_property_t = 3;
pub const filesec_property_t_FILESEC_MODE: filesec_property_t = 4;
pub const filesec_property_t_FILESEC_ACL: filesec_property_t = 5;
pub const filesec_property_t_FILESEC_GRPUUID: filesec_property_t = 6;
pub const filesec_property_t_FILESEC_ACL_RAW: filesec_property_t = 100;
pub const filesec_property_t_FILESEC_ACL_ALLOCSIZE: filesec_property_t = 101;
pub type filesec_property_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn openat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn creat(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcntl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn openx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn open_dprotected_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn openat_dprotected_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn openat_authenticated_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flock(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn filesec_init() -> filesec_t;
}
unsafe extern "C" {
    pub fn filesec_dup(arg1: filesec_t) -> filesec_t;
}
unsafe extern "C" {
    pub fn filesec_free(arg1: filesec_t);
}
unsafe extern "C" {
    pub fn filesec_get_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn filesec_query_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn filesec_set_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn filesec_unset_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlockall(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn munlockall() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mlock(arg1: *const ::std::os::raw::c_void, arg2: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mmap(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: off_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mprotect(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn msync(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn munlock(arg1: *const ::std::os::raw::c_void, arg2: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn munmap(arg1: *mut ::std::os::raw::c_void, arg2: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn shm_open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn shm_unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_madvise(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn madvise(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mincore(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn minherit(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ostat {
    pub st_dev: __uint16_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: __uint16_t,
    pub st_gid: __uint16_t,
    pub st_rdev: __uint16_t,
    pub st_size: __int32_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_blksize: __int32_t,
    pub st_blocks: __int32_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ostat"][::std::mem::size_of::<ostat>() - 96usize];
    ["Alignment of ostat"][::std::mem::align_of::<ostat>() - 8usize];
    ["Offset of field: ostat::st_dev"][::std::mem::offset_of!(ostat, st_dev) - 0usize];
    ["Offset of field: ostat::st_ino"][::std::mem::offset_of!(ostat, st_ino) - 8usize];
    ["Offset of field: ostat::st_mode"][::std::mem::offset_of!(ostat, st_mode) - 16usize];
    ["Offset of field: ostat::st_nlink"][::std::mem::offset_of!(ostat, st_nlink) - 18usize];
    ["Offset of field: ostat::st_uid"][::std::mem::offset_of!(ostat, st_uid) - 20usize];
    ["Offset of field: ostat::st_gid"][::std::mem::offset_of!(ostat, st_gid) - 22usize];
    ["Offset of field: ostat::st_rdev"][::std::mem::offset_of!(ostat, st_rdev) - 24usize];
    ["Offset of field: ostat::st_size"][::std::mem::offset_of!(ostat, st_size) - 28usize];
    ["Offset of field: ostat::st_atimespec"][::std::mem::offset_of!(ostat, st_atimespec) - 32usize];
    ["Offset of field: ostat::st_mtimespec"][::std::mem::offset_of!(ostat, st_mtimespec) - 48usize];
    ["Offset of field: ostat::st_ctimespec"][::std::mem::offset_of!(ostat, st_ctimespec) - 64usize];
    ["Offset of field: ostat::st_blksize"][::std::mem::offset_of!(ostat, st_blksize) - 80usize];
    ["Offset of field: ostat::st_blocks"][::std::mem::offset_of!(ostat, st_blocks) - 84usize];
    ["Offset of field: ostat::st_flags"][::std::mem::offset_of!(ostat, st_flags) - 88usize];
    ["Offset of field: ostat::st_gen"][::std::mem::offset_of!(ostat, st_gen) - 92usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stat"][::std::mem::size_of::<stat>() - 144usize];
    ["Alignment of stat"][::std::mem::align_of::<stat>() - 8usize];
    ["Offset of field: stat::st_dev"][::std::mem::offset_of!(stat, st_dev) - 0usize];
    ["Offset of field: stat::st_mode"][::std::mem::offset_of!(stat, st_mode) - 4usize];
    ["Offset of field: stat::st_nlink"][::std::mem::offset_of!(stat, st_nlink) - 6usize];
    ["Offset of field: stat::st_ino"][::std::mem::offset_of!(stat, st_ino) - 8usize];
    ["Offset of field: stat::st_uid"][::std::mem::offset_of!(stat, st_uid) - 16usize];
    ["Offset of field: stat::st_gid"][::std::mem::offset_of!(stat, st_gid) - 20usize];
    ["Offset of field: stat::st_rdev"][::std::mem::offset_of!(stat, st_rdev) - 24usize];
    ["Offset of field: stat::st_atimespec"][::std::mem::offset_of!(stat, st_atimespec) - 32usize];
    ["Offset of field: stat::st_mtimespec"][::std::mem::offset_of!(stat, st_mtimespec) - 48usize];
    ["Offset of field: stat::st_ctimespec"][::std::mem::offset_of!(stat, st_ctimespec) - 64usize];
    ["Offset of field: stat::st_birthtimespec"]
        [::std::mem::offset_of!(stat, st_birthtimespec) - 80usize];
    ["Offset of field: stat::st_size"][::std::mem::offset_of!(stat, st_size) - 96usize];
    ["Offset of field: stat::st_blocks"][::std::mem::offset_of!(stat, st_blocks) - 104usize];
    ["Offset of field: stat::st_blksize"][::std::mem::offset_of!(stat, st_blksize) - 112usize];
    ["Offset of field: stat::st_flags"][::std::mem::offset_of!(stat, st_flags) - 116usize];
    ["Offset of field: stat::st_gen"][::std::mem::offset_of!(stat, st_gen) - 120usize];
    ["Offset of field: stat::st_lspare"][::std::mem::offset_of!(stat, st_lspare) - 124usize];
    ["Offset of field: stat::st_qspare"][::std::mem::offset_of!(stat, st_qspare) - 128usize];
};
unsafe extern "C" {
    pub fn chmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchmod(arg1: ::std::os::raw::c_int, arg2: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fstat(arg1: ::std::os::raw::c_int, arg2: *mut stat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lstat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdir(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkfifo(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn stat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn umask(arg1: mode_t) -> mode_t;
}
unsafe extern "C" {
    pub fn fchmodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fstatat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut stat,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdirat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkfifoat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mknodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: dev_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chmodx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchflags(arg1: ::std::os::raw::c_int, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchmodx_np(arg1: ::std::os::raw::c_int, arg2: filesec_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fstatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lchflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lchmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lstatx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdirx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkfifox_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: filesec_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn statx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn umaskx_np(arg1: filesec_t) -> ::std::os::raw::c_int;
}
#[doc = " A generic string type that can have various ownership semantics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_string_t {
    #[doc = " A pointer to the start of the string."]
    pub source: *const u8,
    #[doc = " The length of the string in bytes of memory."]
    pub length: usize,
    pub type_: pm_string_t__bindgen_ty_1,
}
#[doc = " This string is a constant string, and should not be freed."]
pub const pm_string_t_PM_STRING_CONSTANT: pm_string_t__bindgen_ty_1 = 0;
#[doc = " This is a slice of another string, and should not be freed."]
pub const pm_string_t_PM_STRING_SHARED: pm_string_t__bindgen_ty_1 = 1;
#[doc = " This string owns its memory, and should be freed using `pm_string_free`."]
pub const pm_string_t_PM_STRING_OWNED: pm_string_t__bindgen_ty_1 = 2;
#[doc = " This string is a memory-mapped file, and should be freed using `pm_string_free`."]
pub const pm_string_t_PM_STRING_MAPPED: pm_string_t__bindgen_ty_1 = 3;
#[doc = " The type of the string. This field determines how the string should be freed."]
pub type pm_string_t__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_string_t"][::std::mem::size_of::<pm_string_t>() - 24usize];
    ["Alignment of pm_string_t"][::std::mem::align_of::<pm_string_t>() - 8usize];
    ["Offset of field: pm_string_t::source"][::std::mem::offset_of!(pm_string_t, source) - 0usize];
    ["Offset of field: pm_string_t::length"][::std::mem::offset_of!(pm_string_t, length) - 8usize];
    ["Offset of field: pm_string_t::type_"][::std::mem::offset_of!(pm_string_t, type_) - 16usize];
};
unsafe extern "C" {
    #[doc = " Returns the size of the pm_string_t struct. This is necessary to allocate the\n correct amount of memory in the FFI backend.\n\n @return The size of the pm_string_t struct."]
    pub fn pm_string_sizeof() -> usize;
}
unsafe extern "C" {
    #[doc = " Initialize a shared string that is based on initial input.\n\n @param string The string to initialize.\n @param start The start of the string.\n @param end The end of the string."]
    pub fn pm_string_shared_init(string: *mut pm_string_t, start: *const u8, end: *const u8);
}
unsafe extern "C" {
    #[doc = " Initialize an owned string that is responsible for freeing allocated memory.\n\n @param string The string to initialize.\n @param source The source of the string.\n @param length The length of the string."]
    pub fn pm_string_owned_init(string: *mut pm_string_t, source: *mut u8, length: usize);
}
unsafe extern "C" {
    #[doc = " Initialize a constant string that doesn't own its memory source.\n\n @param string The string to initialize.\n @param source The source of the string.\n @param length The length of the string."]
    pub fn pm_string_constant_init(
        string: *mut pm_string_t,
        source: *const ::std::os::raw::c_char,
        length: usize,
    );
}
#[doc = " Indicates that the string was successfully initialized."]
pub const pm_string_init_result_t_PM_STRING_INIT_SUCCESS: pm_string_init_result_t = 0;
#[doc = " Indicates a generic error from a string_*_init function, where the type\n of error should be read from `errno` or `GetLastError()`."]
pub const pm_string_init_result_t_PM_STRING_INIT_ERROR_GENERIC: pm_string_init_result_t = 1;
#[doc = " Indicates that the file that was attempted to be opened was a directory."]
pub const pm_string_init_result_t_PM_STRING_INIT_ERROR_DIRECTORY: pm_string_init_result_t = 2;
#[doc = " Represents the result of calling pm_string_mapped_init or\n pm_string_file_init. We need this additional information because there is\n not a platform-agnostic way to indicate that the file that was attempted to\n be opened was a directory."]
pub type pm_string_init_result_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Read the file indicated by the filepath parameter into source and load its\n contents and size into the given `pm_string_t`. The given `pm_string_t`\n should be freed using `pm_string_free` when it is no longer used.\n\n We want to use demand paging as much as possible in order to avoid having to\n read the entire file into memory (which could be detrimental to performance\n for large files). This means that if we're on windows we'll use\n `MapViewOfFile`, on POSIX systems that have access to `mmap` we'll use\n `mmap`, and on other POSIX systems we'll use `read`.\n\n @param string The string to initialize.\n @param filepath The filepath to read.\n @return The success of the read, indicated by the value of the enum."]
    pub fn pm_string_mapped_init(
        string: *mut pm_string_t,
        filepath: *const ::std::os::raw::c_char,
    ) -> pm_string_init_result_t;
}
unsafe extern "C" {
    #[doc = " Read the file indicated by the filepath parameter into source and load its\n contents and size into the given `pm_string_t`. The given `pm_string_t`\n should be freed using `pm_string_free` when it is no longer used.\n\n @param string The string to initialize.\n @param filepath The filepath to read.\n @return The success of the read, indicated by the value of the enum."]
    pub fn pm_string_file_init(
        string: *mut pm_string_t,
        filepath: *const ::std::os::raw::c_char,
    ) -> pm_string_init_result_t;
}
unsafe extern "C" {
    #[doc = " Ensure the string is owned. If it is not, then reinitialize it as owned and\n copy over the previous source.\n\n @param string The string to ensure is owned."]
    pub fn pm_string_ensure_owned(string: *mut pm_string_t);
}
unsafe extern "C" {
    #[doc = " Compare the underlying lengths and bytes of two strings. Returns 0 if the\n strings are equal, a negative number if the left string is less than the\n right string, and a positive number if the left string is greater than the\n right string.\n\n @param left The left string to compare.\n @param right The right string to compare.\n @return The comparison result."]
    pub fn pm_string_compare(
        left: *const pm_string_t,
        right: *const pm_string_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the length associated with the string.\n\n @param string The string to get the length of.\n @return The length of the string."]
    pub fn pm_string_length(string: *const pm_string_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the start pointer associated with the string.\n\n @param string The string to get the start pointer of.\n @return The start pointer of the string."]
    pub fn pm_string_source(string: *const pm_string_t) -> *const u8;
}
unsafe extern "C" {
    #[doc = " Free the associated memory of the given string.\n\n @param string The string to free."]
    pub fn pm_string_free(string: *mut pm_string_t);
}
#[doc = " final token in the file"]
pub const pm_token_type_PM_TOKEN_EOF: pm_token_type = 1;
#[doc = " a token that was expected but not found"]
pub const pm_token_type_PM_TOKEN_MISSING: pm_token_type = 2;
#[doc = " a token that was not present but it is okay"]
pub const pm_token_type_PM_TOKEN_NOT_PROVIDED: pm_token_type = 3;
#[doc = " &"]
pub const pm_token_type_PM_TOKEN_AMPERSAND: pm_token_type = 4;
#[doc = " &&"]
pub const pm_token_type_PM_TOKEN_AMPERSAND_AMPERSAND: pm_token_type = 5;
#[doc = " &&="]
pub const pm_token_type_PM_TOKEN_AMPERSAND_AMPERSAND_EQUAL: pm_token_type = 6;
#[doc = " &."]
pub const pm_token_type_PM_TOKEN_AMPERSAND_DOT: pm_token_type = 7;
#[doc = " &="]
pub const pm_token_type_PM_TOKEN_AMPERSAND_EQUAL: pm_token_type = 8;
#[doc = " `"]
pub const pm_token_type_PM_TOKEN_BACKTICK: pm_token_type = 9;
#[doc = " a back reference"]
pub const pm_token_type_PM_TOKEN_BACK_REFERENCE: pm_token_type = 10;
#[doc = " ! or !@"]
pub const pm_token_type_PM_TOKEN_BANG: pm_token_type = 11;
#[doc = " !="]
pub const pm_token_type_PM_TOKEN_BANG_EQUAL: pm_token_type = 12;
#[doc = " !~"]
pub const pm_token_type_PM_TOKEN_BANG_TILDE: pm_token_type = 13;
#[doc = " {"]
pub const pm_token_type_PM_TOKEN_BRACE_LEFT: pm_token_type = 14;
#[doc = " }"]
pub const pm_token_type_PM_TOKEN_BRACE_RIGHT: pm_token_type = 15;
#[doc = " ["]
pub const pm_token_type_PM_TOKEN_BRACKET_LEFT: pm_token_type = 16;
#[doc = " [ for the beginning of an array"]
pub const pm_token_type_PM_TOKEN_BRACKET_LEFT_ARRAY: pm_token_type = 17;
#[doc = " []"]
pub const pm_token_type_PM_TOKEN_BRACKET_LEFT_RIGHT: pm_token_type = 18;
#[doc = " []="]
pub const pm_token_type_PM_TOKEN_BRACKET_LEFT_RIGHT_EQUAL: pm_token_type = 19;
#[doc = " ]"]
pub const pm_token_type_PM_TOKEN_BRACKET_RIGHT: pm_token_type = 20;
#[doc = " ^"]
pub const pm_token_type_PM_TOKEN_CARET: pm_token_type = 21;
#[doc = " ^="]
pub const pm_token_type_PM_TOKEN_CARET_EQUAL: pm_token_type = 22;
#[doc = " a character literal"]
pub const pm_token_type_PM_TOKEN_CHARACTER_LITERAL: pm_token_type = 23;
#[doc = " a class variable"]
pub const pm_token_type_PM_TOKEN_CLASS_VARIABLE: pm_token_type = 24;
#[doc = " :"]
pub const pm_token_type_PM_TOKEN_COLON: pm_token_type = 25;
#[doc = " ::"]
pub const pm_token_type_PM_TOKEN_COLON_COLON: pm_token_type = 26;
#[doc = " ,"]
pub const pm_token_type_PM_TOKEN_COMMA: pm_token_type = 27;
#[doc = " a comment"]
pub const pm_token_type_PM_TOKEN_COMMENT: pm_token_type = 28;
#[doc = " a constant"]
pub const pm_token_type_PM_TOKEN_CONSTANT: pm_token_type = 29;
#[doc = " the . call operator"]
pub const pm_token_type_PM_TOKEN_DOT: pm_token_type = 30;
#[doc = " the .. range operator"]
pub const pm_token_type_PM_TOKEN_DOT_DOT: pm_token_type = 31;
#[doc = " the ... range operator or forwarding parameter"]
pub const pm_token_type_PM_TOKEN_DOT_DOT_DOT: pm_token_type = 32;
#[doc = " =begin"]
pub const pm_token_type_PM_TOKEN_EMBDOC_BEGIN: pm_token_type = 33;
#[doc = " =end"]
pub const pm_token_type_PM_TOKEN_EMBDOC_END: pm_token_type = 34;
#[doc = " a line inside of embedded documentation"]
pub const pm_token_type_PM_TOKEN_EMBDOC_LINE: pm_token_type = 35;
#[doc = " #{"]
pub const pm_token_type_PM_TOKEN_EMBEXPR_BEGIN: pm_token_type = 36;
#[doc = " }"]
pub const pm_token_type_PM_TOKEN_EMBEXPR_END: pm_token_type = 37;
#[doc = " #"]
pub const pm_token_type_PM_TOKEN_EMBVAR: pm_token_type = 38;
#[doc = " ="]
pub const pm_token_type_PM_TOKEN_EQUAL: pm_token_type = 39;
#[doc = " =="]
pub const pm_token_type_PM_TOKEN_EQUAL_EQUAL: pm_token_type = 40;
#[doc = " ==="]
pub const pm_token_type_PM_TOKEN_EQUAL_EQUAL_EQUAL: pm_token_type = 41;
#[doc = " =>"]
pub const pm_token_type_PM_TOKEN_EQUAL_GREATER: pm_token_type = 42;
#[doc = " =~"]
pub const pm_token_type_PM_TOKEN_EQUAL_TILDE: pm_token_type = 43;
#[doc = " a floating point number"]
pub const pm_token_type_PM_TOKEN_FLOAT: pm_token_type = 44;
#[doc = " a floating pointer number with an imaginary suffix"]
pub const pm_token_type_PM_TOKEN_FLOAT_IMAGINARY: pm_token_type = 45;
#[doc = " a floating pointer number with a rational suffix"]
pub const pm_token_type_PM_TOKEN_FLOAT_RATIONAL: pm_token_type = 46;
#[doc = " a floating pointer number with a rational and imaginary suffix"]
pub const pm_token_type_PM_TOKEN_FLOAT_RATIONAL_IMAGINARY: pm_token_type = 47;
#[doc = " a global variable"]
pub const pm_token_type_PM_TOKEN_GLOBAL_VARIABLE: pm_token_type = 48;
#[doc = " >"]
pub const pm_token_type_PM_TOKEN_GREATER: pm_token_type = 49;
#[doc = " >="]
pub const pm_token_type_PM_TOKEN_GREATER_EQUAL: pm_token_type = 50;
#[doc = " >>"]
pub const pm_token_type_PM_TOKEN_GREATER_GREATER: pm_token_type = 51;
#[doc = " >>="]
pub const pm_token_type_PM_TOKEN_GREATER_GREATER_EQUAL: pm_token_type = 52;
#[doc = " the end of a heredoc"]
pub const pm_token_type_PM_TOKEN_HEREDOC_END: pm_token_type = 53;
#[doc = " the start of a heredoc"]
pub const pm_token_type_PM_TOKEN_HEREDOC_START: pm_token_type = 54;
#[doc = " an identifier"]
pub const pm_token_type_PM_TOKEN_IDENTIFIER: pm_token_type = 55;
#[doc = " an ignored newline"]
pub const pm_token_type_PM_TOKEN_IGNORED_NEWLINE: pm_token_type = 56;
#[doc = " an instance variable"]
pub const pm_token_type_PM_TOKEN_INSTANCE_VARIABLE: pm_token_type = 57;
#[doc = " an integer (any base)"]
pub const pm_token_type_PM_TOKEN_INTEGER: pm_token_type = 58;
#[doc = " an integer with an imaginary suffix"]
pub const pm_token_type_PM_TOKEN_INTEGER_IMAGINARY: pm_token_type = 59;
#[doc = " an integer with a rational suffix"]
pub const pm_token_type_PM_TOKEN_INTEGER_RATIONAL: pm_token_type = 60;
#[doc = " an integer with a rational and imaginary suffix"]
pub const pm_token_type_PM_TOKEN_INTEGER_RATIONAL_IMAGINARY: pm_token_type = 61;
#[doc = " alias"]
pub const pm_token_type_PM_TOKEN_KEYWORD_ALIAS: pm_token_type = 62;
#[doc = " and"]
pub const pm_token_type_PM_TOKEN_KEYWORD_AND: pm_token_type = 63;
#[doc = " begin"]
pub const pm_token_type_PM_TOKEN_KEYWORD_BEGIN: pm_token_type = 64;
#[doc = " BEGIN"]
pub const pm_token_type_PM_TOKEN_KEYWORD_BEGIN_UPCASE: pm_token_type = 65;
#[doc = " break"]
pub const pm_token_type_PM_TOKEN_KEYWORD_BREAK: pm_token_type = 66;
#[doc = " case"]
pub const pm_token_type_PM_TOKEN_KEYWORD_CASE: pm_token_type = 67;
#[doc = " class"]
pub const pm_token_type_PM_TOKEN_KEYWORD_CLASS: pm_token_type = 68;
#[doc = " def"]
pub const pm_token_type_PM_TOKEN_KEYWORD_DEF: pm_token_type = 69;
#[doc = " defined?"]
pub const pm_token_type_PM_TOKEN_KEYWORD_DEFINED: pm_token_type = 70;
#[doc = " do"]
pub const pm_token_type_PM_TOKEN_KEYWORD_DO: pm_token_type = 71;
#[doc = " do keyword for a predicate in a while, until, or for loop"]
pub const pm_token_type_PM_TOKEN_KEYWORD_DO_LOOP: pm_token_type = 72;
#[doc = " else"]
pub const pm_token_type_PM_TOKEN_KEYWORD_ELSE: pm_token_type = 73;
#[doc = " elsif"]
pub const pm_token_type_PM_TOKEN_KEYWORD_ELSIF: pm_token_type = 74;
#[doc = " end"]
pub const pm_token_type_PM_TOKEN_KEYWORD_END: pm_token_type = 75;
#[doc = " END"]
pub const pm_token_type_PM_TOKEN_KEYWORD_END_UPCASE: pm_token_type = 76;
#[doc = " ensure"]
pub const pm_token_type_PM_TOKEN_KEYWORD_ENSURE: pm_token_type = 77;
#[doc = " false"]
pub const pm_token_type_PM_TOKEN_KEYWORD_FALSE: pm_token_type = 78;
#[doc = " for"]
pub const pm_token_type_PM_TOKEN_KEYWORD_FOR: pm_token_type = 79;
#[doc = " if"]
pub const pm_token_type_PM_TOKEN_KEYWORD_IF: pm_token_type = 80;
#[doc = " if in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_IF_MODIFIER: pm_token_type = 81;
#[doc = " in"]
pub const pm_token_type_PM_TOKEN_KEYWORD_IN: pm_token_type = 82;
#[doc = " module"]
pub const pm_token_type_PM_TOKEN_KEYWORD_MODULE: pm_token_type = 83;
#[doc = " next"]
pub const pm_token_type_PM_TOKEN_KEYWORD_NEXT: pm_token_type = 84;
#[doc = " nil"]
pub const pm_token_type_PM_TOKEN_KEYWORD_NIL: pm_token_type = 85;
#[doc = " not"]
pub const pm_token_type_PM_TOKEN_KEYWORD_NOT: pm_token_type = 86;
#[doc = " or"]
pub const pm_token_type_PM_TOKEN_KEYWORD_OR: pm_token_type = 87;
#[doc = " redo"]
pub const pm_token_type_PM_TOKEN_KEYWORD_REDO: pm_token_type = 88;
#[doc = " rescue"]
pub const pm_token_type_PM_TOKEN_KEYWORD_RESCUE: pm_token_type = 89;
#[doc = " rescue in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_RESCUE_MODIFIER: pm_token_type = 90;
#[doc = " retry"]
pub const pm_token_type_PM_TOKEN_KEYWORD_RETRY: pm_token_type = 91;
#[doc = " return"]
pub const pm_token_type_PM_TOKEN_KEYWORD_RETURN: pm_token_type = 92;
#[doc = " self"]
pub const pm_token_type_PM_TOKEN_KEYWORD_SELF: pm_token_type = 93;
#[doc = " super"]
pub const pm_token_type_PM_TOKEN_KEYWORD_SUPER: pm_token_type = 94;
#[doc = " then"]
pub const pm_token_type_PM_TOKEN_KEYWORD_THEN: pm_token_type = 95;
#[doc = " true"]
pub const pm_token_type_PM_TOKEN_KEYWORD_TRUE: pm_token_type = 96;
#[doc = " undef"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNDEF: pm_token_type = 97;
#[doc = " unless"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNLESS: pm_token_type = 98;
#[doc = " unless in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNLESS_MODIFIER: pm_token_type = 99;
#[doc = " until"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNTIL: pm_token_type = 100;
#[doc = " until in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNTIL_MODIFIER: pm_token_type = 101;
#[doc = " when"]
pub const pm_token_type_PM_TOKEN_KEYWORD_WHEN: pm_token_type = 102;
#[doc = " while"]
pub const pm_token_type_PM_TOKEN_KEYWORD_WHILE: pm_token_type = 103;
#[doc = " while in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_WHILE_MODIFIER: pm_token_type = 104;
#[doc = " yield"]
pub const pm_token_type_PM_TOKEN_KEYWORD_YIELD: pm_token_type = 105;
#[doc = " __ENCODING__"]
pub const pm_token_type_PM_TOKEN_KEYWORD___ENCODING__: pm_token_type = 106;
#[doc = " __FILE__"]
pub const pm_token_type_PM_TOKEN_KEYWORD___FILE__: pm_token_type = 107;
#[doc = " __LINE__"]
pub const pm_token_type_PM_TOKEN_KEYWORD___LINE__: pm_token_type = 108;
#[doc = " a label"]
pub const pm_token_type_PM_TOKEN_LABEL: pm_token_type = 109;
#[doc = " the end of a label"]
pub const pm_token_type_PM_TOKEN_LABEL_END: pm_token_type = 110;
#[doc = " {"]
pub const pm_token_type_PM_TOKEN_LAMBDA_BEGIN: pm_token_type = 111;
#[doc = " <"]
pub const pm_token_type_PM_TOKEN_LESS: pm_token_type = 112;
#[doc = " <="]
pub const pm_token_type_PM_TOKEN_LESS_EQUAL: pm_token_type = 113;
#[doc = " <=>"]
pub const pm_token_type_PM_TOKEN_LESS_EQUAL_GREATER: pm_token_type = 114;
#[doc = " <<"]
pub const pm_token_type_PM_TOKEN_LESS_LESS: pm_token_type = 115;
#[doc = " <<="]
pub const pm_token_type_PM_TOKEN_LESS_LESS_EQUAL: pm_token_type = 116;
#[doc = " a method name"]
pub const pm_token_type_PM_TOKEN_METHOD_NAME: pm_token_type = 117;
#[doc = " -"]
pub const pm_token_type_PM_TOKEN_MINUS: pm_token_type = 118;
#[doc = " -="]
pub const pm_token_type_PM_TOKEN_MINUS_EQUAL: pm_token_type = 119;
#[doc = " ->"]
pub const pm_token_type_PM_TOKEN_MINUS_GREATER: pm_token_type = 120;
#[doc = " a newline character outside of other tokens"]
pub const pm_token_type_PM_TOKEN_NEWLINE: pm_token_type = 121;
#[doc = " a numbered reference to a capture group in the previous regular expression match"]
pub const pm_token_type_PM_TOKEN_NUMBERED_REFERENCE: pm_token_type = 122;
#[doc = " ("]
pub const pm_token_type_PM_TOKEN_PARENTHESIS_LEFT: pm_token_type = 123;
#[doc = " ( for a parentheses node"]
pub const pm_token_type_PM_TOKEN_PARENTHESIS_LEFT_PARENTHESES: pm_token_type = 124;
#[doc = " )"]
pub const pm_token_type_PM_TOKEN_PARENTHESIS_RIGHT: pm_token_type = 125;
#[doc = " %"]
pub const pm_token_type_PM_TOKEN_PERCENT: pm_token_type = 126;
#[doc = " %="]
pub const pm_token_type_PM_TOKEN_PERCENT_EQUAL: pm_token_type = 127;
#[doc = " %i"]
pub const pm_token_type_PM_TOKEN_PERCENT_LOWER_I: pm_token_type = 128;
#[doc = " %w"]
pub const pm_token_type_PM_TOKEN_PERCENT_LOWER_W: pm_token_type = 129;
#[doc = " %x"]
pub const pm_token_type_PM_TOKEN_PERCENT_LOWER_X: pm_token_type = 130;
#[doc = " %I"]
pub const pm_token_type_PM_TOKEN_PERCENT_UPPER_I: pm_token_type = 131;
#[doc = " %W"]
pub const pm_token_type_PM_TOKEN_PERCENT_UPPER_W: pm_token_type = 132;
#[doc = " |"]
pub const pm_token_type_PM_TOKEN_PIPE: pm_token_type = 133;
#[doc = " |="]
pub const pm_token_type_PM_TOKEN_PIPE_EQUAL: pm_token_type = 134;
#[doc = " ||"]
pub const pm_token_type_PM_TOKEN_PIPE_PIPE: pm_token_type = 135;
#[doc = " ||="]
pub const pm_token_type_PM_TOKEN_PIPE_PIPE_EQUAL: pm_token_type = 136;
#[doc = " +"]
pub const pm_token_type_PM_TOKEN_PLUS: pm_token_type = 137;
#[doc = " +="]
pub const pm_token_type_PM_TOKEN_PLUS_EQUAL: pm_token_type = 138;
#[doc = " ?"]
pub const pm_token_type_PM_TOKEN_QUESTION_MARK: pm_token_type = 139;
#[doc = " the beginning of a regular expression"]
pub const pm_token_type_PM_TOKEN_REGEXP_BEGIN: pm_token_type = 140;
#[doc = " the end of a regular expression"]
pub const pm_token_type_PM_TOKEN_REGEXP_END: pm_token_type = 141;
#[doc = " ;"]
pub const pm_token_type_PM_TOKEN_SEMICOLON: pm_token_type = 142;
#[doc = " /"]
pub const pm_token_type_PM_TOKEN_SLASH: pm_token_type = 143;
#[doc = " /="]
pub const pm_token_type_PM_TOKEN_SLASH_EQUAL: pm_token_type = 144;
#[doc = " *"]
pub const pm_token_type_PM_TOKEN_STAR: pm_token_type = 145;
#[doc = " *="]
pub const pm_token_type_PM_TOKEN_STAR_EQUAL: pm_token_type = 146;
#[doc = " **"]
pub const pm_token_type_PM_TOKEN_STAR_STAR: pm_token_type = 147;
#[doc = " **="]
pub const pm_token_type_PM_TOKEN_STAR_STAR_EQUAL: pm_token_type = 148;
#[doc = " the beginning of a string"]
pub const pm_token_type_PM_TOKEN_STRING_BEGIN: pm_token_type = 149;
#[doc = " the contents of a string"]
pub const pm_token_type_PM_TOKEN_STRING_CONTENT: pm_token_type = 150;
#[doc = " the end of a string"]
pub const pm_token_type_PM_TOKEN_STRING_END: pm_token_type = 151;
#[doc = " the beginning of a symbol"]
pub const pm_token_type_PM_TOKEN_SYMBOL_BEGIN: pm_token_type = 152;
#[doc = " ~ or ~@"]
pub const pm_token_type_PM_TOKEN_TILDE: pm_token_type = 153;
#[doc = " unary &"]
pub const pm_token_type_PM_TOKEN_UAMPERSAND: pm_token_type = 154;
#[doc = " unary ::"]
pub const pm_token_type_PM_TOKEN_UCOLON_COLON: pm_token_type = 155;
#[doc = " unary .. operator"]
pub const pm_token_type_PM_TOKEN_UDOT_DOT: pm_token_type = 156;
#[doc = " unary ... operator"]
pub const pm_token_type_PM_TOKEN_UDOT_DOT_DOT: pm_token_type = 157;
#[doc = " -@"]
pub const pm_token_type_PM_TOKEN_UMINUS: pm_token_type = 158;
#[doc = " -@ for a number"]
pub const pm_token_type_PM_TOKEN_UMINUS_NUM: pm_token_type = 159;
#[doc = " +@"]
pub const pm_token_type_PM_TOKEN_UPLUS: pm_token_type = 160;
#[doc = " unary *"]
pub const pm_token_type_PM_TOKEN_USTAR: pm_token_type = 161;
#[doc = " unary **"]
pub const pm_token_type_PM_TOKEN_USTAR_STAR: pm_token_type = 162;
#[doc = " a separator between words in a list"]
pub const pm_token_type_PM_TOKEN_WORDS_SEP: pm_token_type = 163;
#[doc = " marker for the point in the file at which the parser should stop"]
pub const pm_token_type_PM_TOKEN___END__: pm_token_type = 164;
#[doc = " The maximum token value."]
pub const pm_token_type_PM_TOKEN_MAXIMUM: pm_token_type = 165;
#[doc = " This enum represents every type of token in the Ruby source."]
pub type pm_token_type = ::std::os::raw::c_uint;
#[doc = " This enum represents every type of token in the Ruby source."]
pub use self::pm_token_type as pm_token_type_t;
#[doc = " This struct represents a token in the Ruby source. We use it to track both\n type and location information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_token_t {
    #[doc = " The type of the token."]
    pub type_: pm_token_type_t,
    #[doc = " A pointer to the start location of the token in the source."]
    pub start: *const u8,
    #[doc = " A pointer to the end location of the token in the source."]
    pub end: *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_token_t"][::std::mem::size_of::<pm_token_t>() - 24usize];
    ["Alignment of pm_token_t"][::std::mem::align_of::<pm_token_t>() - 8usize];
    ["Offset of field: pm_token_t::type_"][::std::mem::offset_of!(pm_token_t, type_) - 0usize];
    ["Offset of field: pm_token_t::start"][::std::mem::offset_of!(pm_token_t, start) - 8usize];
    ["Offset of field: pm_token_t::end"][::std::mem::offset_of!(pm_token_t, end) - 16usize];
};
#[doc = " This represents a range of bytes in the source string to which a node or\n token corresponds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_location_t {
    #[doc = " A pointer to the start location of the range in the source."]
    pub start: *const u8,
    #[doc = " A pointer to the end location of the range in the source."]
    pub end: *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_location_t"][::std::mem::size_of::<pm_location_t>() - 16usize];
    ["Alignment of pm_location_t"][::std::mem::align_of::<pm_location_t>() - 8usize];
    ["Offset of field: pm_location_t::start"]
        [::std::mem::offset_of!(pm_location_t, start) - 0usize];
    ["Offset of field: pm_location_t::end"][::std::mem::offset_of!(pm_location_t, end) - 8usize];
};
#[doc = " A list of nodes in the source, most often used for lists of children."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_node_list {
    #[doc = " The number of nodes in the list."]
    pub size: usize,
    #[doc = " The capacity of the list that has been allocated."]
    pub capacity: usize,
    #[doc = " The nodes in the list."]
    pub nodes: *mut *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_node_list"][::std::mem::size_of::<pm_node_list>() - 24usize];
    ["Alignment of pm_node_list"][::std::mem::align_of::<pm_node_list>() - 8usize];
    ["Offset of field: pm_node_list::size"][::std::mem::offset_of!(pm_node_list, size) - 0usize];
    ["Offset of field: pm_node_list::capacity"]
        [::std::mem::offset_of!(pm_node_list, capacity) - 8usize];
    ["Offset of field: pm_node_list::nodes"][::std::mem::offset_of!(pm_node_list, nodes) - 16usize];
};
#[doc = " A list of nodes in the source, most often used for lists of children."]
pub type pm_node_list_t = pm_node_list;
#[doc = " AliasGlobalVariableNode"]
pub const pm_node_type_PM_ALIAS_GLOBAL_VARIABLE_NODE: pm_node_type = 1;
#[doc = " AliasMethodNode"]
pub const pm_node_type_PM_ALIAS_METHOD_NODE: pm_node_type = 2;
#[doc = " AlternationPatternNode"]
pub const pm_node_type_PM_ALTERNATION_PATTERN_NODE: pm_node_type = 3;
#[doc = " AndNode"]
pub const pm_node_type_PM_AND_NODE: pm_node_type = 4;
#[doc = " ArgumentsNode"]
pub const pm_node_type_PM_ARGUMENTS_NODE: pm_node_type = 5;
#[doc = " ArrayNode"]
pub const pm_node_type_PM_ARRAY_NODE: pm_node_type = 6;
#[doc = " ArrayPatternNode"]
pub const pm_node_type_PM_ARRAY_PATTERN_NODE: pm_node_type = 7;
#[doc = " AssocNode"]
pub const pm_node_type_PM_ASSOC_NODE: pm_node_type = 8;
#[doc = " AssocSplatNode"]
pub const pm_node_type_PM_ASSOC_SPLAT_NODE: pm_node_type = 9;
#[doc = " BackReferenceReadNode"]
pub const pm_node_type_PM_BACK_REFERENCE_READ_NODE: pm_node_type = 10;
#[doc = " BeginNode"]
pub const pm_node_type_PM_BEGIN_NODE: pm_node_type = 11;
#[doc = " BlockArgumentNode"]
pub const pm_node_type_PM_BLOCK_ARGUMENT_NODE: pm_node_type = 12;
#[doc = " BlockLocalVariableNode"]
pub const pm_node_type_PM_BLOCK_LOCAL_VARIABLE_NODE: pm_node_type = 13;
#[doc = " BlockNode"]
pub const pm_node_type_PM_BLOCK_NODE: pm_node_type = 14;
#[doc = " BlockParameterNode"]
pub const pm_node_type_PM_BLOCK_PARAMETER_NODE: pm_node_type = 15;
#[doc = " BlockParametersNode"]
pub const pm_node_type_PM_BLOCK_PARAMETERS_NODE: pm_node_type = 16;
#[doc = " BreakNode"]
pub const pm_node_type_PM_BREAK_NODE: pm_node_type = 17;
#[doc = " CallAndWriteNode"]
pub const pm_node_type_PM_CALL_AND_WRITE_NODE: pm_node_type = 18;
#[doc = " CallNode"]
pub const pm_node_type_PM_CALL_NODE: pm_node_type = 19;
#[doc = " CallOperatorWriteNode"]
pub const pm_node_type_PM_CALL_OPERATOR_WRITE_NODE: pm_node_type = 20;
#[doc = " CallOrWriteNode"]
pub const pm_node_type_PM_CALL_OR_WRITE_NODE: pm_node_type = 21;
#[doc = " CallTargetNode"]
pub const pm_node_type_PM_CALL_TARGET_NODE: pm_node_type = 22;
#[doc = " CapturePatternNode"]
pub const pm_node_type_PM_CAPTURE_PATTERN_NODE: pm_node_type = 23;
#[doc = " CaseMatchNode"]
pub const pm_node_type_PM_CASE_MATCH_NODE: pm_node_type = 24;
#[doc = " CaseNode"]
pub const pm_node_type_PM_CASE_NODE: pm_node_type = 25;
#[doc = " ClassNode"]
pub const pm_node_type_PM_CLASS_NODE: pm_node_type = 26;
#[doc = " ClassVariableAndWriteNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_AND_WRITE_NODE: pm_node_type = 27;
#[doc = " ClassVariableOperatorWriteNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_OPERATOR_WRITE_NODE: pm_node_type = 28;
#[doc = " ClassVariableOrWriteNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_OR_WRITE_NODE: pm_node_type = 29;
#[doc = " ClassVariableReadNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_READ_NODE: pm_node_type = 30;
#[doc = " ClassVariableTargetNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_TARGET_NODE: pm_node_type = 31;
#[doc = " ClassVariableWriteNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_WRITE_NODE: pm_node_type = 32;
#[doc = " ConstantAndWriteNode"]
pub const pm_node_type_PM_CONSTANT_AND_WRITE_NODE: pm_node_type = 33;
#[doc = " ConstantOperatorWriteNode"]
pub const pm_node_type_PM_CONSTANT_OPERATOR_WRITE_NODE: pm_node_type = 34;
#[doc = " ConstantOrWriteNode"]
pub const pm_node_type_PM_CONSTANT_OR_WRITE_NODE: pm_node_type = 35;
#[doc = " ConstantPathAndWriteNode"]
pub const pm_node_type_PM_CONSTANT_PATH_AND_WRITE_NODE: pm_node_type = 36;
#[doc = " ConstantPathNode"]
pub const pm_node_type_PM_CONSTANT_PATH_NODE: pm_node_type = 37;
#[doc = " ConstantPathOperatorWriteNode"]
pub const pm_node_type_PM_CONSTANT_PATH_OPERATOR_WRITE_NODE: pm_node_type = 38;
#[doc = " ConstantPathOrWriteNode"]
pub const pm_node_type_PM_CONSTANT_PATH_OR_WRITE_NODE: pm_node_type = 39;
#[doc = " ConstantPathTargetNode"]
pub const pm_node_type_PM_CONSTANT_PATH_TARGET_NODE: pm_node_type = 40;
#[doc = " ConstantPathWriteNode"]
pub const pm_node_type_PM_CONSTANT_PATH_WRITE_NODE: pm_node_type = 41;
#[doc = " ConstantReadNode"]
pub const pm_node_type_PM_CONSTANT_READ_NODE: pm_node_type = 42;
#[doc = " ConstantTargetNode"]
pub const pm_node_type_PM_CONSTANT_TARGET_NODE: pm_node_type = 43;
#[doc = " ConstantWriteNode"]
pub const pm_node_type_PM_CONSTANT_WRITE_NODE: pm_node_type = 44;
#[doc = " DefNode"]
pub const pm_node_type_PM_DEF_NODE: pm_node_type = 45;
#[doc = " DefinedNode"]
pub const pm_node_type_PM_DEFINED_NODE: pm_node_type = 46;
#[doc = " ElseNode"]
pub const pm_node_type_PM_ELSE_NODE: pm_node_type = 47;
#[doc = " EmbeddedStatementsNode"]
pub const pm_node_type_PM_EMBEDDED_STATEMENTS_NODE: pm_node_type = 48;
#[doc = " EmbeddedVariableNode"]
pub const pm_node_type_PM_EMBEDDED_VARIABLE_NODE: pm_node_type = 49;
#[doc = " EnsureNode"]
pub const pm_node_type_PM_ENSURE_NODE: pm_node_type = 50;
#[doc = " FalseNode"]
pub const pm_node_type_PM_FALSE_NODE: pm_node_type = 51;
#[doc = " FindPatternNode"]
pub const pm_node_type_PM_FIND_PATTERN_NODE: pm_node_type = 52;
#[doc = " FlipFlopNode"]
pub const pm_node_type_PM_FLIP_FLOP_NODE: pm_node_type = 53;
#[doc = " FloatNode"]
pub const pm_node_type_PM_FLOAT_NODE: pm_node_type = 54;
#[doc = " ForNode"]
pub const pm_node_type_PM_FOR_NODE: pm_node_type = 55;
#[doc = " ForwardingArgumentsNode"]
pub const pm_node_type_PM_FORWARDING_ARGUMENTS_NODE: pm_node_type = 56;
#[doc = " ForwardingParameterNode"]
pub const pm_node_type_PM_FORWARDING_PARAMETER_NODE: pm_node_type = 57;
#[doc = " ForwardingSuperNode"]
pub const pm_node_type_PM_FORWARDING_SUPER_NODE: pm_node_type = 58;
#[doc = " GlobalVariableAndWriteNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_AND_WRITE_NODE: pm_node_type = 59;
#[doc = " GlobalVariableOperatorWriteNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE: pm_node_type = 60;
#[doc = " GlobalVariableOrWriteNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_OR_WRITE_NODE: pm_node_type = 61;
#[doc = " GlobalVariableReadNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_READ_NODE: pm_node_type = 62;
#[doc = " GlobalVariableTargetNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_TARGET_NODE: pm_node_type = 63;
#[doc = " GlobalVariableWriteNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_WRITE_NODE: pm_node_type = 64;
#[doc = " HashNode"]
pub const pm_node_type_PM_HASH_NODE: pm_node_type = 65;
#[doc = " HashPatternNode"]
pub const pm_node_type_PM_HASH_PATTERN_NODE: pm_node_type = 66;
#[doc = " IfNode"]
pub const pm_node_type_PM_IF_NODE: pm_node_type = 67;
#[doc = " ImaginaryNode"]
pub const pm_node_type_PM_IMAGINARY_NODE: pm_node_type = 68;
#[doc = " ImplicitNode"]
pub const pm_node_type_PM_IMPLICIT_NODE: pm_node_type = 69;
#[doc = " ImplicitRestNode"]
pub const pm_node_type_PM_IMPLICIT_REST_NODE: pm_node_type = 70;
#[doc = " InNode"]
pub const pm_node_type_PM_IN_NODE: pm_node_type = 71;
#[doc = " IndexAndWriteNode"]
pub const pm_node_type_PM_INDEX_AND_WRITE_NODE: pm_node_type = 72;
#[doc = " IndexOperatorWriteNode"]
pub const pm_node_type_PM_INDEX_OPERATOR_WRITE_NODE: pm_node_type = 73;
#[doc = " IndexOrWriteNode"]
pub const pm_node_type_PM_INDEX_OR_WRITE_NODE: pm_node_type = 74;
#[doc = " IndexTargetNode"]
pub const pm_node_type_PM_INDEX_TARGET_NODE: pm_node_type = 75;
#[doc = " InstanceVariableAndWriteNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_AND_WRITE_NODE: pm_node_type = 76;
#[doc = " InstanceVariableOperatorWriteNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE: pm_node_type = 77;
#[doc = " InstanceVariableOrWriteNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_OR_WRITE_NODE: pm_node_type = 78;
#[doc = " InstanceVariableReadNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_READ_NODE: pm_node_type = 79;
#[doc = " InstanceVariableTargetNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_TARGET_NODE: pm_node_type = 80;
#[doc = " InstanceVariableWriteNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_WRITE_NODE: pm_node_type = 81;
#[doc = " IntegerNode"]
pub const pm_node_type_PM_INTEGER_NODE: pm_node_type = 82;
#[doc = " InterpolatedMatchLastLineNode"]
pub const pm_node_type_PM_INTERPOLATED_MATCH_LAST_LINE_NODE: pm_node_type = 83;
#[doc = " InterpolatedRegularExpressionNode"]
pub const pm_node_type_PM_INTERPOLATED_REGULAR_EXPRESSION_NODE: pm_node_type = 84;
#[doc = " InterpolatedStringNode"]
pub const pm_node_type_PM_INTERPOLATED_STRING_NODE: pm_node_type = 85;
#[doc = " InterpolatedSymbolNode"]
pub const pm_node_type_PM_INTERPOLATED_SYMBOL_NODE: pm_node_type = 86;
#[doc = " InterpolatedXStringNode"]
pub const pm_node_type_PM_INTERPOLATED_X_STRING_NODE: pm_node_type = 87;
#[doc = " ItLocalVariableReadNode"]
pub const pm_node_type_PM_IT_LOCAL_VARIABLE_READ_NODE: pm_node_type = 88;
#[doc = " ItParametersNode"]
pub const pm_node_type_PM_IT_PARAMETERS_NODE: pm_node_type = 89;
#[doc = " KeywordHashNode"]
pub const pm_node_type_PM_KEYWORD_HASH_NODE: pm_node_type = 90;
#[doc = " KeywordRestParameterNode"]
pub const pm_node_type_PM_KEYWORD_REST_PARAMETER_NODE: pm_node_type = 91;
#[doc = " LambdaNode"]
pub const pm_node_type_PM_LAMBDA_NODE: pm_node_type = 92;
#[doc = " LocalVariableAndWriteNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_AND_WRITE_NODE: pm_node_type = 93;
#[doc = " LocalVariableOperatorWriteNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_OPERATOR_WRITE_NODE: pm_node_type = 94;
#[doc = " LocalVariableOrWriteNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_OR_WRITE_NODE: pm_node_type = 95;
#[doc = " LocalVariableReadNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_READ_NODE: pm_node_type = 96;
#[doc = " LocalVariableTargetNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_TARGET_NODE: pm_node_type = 97;
#[doc = " LocalVariableWriteNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_WRITE_NODE: pm_node_type = 98;
#[doc = " MatchLastLineNode"]
pub const pm_node_type_PM_MATCH_LAST_LINE_NODE: pm_node_type = 99;
#[doc = " MatchPredicateNode"]
pub const pm_node_type_PM_MATCH_PREDICATE_NODE: pm_node_type = 100;
#[doc = " MatchRequiredNode"]
pub const pm_node_type_PM_MATCH_REQUIRED_NODE: pm_node_type = 101;
#[doc = " MatchWriteNode"]
pub const pm_node_type_PM_MATCH_WRITE_NODE: pm_node_type = 102;
#[doc = " MissingNode"]
pub const pm_node_type_PM_MISSING_NODE: pm_node_type = 103;
#[doc = " ModuleNode"]
pub const pm_node_type_PM_MODULE_NODE: pm_node_type = 104;
#[doc = " MultiTargetNode"]
pub const pm_node_type_PM_MULTI_TARGET_NODE: pm_node_type = 105;
#[doc = " MultiWriteNode"]
pub const pm_node_type_PM_MULTI_WRITE_NODE: pm_node_type = 106;
#[doc = " NextNode"]
pub const pm_node_type_PM_NEXT_NODE: pm_node_type = 107;
#[doc = " NilNode"]
pub const pm_node_type_PM_NIL_NODE: pm_node_type = 108;
#[doc = " NoKeywordsParameterNode"]
pub const pm_node_type_PM_NO_KEYWORDS_PARAMETER_NODE: pm_node_type = 109;
#[doc = " NumberedParametersNode"]
pub const pm_node_type_PM_NUMBERED_PARAMETERS_NODE: pm_node_type = 110;
#[doc = " NumberedReferenceReadNode"]
pub const pm_node_type_PM_NUMBERED_REFERENCE_READ_NODE: pm_node_type = 111;
#[doc = " OptionalKeywordParameterNode"]
pub const pm_node_type_PM_OPTIONAL_KEYWORD_PARAMETER_NODE: pm_node_type = 112;
#[doc = " OptionalParameterNode"]
pub const pm_node_type_PM_OPTIONAL_PARAMETER_NODE: pm_node_type = 113;
#[doc = " OrNode"]
pub const pm_node_type_PM_OR_NODE: pm_node_type = 114;
#[doc = " ParametersNode"]
pub const pm_node_type_PM_PARAMETERS_NODE: pm_node_type = 115;
#[doc = " ParenthesesNode"]
pub const pm_node_type_PM_PARENTHESES_NODE: pm_node_type = 116;
#[doc = " PinnedExpressionNode"]
pub const pm_node_type_PM_PINNED_EXPRESSION_NODE: pm_node_type = 117;
#[doc = " PinnedVariableNode"]
pub const pm_node_type_PM_PINNED_VARIABLE_NODE: pm_node_type = 118;
#[doc = " PostExecutionNode"]
pub const pm_node_type_PM_POST_EXECUTION_NODE: pm_node_type = 119;
#[doc = " PreExecutionNode"]
pub const pm_node_type_PM_PRE_EXECUTION_NODE: pm_node_type = 120;
#[doc = " ProgramNode"]
pub const pm_node_type_PM_PROGRAM_NODE: pm_node_type = 121;
#[doc = " RangeNode"]
pub const pm_node_type_PM_RANGE_NODE: pm_node_type = 122;
#[doc = " RationalNode"]
pub const pm_node_type_PM_RATIONAL_NODE: pm_node_type = 123;
#[doc = " RedoNode"]
pub const pm_node_type_PM_REDO_NODE: pm_node_type = 124;
#[doc = " RegularExpressionNode"]
pub const pm_node_type_PM_REGULAR_EXPRESSION_NODE: pm_node_type = 125;
#[doc = " RequiredKeywordParameterNode"]
pub const pm_node_type_PM_REQUIRED_KEYWORD_PARAMETER_NODE: pm_node_type = 126;
#[doc = " RequiredParameterNode"]
pub const pm_node_type_PM_REQUIRED_PARAMETER_NODE: pm_node_type = 127;
#[doc = " RescueModifierNode"]
pub const pm_node_type_PM_RESCUE_MODIFIER_NODE: pm_node_type = 128;
#[doc = " RescueNode"]
pub const pm_node_type_PM_RESCUE_NODE: pm_node_type = 129;
#[doc = " RestParameterNode"]
pub const pm_node_type_PM_REST_PARAMETER_NODE: pm_node_type = 130;
#[doc = " RetryNode"]
pub const pm_node_type_PM_RETRY_NODE: pm_node_type = 131;
#[doc = " ReturnNode"]
pub const pm_node_type_PM_RETURN_NODE: pm_node_type = 132;
#[doc = " SelfNode"]
pub const pm_node_type_PM_SELF_NODE: pm_node_type = 133;
#[doc = " ShareableConstantNode"]
pub const pm_node_type_PM_SHAREABLE_CONSTANT_NODE: pm_node_type = 134;
#[doc = " SingletonClassNode"]
pub const pm_node_type_PM_SINGLETON_CLASS_NODE: pm_node_type = 135;
#[doc = " SourceEncodingNode"]
pub const pm_node_type_PM_SOURCE_ENCODING_NODE: pm_node_type = 136;
#[doc = " SourceFileNode"]
pub const pm_node_type_PM_SOURCE_FILE_NODE: pm_node_type = 137;
#[doc = " SourceLineNode"]
pub const pm_node_type_PM_SOURCE_LINE_NODE: pm_node_type = 138;
#[doc = " SplatNode"]
pub const pm_node_type_PM_SPLAT_NODE: pm_node_type = 139;
#[doc = " StatementsNode"]
pub const pm_node_type_PM_STATEMENTS_NODE: pm_node_type = 140;
#[doc = " StringNode"]
pub const pm_node_type_PM_STRING_NODE: pm_node_type = 141;
#[doc = " SuperNode"]
pub const pm_node_type_PM_SUPER_NODE: pm_node_type = 142;
#[doc = " SymbolNode"]
pub const pm_node_type_PM_SYMBOL_NODE: pm_node_type = 143;
#[doc = " TrueNode"]
pub const pm_node_type_PM_TRUE_NODE: pm_node_type = 144;
#[doc = " UndefNode"]
pub const pm_node_type_PM_UNDEF_NODE: pm_node_type = 145;
#[doc = " UnlessNode"]
pub const pm_node_type_PM_UNLESS_NODE: pm_node_type = 146;
#[doc = " UntilNode"]
pub const pm_node_type_PM_UNTIL_NODE: pm_node_type = 147;
#[doc = " WhenNode"]
pub const pm_node_type_PM_WHEN_NODE: pm_node_type = 148;
#[doc = " WhileNode"]
pub const pm_node_type_PM_WHILE_NODE: pm_node_type = 149;
#[doc = " XStringNode"]
pub const pm_node_type_PM_X_STRING_NODE: pm_node_type = 150;
#[doc = " YieldNode"]
pub const pm_node_type_PM_YIELD_NODE: pm_node_type = 151;
#[doc = " A special kind of node used for compilation."]
pub const pm_node_type_PM_SCOPE_NODE: pm_node_type = 152;
#[doc = " This enum represents every type of node in the Ruby syntax tree."]
pub type pm_node_type = ::std::os::raw::c_uint;
#[doc = " This is the type of node embedded in the node struct. We explicitly control\n the size of it here to avoid having the variable-width enum."]
pub type pm_node_type_t = u16;
#[doc = " These are the flags embedded in the node struct. We explicitly control the\n size of it here to avoid having the variable-width enum."]
pub type pm_node_flags_t = u16;
#[doc = " We store the flags enum in every node in the tree. Some flags are common to\n all nodes (the ones listed below). Others are specific to certain node types."]
pub const PM_NODE_FLAG_NEWLINE: pm_node_flags_t = 1;
pub const PM_NODE_FLAG_STATIC_LITERAL: pm_node_flags_t = 2;
#[doc = " This is the base structure that represents a node in the syntax tree. It is\n embedded into every node type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_node {
    #[doc = " This represents the type of the node. It somewhat maps to the nodes that\n existed in the original grammar and ripper, but it's not a 1:1 mapping."]
    pub type_: pm_node_type_t,
    #[doc = " This represents any flags on the node. Some are common to all nodes, and\n some are specific to the type of node."]
    pub flags: pm_node_flags_t,
    #[doc = " The unique identifier for this node, which is deterministic based on the\n source. It is used to identify unique nodes across parses."]
    pub node_id: u32,
    #[doc = " This is the location of the node in the source. It's a range of bytes\n containing a start and an end."]
    pub location: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_node"][::std::mem::size_of::<pm_node>() - 24usize];
    ["Alignment of pm_node"][::std::mem::align_of::<pm_node>() - 8usize];
    ["Offset of field: pm_node::type_"][::std::mem::offset_of!(pm_node, type_) - 0usize];
    ["Offset of field: pm_node::flags"][::std::mem::offset_of!(pm_node, flags) - 2usize];
    ["Offset of field: pm_node::node_id"][::std::mem::offset_of!(pm_node, node_id) - 4usize];
    ["Offset of field: pm_node::location"][::std::mem::offset_of!(pm_node, location) - 8usize];
};
#[doc = " This is the base structure that represents a node in the syntax tree. It is\n embedded into every node type."]
pub type pm_node_t = pm_node;
#[doc = " AliasGlobalVariableNode\n\n Represents the use of the `alias` keyword to alias a global variable.\n\n     alias $foo $bar\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_ALIAS_GLOBAL_VARIABLE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_alias_global_variable_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AliasGlobalVariableNode#new_name\n\n Represents the new name of the global variable that can be used after aliasing.\n\n     alias $foo $bar\n           ^^^^"]
    pub new_name: *mut pm_node,
    #[doc = " AliasGlobalVariableNode#old_name\n\n Represents the old name of the global variable that can be used before aliasing.\n\n     alias $foo $bar\n                ^^^^"]
    pub old_name: *mut pm_node,
    #[doc = " AliasGlobalVariableNode#keyword_loc\n\n The location of the `alias` keyword.\n\n     alias $foo $bar\n     ^^^^^"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_alias_global_variable_node"]
        [::std::mem::size_of::<pm_alias_global_variable_node>() - 56usize];
    ["Alignment of pm_alias_global_variable_node"]
        [::std::mem::align_of::<pm_alias_global_variable_node>() - 8usize];
    ["Offset of field: pm_alias_global_variable_node::base"]
        [::std::mem::offset_of!(pm_alias_global_variable_node, base) - 0usize];
    ["Offset of field: pm_alias_global_variable_node::new_name"]
        [::std::mem::offset_of!(pm_alias_global_variable_node, new_name) - 24usize];
    ["Offset of field: pm_alias_global_variable_node::old_name"]
        [::std::mem::offset_of!(pm_alias_global_variable_node, old_name) - 32usize];
    ["Offset of field: pm_alias_global_variable_node::keyword_loc"]
        [::std::mem::offset_of!(pm_alias_global_variable_node, keyword_loc) - 40usize];
};
#[doc = " AliasGlobalVariableNode\n\n Represents the use of the `alias` keyword to alias a global variable.\n\n     alias $foo $bar\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_ALIAS_GLOBAL_VARIABLE_NODE\n\n @extends pm_node_t"]
pub type pm_alias_global_variable_node_t = pm_alias_global_variable_node;
#[doc = " AliasMethodNode\n\n Represents the use of the `alias` keyword to alias a method.\n\n     alias foo bar\n     ^^^^^^^^^^^^^\n\n Type: ::PM_ALIAS_METHOD_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_alias_method_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AliasMethodNode#new_name\n\n Represents the new name of the method that will be aliased.\n\n     alias foo bar\n           ^^^\n\n     alias :foo :bar\n           ^^^^\n\n     alias :\"#{foo}\" :\"#{bar}\"\n           ^^^^^^^^^"]
    pub new_name: *mut pm_node,
    #[doc = " AliasMethodNode#old_name\n\n Represents the old name of the method that will be aliased.\n\n     alias foo bar\n               ^^^\n\n     alias :foo :bar\n                ^^^^\n\n     alias :\"#{foo}\" :\"#{bar}\"\n                     ^^^^^^^^^"]
    pub old_name: *mut pm_node,
    #[doc = " AliasMethodNode#keyword_loc\n\n Represents the location of the `alias` keyword.\n\n     alias foo bar\n     ^^^^^"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_alias_method_node"][::std::mem::size_of::<pm_alias_method_node>() - 56usize];
    ["Alignment of pm_alias_method_node"][::std::mem::align_of::<pm_alias_method_node>() - 8usize];
    ["Offset of field: pm_alias_method_node::base"]
        [::std::mem::offset_of!(pm_alias_method_node, base) - 0usize];
    ["Offset of field: pm_alias_method_node::new_name"]
        [::std::mem::offset_of!(pm_alias_method_node, new_name) - 24usize];
    ["Offset of field: pm_alias_method_node::old_name"]
        [::std::mem::offset_of!(pm_alias_method_node, old_name) - 32usize];
    ["Offset of field: pm_alias_method_node::keyword_loc"]
        [::std::mem::offset_of!(pm_alias_method_node, keyword_loc) - 40usize];
};
#[doc = " AliasMethodNode\n\n Represents the use of the `alias` keyword to alias a method.\n\n     alias foo bar\n     ^^^^^^^^^^^^^\n\n Type: ::PM_ALIAS_METHOD_NODE\n\n @extends pm_node_t"]
pub type pm_alias_method_node_t = pm_alias_method_node;
#[doc = " AlternationPatternNode\n\n Represents an alternation pattern in pattern matching.\n\n     foo => bar | baz\n            ^^^^^^^^^\n\n Type: ::PM_ALTERNATION_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_alternation_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AlternationPatternNode#left\n\n Represents the left side of the expression.\n\n     foo => bar | baz\n            ^^^"]
    pub left: *mut pm_node,
    #[doc = " AlternationPatternNode#right\n\n Represents the right side of the expression.\n\n     foo => bar | baz\n                  ^^^"]
    pub right: *mut pm_node,
    #[doc = " AlternationPatternNode#operator_loc\n\n Represents the alternation operator location.\n\n     foo => bar | baz\n                ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_alternation_pattern_node"]
        [::std::mem::size_of::<pm_alternation_pattern_node>() - 56usize];
    ["Alignment of pm_alternation_pattern_node"]
        [::std::mem::align_of::<pm_alternation_pattern_node>() - 8usize];
    ["Offset of field: pm_alternation_pattern_node::base"]
        [::std::mem::offset_of!(pm_alternation_pattern_node, base) - 0usize];
    ["Offset of field: pm_alternation_pattern_node::left"]
        [::std::mem::offset_of!(pm_alternation_pattern_node, left) - 24usize];
    ["Offset of field: pm_alternation_pattern_node::right"]
        [::std::mem::offset_of!(pm_alternation_pattern_node, right) - 32usize];
    ["Offset of field: pm_alternation_pattern_node::operator_loc"]
        [::std::mem::offset_of!(pm_alternation_pattern_node, operator_loc) - 40usize];
};
#[doc = " AlternationPatternNode\n\n Represents an alternation pattern in pattern matching.\n\n     foo => bar | baz\n            ^^^^^^^^^\n\n Type: ::PM_ALTERNATION_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_alternation_pattern_node_t = pm_alternation_pattern_node;
#[doc = " AndNode\n\n Represents the use of the `&&` operator or the `and` keyword.\n\n     left and right\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_AND_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_and_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AndNode#left\n\n Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     left and right\n     ^^^^\n\n     1 && 2\n     ^"]
    pub left: *mut pm_node,
    #[doc = " AndNode#right\n\n Represents the right side of the expression.\n\n     left && right\n             ^^^^^\n\n     1 and 2\n           ^"]
    pub right: *mut pm_node,
    #[doc = " AndNode#operator_loc\n\n The location of the `and` keyword or the `&&` operator.\n\n     left and right\n          ^^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_and_node"][::std::mem::size_of::<pm_and_node>() - 56usize];
    ["Alignment of pm_and_node"][::std::mem::align_of::<pm_and_node>() - 8usize];
    ["Offset of field: pm_and_node::base"][::std::mem::offset_of!(pm_and_node, base) - 0usize];
    ["Offset of field: pm_and_node::left"][::std::mem::offset_of!(pm_and_node, left) - 24usize];
    ["Offset of field: pm_and_node::right"][::std::mem::offset_of!(pm_and_node, right) - 32usize];
    ["Offset of field: pm_and_node::operator_loc"]
        [::std::mem::offset_of!(pm_and_node, operator_loc) - 40usize];
};
#[doc = " AndNode\n\n Represents the use of the `&&` operator or the `and` keyword.\n\n     left and right\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_AND_NODE\n\n @extends pm_node_t"]
pub type pm_and_node_t = pm_and_node;
#[doc = " ArgumentsNode\n\n Represents a set of arguments to a method or a keyword.\n\n     return foo, bar, baz\n            ^^^^^^^^^^^^^\n\n Type: ::PM_ARGUMENTS_NODE\n\n Flags (#pm_arguments_node_flags):\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_FORWARDING\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORDS\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORD_SPLAT\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_SPLAT\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_MULTIPLE_SPLATS\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_arguments_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ArgumentsNode#arguments\n\n The list of arguments, if present. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo(bar, baz)\n         ^^^^^^^^"]
    pub arguments: pm_node_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_arguments_node"][::std::mem::size_of::<pm_arguments_node>() - 48usize];
    ["Alignment of pm_arguments_node"][::std::mem::align_of::<pm_arguments_node>() - 8usize];
    ["Offset of field: pm_arguments_node::base"]
        [::std::mem::offset_of!(pm_arguments_node, base) - 0usize];
    ["Offset of field: pm_arguments_node::arguments"]
        [::std::mem::offset_of!(pm_arguments_node, arguments) - 24usize];
};
#[doc = " ArgumentsNode\n\n Represents a set of arguments to a method or a keyword.\n\n     return foo, bar, baz\n            ^^^^^^^^^^^^^\n\n Type: ::PM_ARGUMENTS_NODE\n\n Flags (#pm_arguments_node_flags):\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_FORWARDING\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORDS\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORD_SPLAT\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_SPLAT\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_MULTIPLE_SPLATS\n\n @extends pm_node_t"]
pub type pm_arguments_node_t = pm_arguments_node;
#[doc = " ArrayNode\n\n Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.\n\n     [1, 2, 3]\n     ^^^^^^^^^\n\n Type: ::PM_ARRAY_NODE\n\n Flags (#pm_array_node_flags):\n * ::PM_ARRAY_NODE_FLAGS_CONTAINS_SPLAT\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_array_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ArrayNode#elements\n\n Represent the list of zero or more [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression) within the array."]
    pub elements: pm_node_list,
    #[doc = " ArrayNode#opening_loc\n\n Represents the optional source location for the opening token.\n\n     [1,2,3]                 # \"[\"\n     %w[foo bar baz]         # \"%w[\"\n     %I(apple orange banana) # \"%I(\"\n     foo = 1, 2, 3           # nil"]
    pub opening_loc: pm_location_t,
    #[doc = " ArrayNode#closing_loc\n\n Represents the optional source location for the closing token.\n\n     [1,2,3]                 # \"]\"\n     %w[foo bar baz]         # \"]\"\n     %I(apple orange banana) # \")\"\n     foo = 1, 2, 3           # nil"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_array_node"][::std::mem::size_of::<pm_array_node>() - 80usize];
    ["Alignment of pm_array_node"][::std::mem::align_of::<pm_array_node>() - 8usize];
    ["Offset of field: pm_array_node::base"][::std::mem::offset_of!(pm_array_node, base) - 0usize];
    ["Offset of field: pm_array_node::elements"]
        [::std::mem::offset_of!(pm_array_node, elements) - 24usize];
    ["Offset of field: pm_array_node::opening_loc"]
        [::std::mem::offset_of!(pm_array_node, opening_loc) - 48usize];
    ["Offset of field: pm_array_node::closing_loc"]
        [::std::mem::offset_of!(pm_array_node, closing_loc) - 64usize];
};
#[doc = " ArrayNode\n\n Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.\n\n     [1, 2, 3]\n     ^^^^^^^^^\n\n Type: ::PM_ARRAY_NODE\n\n Flags (#pm_array_node_flags):\n * ::PM_ARRAY_NODE_FLAGS_CONTAINS_SPLAT\n\n @extends pm_node_t"]
pub type pm_array_node_t = pm_array_node;
#[doc = " ArrayPatternNode\n\n Represents an array pattern in pattern matching.\n\n     foo in 1, 2\n     ^^^^^^^^^^^\n\n     foo in [1, 2]\n     ^^^^^^^^^^^^^\n\n     foo in *bar\n     ^^^^^^^^^^^\n\n     foo in Bar[]\n     ^^^^^^^^^^^^\n\n     foo in Bar[1, 2, 3]\n     ^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_ARRAY_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_array_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ArrayPatternNode#constant"]
    pub constant: *mut pm_node,
    #[doc = " ArrayPatternNode#requireds\n\n Represents the required elements of the array pattern.\n\n     foo in [1, 2]\n             ^  ^"]
    pub requireds: pm_node_list,
    #[doc = " ArrayPatternNode#rest\n\n Represents the rest element of the array pattern.\n\n     foo in *bar\n            ^^^^"]
    pub rest: *mut pm_node,
    #[doc = " ArrayPatternNode#posts\n\n Represents the elements after the rest element of the array pattern.\n\n     foo in *bar, baz\n                  ^^^"]
    pub posts: pm_node_list,
    #[doc = " ArrayPatternNode#opening_loc\n\n Represents the opening location of the array pattern.\n\n     foo in [1, 2]\n            ^"]
    pub opening_loc: pm_location_t,
    #[doc = " ArrayPatternNode#closing_loc\n\n Represents the closing location of the array pattern.\n\n     foo in [1, 2]\n                 ^"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_array_pattern_node"][::std::mem::size_of::<pm_array_pattern_node>() - 120usize];
    ["Alignment of pm_array_pattern_node"]
        [::std::mem::align_of::<pm_array_pattern_node>() - 8usize];
    ["Offset of field: pm_array_pattern_node::base"]
        [::std::mem::offset_of!(pm_array_pattern_node, base) - 0usize];
    ["Offset of field: pm_array_pattern_node::constant"]
        [::std::mem::offset_of!(pm_array_pattern_node, constant) - 24usize];
    ["Offset of field: pm_array_pattern_node::requireds"]
        [::std::mem::offset_of!(pm_array_pattern_node, requireds) - 32usize];
    ["Offset of field: pm_array_pattern_node::rest"]
        [::std::mem::offset_of!(pm_array_pattern_node, rest) - 56usize];
    ["Offset of field: pm_array_pattern_node::posts"]
        [::std::mem::offset_of!(pm_array_pattern_node, posts) - 64usize];
    ["Offset of field: pm_array_pattern_node::opening_loc"]
        [::std::mem::offset_of!(pm_array_pattern_node, opening_loc) - 88usize];
    ["Offset of field: pm_array_pattern_node::closing_loc"]
        [::std::mem::offset_of!(pm_array_pattern_node, closing_loc) - 104usize];
};
#[doc = " ArrayPatternNode\n\n Represents an array pattern in pattern matching.\n\n     foo in 1, 2\n     ^^^^^^^^^^^\n\n     foo in [1, 2]\n     ^^^^^^^^^^^^^\n\n     foo in *bar\n     ^^^^^^^^^^^\n\n     foo in Bar[]\n     ^^^^^^^^^^^^\n\n     foo in Bar[1, 2, 3]\n     ^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_ARRAY_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_array_pattern_node_t = pm_array_pattern_node;
#[doc = " AssocNode\n\n Represents a hash key/value pair.\n\n     { a => b }\n       ^^^^^^\n\n Type: ::PM_ASSOC_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_assoc_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AssocNode#key\n\n The key of the association. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     { a: b }\n       ^\n\n     { foo => bar }\n       ^^^\n\n     { def a; end => 1 }\n       ^^^^^^^^^^"]
    pub key: *mut pm_node,
    #[doc = " AssocNode#value\n\n The value of the association, if present. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     { foo => bar }\n              ^^^\n\n     { x: 1 }\n          ^"]
    pub value: *mut pm_node,
    #[doc = " AssocNode#operator_loc\n\n The location of the `=>` operator, if present.\n\n     { foo => bar }\n           ^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_assoc_node"][::std::mem::size_of::<pm_assoc_node>() - 56usize];
    ["Alignment of pm_assoc_node"][::std::mem::align_of::<pm_assoc_node>() - 8usize];
    ["Offset of field: pm_assoc_node::base"][::std::mem::offset_of!(pm_assoc_node, base) - 0usize];
    ["Offset of field: pm_assoc_node::key"][::std::mem::offset_of!(pm_assoc_node, key) - 24usize];
    ["Offset of field: pm_assoc_node::value"]
        [::std::mem::offset_of!(pm_assoc_node, value) - 32usize];
    ["Offset of field: pm_assoc_node::operator_loc"]
        [::std::mem::offset_of!(pm_assoc_node, operator_loc) - 40usize];
};
#[doc = " AssocNode\n\n Represents a hash key/value pair.\n\n     { a => b }\n       ^^^^^^\n\n Type: ::PM_ASSOC_NODE\n\n @extends pm_node_t"]
pub type pm_assoc_node_t = pm_assoc_node;
#[doc = " AssocSplatNode\n\n Represents a splat in a hash literal.\n\n     { **foo }\n       ^^^^^\n\n Type: ::PM_ASSOC_SPLAT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_assoc_splat_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AssocSplatNode#value\n\n The value to be splatted, if present. Will be missing when keyword rest argument forwarding is used.\n\n     { **foo }\n         ^^^"]
    pub value: *mut pm_node,
    #[doc = " AssocSplatNode#operator_loc\n\n The location of the `**` operator.\n\n     { **x }\n       ^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_assoc_splat_node"][::std::mem::size_of::<pm_assoc_splat_node>() - 48usize];
    ["Alignment of pm_assoc_splat_node"][::std::mem::align_of::<pm_assoc_splat_node>() - 8usize];
    ["Offset of field: pm_assoc_splat_node::base"]
        [::std::mem::offset_of!(pm_assoc_splat_node, base) - 0usize];
    ["Offset of field: pm_assoc_splat_node::value"]
        [::std::mem::offset_of!(pm_assoc_splat_node, value) - 24usize];
    ["Offset of field: pm_assoc_splat_node::operator_loc"]
        [::std::mem::offset_of!(pm_assoc_splat_node, operator_loc) - 32usize];
};
#[doc = " AssocSplatNode\n\n Represents a splat in a hash literal.\n\n     { **foo }\n       ^^^^^\n\n Type: ::PM_ASSOC_SPLAT_NODE\n\n @extends pm_node_t"]
pub type pm_assoc_splat_node_t = pm_assoc_splat_node;
#[doc = " BackReferenceReadNode\n\n Represents reading a reference to a field in the previous match.\n\n     $'\n     ^^\n\n Type: ::PM_BACK_REFERENCE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_back_reference_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BackReferenceReadNode#name\n\n The name of the back-reference variable, including the leading `$`.\n\n     $& # name `:$&`\n\n     $+ # name `:$+`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_back_reference_read_node"]
        [::std::mem::size_of::<pm_back_reference_read_node>() - 32usize];
    ["Alignment of pm_back_reference_read_node"]
        [::std::mem::align_of::<pm_back_reference_read_node>() - 8usize];
    ["Offset of field: pm_back_reference_read_node::base"]
        [::std::mem::offset_of!(pm_back_reference_read_node, base) - 0usize];
    ["Offset of field: pm_back_reference_read_node::name"]
        [::std::mem::offset_of!(pm_back_reference_read_node, name) - 24usize];
};
#[doc = " BackReferenceReadNode\n\n Represents reading a reference to a field in the previous match.\n\n     $'\n     ^^\n\n Type: ::PM_BACK_REFERENCE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_back_reference_read_node_t = pm_back_reference_read_node;
#[doc = " BeginNode\n\n Represents a begin statement.\n\n     begin\n       foo\n     end\n     ^^^^^\n\n Type: ::PM_BEGIN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_begin_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BeginNode#begin_keyword_loc\n\n Represents the location of the `begin` keyword.\n\n     begin x end\n     ^^^^^"]
    pub begin_keyword_loc: pm_location_t,
    #[doc = " BeginNode#statements\n\n Represents the statements within the begin block.\n\n     begin x end\n           ^"]
    pub statements: *mut pm_statements_node,
    #[doc = " BeginNode#rescue_clause\n\n Represents the rescue clause within the begin block.\n\n     begin x; rescue y; end\n              ^^^^^^^^"]
    pub rescue_clause: *mut pm_rescue_node,
    #[doc = " BeginNode#else_clause\n\n Represents the else clause within the begin block.\n\n     begin x; rescue y; else z; end\n                        ^^^^^^"]
    pub else_clause: *mut pm_else_node,
    #[doc = " BeginNode#ensure_clause\n\n Represents the ensure clause within the begin block.\n\n     begin x; ensure y; end\n              ^^^^^^^^"]
    pub ensure_clause: *mut pm_ensure_node,
    #[doc = " BeginNode#end_keyword_loc\n\n Represents the location of the `end` keyword.\n\n     begin x end\n             ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_begin_node"][::std::mem::size_of::<pm_begin_node>() - 88usize];
    ["Alignment of pm_begin_node"][::std::mem::align_of::<pm_begin_node>() - 8usize];
    ["Offset of field: pm_begin_node::base"][::std::mem::offset_of!(pm_begin_node, base) - 0usize];
    ["Offset of field: pm_begin_node::begin_keyword_loc"]
        [::std::mem::offset_of!(pm_begin_node, begin_keyword_loc) - 24usize];
    ["Offset of field: pm_begin_node::statements"]
        [::std::mem::offset_of!(pm_begin_node, statements) - 40usize];
    ["Offset of field: pm_begin_node::rescue_clause"]
        [::std::mem::offset_of!(pm_begin_node, rescue_clause) - 48usize];
    ["Offset of field: pm_begin_node::else_clause"]
        [::std::mem::offset_of!(pm_begin_node, else_clause) - 56usize];
    ["Offset of field: pm_begin_node::ensure_clause"]
        [::std::mem::offset_of!(pm_begin_node, ensure_clause) - 64usize];
    ["Offset of field: pm_begin_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_begin_node, end_keyword_loc) - 72usize];
};
#[doc = " BeginNode\n\n Represents a begin statement.\n\n     begin\n       foo\n     end\n     ^^^^^\n\n Type: ::PM_BEGIN_NODE\n\n @extends pm_node_t"]
pub type pm_begin_node_t = pm_begin_node;
#[doc = " BlockArgumentNode\n\n Represents a block argument using `&`.\n\n     bar(&args)\n     ^^^^^^^^^^\n\n Type: ::PM_BLOCK_ARGUMENT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_argument_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockArgumentNode#expression\n\n The expression that is being passed as a block argument. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo(&args)\n         ^^^^^"]
    pub expression: *mut pm_node,
    #[doc = " BlockArgumentNode#operator_loc\n\n Represents the location of the `&` operator.\n\n     foo(&args)\n         ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_argument_node"][::std::mem::size_of::<pm_block_argument_node>() - 48usize];
    ["Alignment of pm_block_argument_node"]
        [::std::mem::align_of::<pm_block_argument_node>() - 8usize];
    ["Offset of field: pm_block_argument_node::base"]
        [::std::mem::offset_of!(pm_block_argument_node, base) - 0usize];
    ["Offset of field: pm_block_argument_node::expression"]
        [::std::mem::offset_of!(pm_block_argument_node, expression) - 24usize];
    ["Offset of field: pm_block_argument_node::operator_loc"]
        [::std::mem::offset_of!(pm_block_argument_node, operator_loc) - 32usize];
};
#[doc = " BlockArgumentNode\n\n Represents a block argument using `&`.\n\n     bar(&args)\n     ^^^^^^^^^^\n\n Type: ::PM_BLOCK_ARGUMENT_NODE\n\n @extends pm_node_t"]
pub type pm_block_argument_node_t = pm_block_argument_node;
#[doc = " BlockLocalVariableNode\n\n Represents a block local variable.\n\n     a { |; b| }\n            ^\n\n Type: ::PM_BLOCK_LOCAL_VARIABLE_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_local_variable_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockLocalVariableNode#name\n\n The name of the block local variable.\n\n     a { |; b| } # name `:b`\n            ^"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_local_variable_node"]
        [::std::mem::size_of::<pm_block_local_variable_node>() - 32usize];
    ["Alignment of pm_block_local_variable_node"]
        [::std::mem::align_of::<pm_block_local_variable_node>() - 8usize];
    ["Offset of field: pm_block_local_variable_node::base"]
        [::std::mem::offset_of!(pm_block_local_variable_node, base) - 0usize];
    ["Offset of field: pm_block_local_variable_node::name"]
        [::std::mem::offset_of!(pm_block_local_variable_node, name) - 24usize];
};
#[doc = " BlockLocalVariableNode\n\n Represents a block local variable.\n\n     a { |; b| }\n            ^\n\n Type: ::PM_BLOCK_LOCAL_VARIABLE_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_block_local_variable_node_t = pm_block_local_variable_node;
#[doc = " BlockNode\n\n Represents a block of ruby code.\n\n     [1, 2, 3].each { |i| puts x }\n                    ^^^^^^^^^^^^^^\n\n Type: ::PM_BLOCK_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockNode#locals\n\n The local variables declared in the block.\n\n     [1, 2, 3].each { |i| puts x } # locals: [:i]\n                       ^"]
    pub locals: pm_constant_id_list_t,
    #[doc = " BlockNode#parameters\n\n The parameters of the block.\n\n     [1, 2, 3].each { |i| puts x }\n                      ^^^\n     [1, 2, 3].each { puts _1 }\n                    ^^^^^^^^^^^\n     [1, 2, 3].each { puts it }\n                    ^^^^^^^^^^^"]
    pub parameters: *mut pm_node,
    #[doc = " BlockNode#body\n\n The body of the block.\n\n     [1, 2, 3].each { |i| puts x }\n                          ^^^^^^"]
    pub body: *mut pm_node,
    #[doc = " BlockNode#opening_loc\n\n Represents the location of the opening `|`.\n\n     [1, 2, 3].each { |i| puts x }\n                      ^"]
    pub opening_loc: pm_location_t,
    #[doc = " BlockNode#closing_loc\n\n Represents the location of the closing `|`.\n\n     [1, 2, 3].each { |i| puts x }\n                        ^"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_node"][::std::mem::size_of::<pm_block_node>() - 96usize];
    ["Alignment of pm_block_node"][::std::mem::align_of::<pm_block_node>() - 8usize];
    ["Offset of field: pm_block_node::base"][::std::mem::offset_of!(pm_block_node, base) - 0usize];
    ["Offset of field: pm_block_node::locals"]
        [::std::mem::offset_of!(pm_block_node, locals) - 24usize];
    ["Offset of field: pm_block_node::parameters"]
        [::std::mem::offset_of!(pm_block_node, parameters) - 48usize];
    ["Offset of field: pm_block_node::body"][::std::mem::offset_of!(pm_block_node, body) - 56usize];
    ["Offset of field: pm_block_node::opening_loc"]
        [::std::mem::offset_of!(pm_block_node, opening_loc) - 64usize];
    ["Offset of field: pm_block_node::closing_loc"]
        [::std::mem::offset_of!(pm_block_node, closing_loc) - 80usize];
};
#[doc = " BlockNode\n\n Represents a block of ruby code.\n\n     [1, 2, 3].each { |i| puts x }\n                    ^^^^^^^^^^^^^^\n\n Type: ::PM_BLOCK_NODE\n\n @extends pm_node_t"]
pub type pm_block_node_t = pm_block_node;
#[doc = " BlockParameterNode\n\n Represents a block parameter of a method, block, or lambda definition.\n\n     def a(&b)\n           ^^\n     end\n\n Type: ::PM_BLOCK_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockParameterNode#name\n\n The name of the block parameter.\n\n     def a(&b) # name `:b`\n            ^\n     end"]
    pub name: pm_constant_id_t,
    #[doc = " BlockParameterNode#name_loc\n\n Represents the location of the block parameter name.\n\n     def a(&b)\n            ^"]
    pub name_loc: pm_location_t,
    #[doc = " BlockParameterNode#operator_loc\n\n Represents the location of the `&` operator.\n\n     def a(&b)\n           ^\n     end"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_parameter_node"][::std::mem::size_of::<pm_block_parameter_node>() - 64usize];
    ["Alignment of pm_block_parameter_node"]
        [::std::mem::align_of::<pm_block_parameter_node>() - 8usize];
    ["Offset of field: pm_block_parameter_node::base"]
        [::std::mem::offset_of!(pm_block_parameter_node, base) - 0usize];
    ["Offset of field: pm_block_parameter_node::name"]
        [::std::mem::offset_of!(pm_block_parameter_node, name) - 24usize];
    ["Offset of field: pm_block_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_block_parameter_node, name_loc) - 32usize];
    ["Offset of field: pm_block_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_block_parameter_node, operator_loc) - 48usize];
};
#[doc = " BlockParameterNode\n\n Represents a block parameter of a method, block, or lambda definition.\n\n     def a(&b)\n           ^^\n     end\n\n Type: ::PM_BLOCK_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_block_parameter_node_t = pm_block_parameter_node;
#[doc = " BlockParametersNode\n\n Represents a block's parameters declaration.\n\n     -> (a, b = 1; local) { }\n        ^^^^^^^^^^^^^^^^^\n\n     foo do |a, b = 1; local|\n            ^^^^^^^^^^^^^^^^^\n     end\n\n Type: ::PM_BLOCK_PARAMETERS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_parameters_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockParametersNode#parameters\n\n Represents the parameters of the block.\n\n     -> (a, b = 1; local) { }\n         ^^^^^^^^\n\n     foo do |a, b = 1; local|\n             ^^^^^^^^\n     end"]
    pub parameters: *mut pm_parameters_node,
    #[doc = " BlockParametersNode#locals\n\n Represents the local variables of the block.\n\n     -> (a, b = 1; local) { }\n                   ^^^^^\n\n     foo do |a, b = 1; local|\n                       ^^^^^\n     end"]
    pub locals: pm_node_list,
    #[doc = " BlockParametersNode#opening_loc\n\n Represents the opening location of the block parameters.\n\n     -> (a, b = 1; local) { }\n        ^\n\n     foo do |a, b = 1; local|\n            ^\n     end"]
    pub opening_loc: pm_location_t,
    #[doc = " BlockParametersNode#closing_loc\n\n Represents the closing location of the block parameters.\n\n     -> (a, b = 1; local) { }\n                        ^\n\n     foo do |a, b = 1; local|\n                            ^\n     end"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_parameters_node"]
        [::std::mem::size_of::<pm_block_parameters_node>() - 88usize];
    ["Alignment of pm_block_parameters_node"]
        [::std::mem::align_of::<pm_block_parameters_node>() - 8usize];
    ["Offset of field: pm_block_parameters_node::base"]
        [::std::mem::offset_of!(pm_block_parameters_node, base) - 0usize];
    ["Offset of field: pm_block_parameters_node::parameters"]
        [::std::mem::offset_of!(pm_block_parameters_node, parameters) - 24usize];
    ["Offset of field: pm_block_parameters_node::locals"]
        [::std::mem::offset_of!(pm_block_parameters_node, locals) - 32usize];
    ["Offset of field: pm_block_parameters_node::opening_loc"]
        [::std::mem::offset_of!(pm_block_parameters_node, opening_loc) - 56usize];
    ["Offset of field: pm_block_parameters_node::closing_loc"]
        [::std::mem::offset_of!(pm_block_parameters_node, closing_loc) - 72usize];
};
#[doc = " BlockParametersNode\n\n Represents a block's parameters declaration.\n\n     -> (a, b = 1; local) { }\n        ^^^^^^^^^^^^^^^^^\n\n     foo do |a, b = 1; local|\n            ^^^^^^^^^^^^^^^^^\n     end\n\n Type: ::PM_BLOCK_PARAMETERS_NODE\n\n @extends pm_node_t"]
pub type pm_block_parameters_node_t = pm_block_parameters_node;
#[doc = " BreakNode\n\n Represents the use of the `break` keyword.\n\n     break foo\n     ^^^^^^^^^\n\n Type: ::PM_BREAK_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_break_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BreakNode#arguments\n\n The arguments to the break statement, if present. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     break foo\n           ^^^"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " BreakNode#keyword_loc\n\n The location of the `break` keyword.\n\n     break foo\n     ^^^^^"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_break_node"][::std::mem::size_of::<pm_break_node>() - 48usize];
    ["Alignment of pm_break_node"][::std::mem::align_of::<pm_break_node>() - 8usize];
    ["Offset of field: pm_break_node::base"][::std::mem::offset_of!(pm_break_node, base) - 0usize];
    ["Offset of field: pm_break_node::arguments"]
        [::std::mem::offset_of!(pm_break_node, arguments) - 24usize];
    ["Offset of field: pm_break_node::keyword_loc"]
        [::std::mem::offset_of!(pm_break_node, keyword_loc) - 32usize];
};
#[doc = " BreakNode\n\n Represents the use of the `break` keyword.\n\n     break foo\n     ^^^^^^^^^\n\n Type: ::PM_BREAK_NODE\n\n @extends pm_node_t"]
pub type pm_break_node_t = pm_break_node;
#[doc = " CallAndWriteNode\n\n Represents the use of the `&&=` operator on a call.\n\n     foo.bar &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_AND_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallAndWriteNode#receiver\n\n The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar &&= value\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallAndWriteNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar &&= value\n        ^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallAndWriteNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar &&= value\n         ^^^"]
    pub message_loc: pm_location_t,
    #[doc = " CallAndWriteNode#read_name\n\n Represents the name of the method being called.\n\n     foo.bar &&= value # read_name `:bar`\n         ^^^"]
    pub read_name: pm_constant_id_t,
    #[doc = " CallAndWriteNode#write_name\n\n Represents the name of the method being written to.\n\n     foo.bar &&= value # write_name `:bar=`\n         ^^^"]
    pub write_name: pm_constant_id_t,
    #[doc = " CallAndWriteNode#operator_loc\n\n Represents the location of the operator.\n\n     foo.bar &&= value\n             ^^^"]
    pub operator_loc: pm_location_t,
    #[doc = " CallAndWriteNode#value\n\n Represents the value being assigned.\n\n     foo.bar &&= value\n                 ^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_and_write_node"][::std::mem::size_of::<pm_call_and_write_node>() - 96usize];
    ["Alignment of pm_call_and_write_node"]
        [::std::mem::align_of::<pm_call_and_write_node>() - 8usize];
    ["Offset of field: pm_call_and_write_node::base"]
        [::std::mem::offset_of!(pm_call_and_write_node, base) - 0usize];
    ["Offset of field: pm_call_and_write_node::receiver"]
        [::std::mem::offset_of!(pm_call_and_write_node, receiver) - 24usize];
    ["Offset of field: pm_call_and_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_and_write_node, call_operator_loc) - 32usize];
    ["Offset of field: pm_call_and_write_node::message_loc"]
        [::std::mem::offset_of!(pm_call_and_write_node, message_loc) - 48usize];
    ["Offset of field: pm_call_and_write_node::read_name"]
        [::std::mem::offset_of!(pm_call_and_write_node, read_name) - 64usize];
    ["Offset of field: pm_call_and_write_node::write_name"]
        [::std::mem::offset_of!(pm_call_and_write_node, write_name) - 68usize];
    ["Offset of field: pm_call_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_call_and_write_node, operator_loc) - 72usize];
    ["Offset of field: pm_call_and_write_node::value"]
        [::std::mem::offset_of!(pm_call_and_write_node, value) - 88usize];
};
#[doc = " CallAndWriteNode\n\n Represents the use of the `&&=` operator on a call.\n\n     foo.bar &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_AND_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_and_write_node_t = pm_call_and_write_node;
#[doc = " CallNode\n\n Represents a method call, in all of the various forms that can take.\n\n     foo\n     ^^^\n\n     foo()\n     ^^^^^\n\n     +foo\n     ^^^^\n\n     foo + bar\n     ^^^^^^^^^\n\n     foo.bar\n     ^^^^^^^\n\n     foo&.bar\n     ^^^^^^^^\n\n Type: ::PM_CALL_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallNode#receiver\n\n The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar\n     ^^^\n\n     +foo\n      ^^^\n\n     foo + bar\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar\n        ^\n\n     foo&.bar\n        ^^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallNode#name\n\n Represents the name of the method being called.\n\n     foo.bar # name `:foo`\n     ^^^"]
    pub name: pm_constant_id_t,
    #[doc = " CallNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar\n         ^^^"]
    pub message_loc: pm_location_t,
    #[doc = " CallNode#opening_loc\n\n Represents the location of the left parenthesis.\n     foo(bar)\n        ^"]
    pub opening_loc: pm_location_t,
    #[doc = " CallNode#arguments\n\n Represents the arguments to the method call. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo(bar)\n         ^^^"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " CallNode#closing_loc\n\n Represents the location of the right parenthesis.\n\n     foo(bar)\n            ^"]
    pub closing_loc: pm_location_t,
    #[doc = " CallNode#block\n\n Represents the block that is being passed to the method.\n\n     foo { |a| a }\n         ^^^^^^^^^"]
    pub block: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_node"][::std::mem::size_of::<pm_call_node>() - 120usize];
    ["Alignment of pm_call_node"][::std::mem::align_of::<pm_call_node>() - 8usize];
    ["Offset of field: pm_call_node::base"][::std::mem::offset_of!(pm_call_node, base) - 0usize];
    ["Offset of field: pm_call_node::receiver"]
        [::std::mem::offset_of!(pm_call_node, receiver) - 24usize];
    ["Offset of field: pm_call_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_node, call_operator_loc) - 32usize];
    ["Offset of field: pm_call_node::name"][::std::mem::offset_of!(pm_call_node, name) - 48usize];
    ["Offset of field: pm_call_node::message_loc"]
        [::std::mem::offset_of!(pm_call_node, message_loc) - 56usize];
    ["Offset of field: pm_call_node::opening_loc"]
        [::std::mem::offset_of!(pm_call_node, opening_loc) - 72usize];
    ["Offset of field: pm_call_node::arguments"]
        [::std::mem::offset_of!(pm_call_node, arguments) - 88usize];
    ["Offset of field: pm_call_node::closing_loc"]
        [::std::mem::offset_of!(pm_call_node, closing_loc) - 96usize];
    ["Offset of field: pm_call_node::block"]
        [::std::mem::offset_of!(pm_call_node, block) - 112usize];
};
#[doc = " CallNode\n\n Represents a method call, in all of the various forms that can take.\n\n     foo\n     ^^^\n\n     foo()\n     ^^^^^\n\n     +foo\n     ^^^^\n\n     foo + bar\n     ^^^^^^^^^\n\n     foo.bar\n     ^^^^^^^\n\n     foo&.bar\n     ^^^^^^^^\n\n Type: ::PM_CALL_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_node_t = pm_call_node;
#[doc = " CallOperatorWriteNode\n\n Represents the use of an assignment operator on a call.\n\n     foo.bar += baz\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_OPERATOR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallOperatorWriteNode#receiver\n\n The object that the method is being called on. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar += value\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallOperatorWriteNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar += value\n        ^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallOperatorWriteNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar += value\n         ^^^"]
    pub message_loc: pm_location_t,
    #[doc = " CallOperatorWriteNode#read_name\n\n Represents the name of the method being called.\n\n     foo.bar += value # read_name `:bar`\n         ^^^"]
    pub read_name: pm_constant_id_t,
    #[doc = " CallOperatorWriteNode#write_name\n\n Represents the name of the method being written to.\n\n     foo.bar += value # write_name `:bar=`\n         ^^^"]
    pub write_name: pm_constant_id_t,
    #[doc = " CallOperatorWriteNode#binary_operator\n\n Represents the binary operator being used.\n\n     foo.bar += value # binary_operator `:+`\n             ^"]
    pub binary_operator: pm_constant_id_t,
    #[doc = " CallOperatorWriteNode#binary_operator_loc\n\n Represents the location of the binary operator.\n\n     foo.bar += value\n             ^^"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " CallOperatorWriteNode#value\n\n Represents the value being assigned.\n\n     foo.bar += value\n                ^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_operator_write_node"]
        [::std::mem::size_of::<pm_call_operator_write_node>() - 104usize];
    ["Alignment of pm_call_operator_write_node"]
        [::std::mem::align_of::<pm_call_operator_write_node>() - 8usize];
    ["Offset of field: pm_call_operator_write_node::base"]
        [::std::mem::offset_of!(pm_call_operator_write_node, base) - 0usize];
    ["Offset of field: pm_call_operator_write_node::receiver"]
        [::std::mem::offset_of!(pm_call_operator_write_node, receiver) - 24usize];
    ["Offset of field: pm_call_operator_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_operator_write_node, call_operator_loc) - 32usize];
    ["Offset of field: pm_call_operator_write_node::message_loc"]
        [::std::mem::offset_of!(pm_call_operator_write_node, message_loc) - 48usize];
    ["Offset of field: pm_call_operator_write_node::read_name"]
        [::std::mem::offset_of!(pm_call_operator_write_node, read_name) - 64usize];
    ["Offset of field: pm_call_operator_write_node::write_name"]
        [::std::mem::offset_of!(pm_call_operator_write_node, write_name) - 68usize];
    ["Offset of field: pm_call_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_call_operator_write_node, binary_operator) - 72usize];
    ["Offset of field: pm_call_operator_write_node::binary_operator_loc"]
        [::std::mem::offset_of!(pm_call_operator_write_node, binary_operator_loc) - 80usize];
    ["Offset of field: pm_call_operator_write_node::value"]
        [::std::mem::offset_of!(pm_call_operator_write_node, value) - 96usize];
};
#[doc = " CallOperatorWriteNode\n\n Represents the use of an assignment operator on a call.\n\n     foo.bar += baz\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_OPERATOR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_operator_write_node_t = pm_call_operator_write_node;
#[doc = " CallOrWriteNode\n\n Represents the use of the `||=` operator on a call.\n\n     foo.bar ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_OR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallOrWriteNode#receiver\n\n The object that the method is being called on. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar ||= value\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallOrWriteNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar ||= value\n        ^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallOrWriteNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar ||= value\n         ^^^"]
    pub message_loc: pm_location_t,
    #[doc = " CallOrWriteNode#read_name\n\n Represents the name of the method being called.\n\n     foo.bar ||= value # read_name `:bar`\n         ^^^"]
    pub read_name: pm_constant_id_t,
    #[doc = " CallOrWriteNode#write_name\n\n Represents the name of the method being written to.\n\n     foo.bar ||= value # write_name `:bar=`\n         ^^^"]
    pub write_name: pm_constant_id_t,
    #[doc = " CallOrWriteNode#operator_loc\n\n Represents the location of the operator.\n\n     foo.bar ||= value\n             ^^^"]
    pub operator_loc: pm_location_t,
    #[doc = " CallOrWriteNode#value\n\n Represents the value being assigned.\n\n     foo.bar ||= value\n                 ^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_or_write_node"][::std::mem::size_of::<pm_call_or_write_node>() - 96usize];
    ["Alignment of pm_call_or_write_node"]
        [::std::mem::align_of::<pm_call_or_write_node>() - 8usize];
    ["Offset of field: pm_call_or_write_node::base"]
        [::std::mem::offset_of!(pm_call_or_write_node, base) - 0usize];
    ["Offset of field: pm_call_or_write_node::receiver"]
        [::std::mem::offset_of!(pm_call_or_write_node, receiver) - 24usize];
    ["Offset of field: pm_call_or_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_or_write_node, call_operator_loc) - 32usize];
    ["Offset of field: pm_call_or_write_node::message_loc"]
        [::std::mem::offset_of!(pm_call_or_write_node, message_loc) - 48usize];
    ["Offset of field: pm_call_or_write_node::read_name"]
        [::std::mem::offset_of!(pm_call_or_write_node, read_name) - 64usize];
    ["Offset of field: pm_call_or_write_node::write_name"]
        [::std::mem::offset_of!(pm_call_or_write_node, write_name) - 68usize];
    ["Offset of field: pm_call_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_call_or_write_node, operator_loc) - 72usize];
    ["Offset of field: pm_call_or_write_node::value"]
        [::std::mem::offset_of!(pm_call_or_write_node, value) - 88usize];
};
#[doc = " CallOrWriteNode\n\n Represents the use of the `||=` operator on a call.\n\n     foo.bar ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_OR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_or_write_node_t = pm_call_or_write_node;
#[doc = " CallTargetNode\n\n Represents assigning to a method call.\n\n     foo.bar, = 1\n     ^^^^^^^\n\n     begin\n     rescue => foo.bar\n               ^^^^^^^\n     end\n\n     for foo.bar in baz do end\n         ^^^^^^^\n\n Type: ::PM_CALL_TARGET_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallTargetNode#receiver\n\n The object that the method is being called on. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar = 1\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallTargetNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar = 1\n        ^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallTargetNode#name\n\n Represents the name of the method being called.\n\n     foo.bar = 1 # name `:foo`\n     ^^^"]
    pub name: pm_constant_id_t,
    #[doc = " CallTargetNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar = 1\n         ^^^"]
    pub message_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_target_node"][::std::mem::size_of::<pm_call_target_node>() - 72usize];
    ["Alignment of pm_call_target_node"][::std::mem::align_of::<pm_call_target_node>() - 8usize];
    ["Offset of field: pm_call_target_node::base"]
        [::std::mem::offset_of!(pm_call_target_node, base) - 0usize];
    ["Offset of field: pm_call_target_node::receiver"]
        [::std::mem::offset_of!(pm_call_target_node, receiver) - 24usize];
    ["Offset of field: pm_call_target_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_target_node, call_operator_loc) - 32usize];
    ["Offset of field: pm_call_target_node::name"]
        [::std::mem::offset_of!(pm_call_target_node, name) - 48usize];
    ["Offset of field: pm_call_target_node::message_loc"]
        [::std::mem::offset_of!(pm_call_target_node, message_loc) - 56usize];
};
#[doc = " CallTargetNode\n\n Represents assigning to a method call.\n\n     foo.bar, = 1\n     ^^^^^^^\n\n     begin\n     rescue => foo.bar\n               ^^^^^^^\n     end\n\n     for foo.bar in baz do end\n         ^^^^^^^\n\n Type: ::PM_CALL_TARGET_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_target_node_t = pm_call_target_node;
#[doc = " CapturePatternNode\n\n Represents assigning to a local variable in pattern matching.\n\n     foo => [bar => baz]\n            ^^^^^^^^^^^^\n\n Type: ::PM_CAPTURE_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_capture_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CapturePatternNode#value\n\n Represents the value to capture.\n\n     foo => bar\n            ^^^"]
    pub value: *mut pm_node,
    #[doc = " CapturePatternNode#target\n\n Represents the target of the capture.\n\n     foo => bar\n     ^^^"]
    pub target: *mut pm_local_variable_target_node,
    #[doc = " CapturePatternNode#operator_loc\n\n Represents the location of the `=>` operator.\n\n     foo => bar\n         ^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_capture_pattern_node"][::std::mem::size_of::<pm_capture_pattern_node>() - 56usize];
    ["Alignment of pm_capture_pattern_node"]
        [::std::mem::align_of::<pm_capture_pattern_node>() - 8usize];
    ["Offset of field: pm_capture_pattern_node::base"]
        [::std::mem::offset_of!(pm_capture_pattern_node, base) - 0usize];
    ["Offset of field: pm_capture_pattern_node::value"]
        [::std::mem::offset_of!(pm_capture_pattern_node, value) - 24usize];
    ["Offset of field: pm_capture_pattern_node::target"]
        [::std::mem::offset_of!(pm_capture_pattern_node, target) - 32usize];
    ["Offset of field: pm_capture_pattern_node::operator_loc"]
        [::std::mem::offset_of!(pm_capture_pattern_node, operator_loc) - 40usize];
};
#[doc = " CapturePatternNode\n\n Represents assigning to a local variable in pattern matching.\n\n     foo => [bar => baz]\n            ^^^^^^^^^^^^\n\n Type: ::PM_CAPTURE_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_capture_pattern_node_t = pm_capture_pattern_node;
#[doc = " CaseMatchNode\n\n Represents the use of a case statement for pattern matching.\n\n     case true\n     in false\n     end\n     ^^^^^^^^^\n\n Type: ::PM_CASE_MATCH_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_case_match_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CaseMatchNode#predicate\n\n Represents the predicate of the case match. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     case true; in false; end\n     ^^^^"]
    pub predicate: *mut pm_node,
    #[doc = " CaseMatchNode#conditions\n\n Represents the conditions of the case match.\n\n     case true; in false; end\n                ^^^^^^^^"]
    pub conditions: pm_node_list,
    #[doc = " CaseMatchNode#else_clause\n\n Represents the else clause of the case match.\n\n     case true; in false; else; end\n                          ^^^^"]
    pub else_clause: *mut pm_else_node,
    #[doc = " CaseMatchNode#case_keyword_loc\n\n Represents the location of the `case` keyword.\n\n     case true; in false; end\n     ^^^^"]
    pub case_keyword_loc: pm_location_t,
    #[doc = " CaseMatchNode#end_keyword_loc\n\n Represents the location of the `end` keyword.\n\n     case true; in false; end\n                          ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_case_match_node"][::std::mem::size_of::<pm_case_match_node>() - 96usize];
    ["Alignment of pm_case_match_node"][::std::mem::align_of::<pm_case_match_node>() - 8usize];
    ["Offset of field: pm_case_match_node::base"]
        [::std::mem::offset_of!(pm_case_match_node, base) - 0usize];
    ["Offset of field: pm_case_match_node::predicate"]
        [::std::mem::offset_of!(pm_case_match_node, predicate) - 24usize];
    ["Offset of field: pm_case_match_node::conditions"]
        [::std::mem::offset_of!(pm_case_match_node, conditions) - 32usize];
    ["Offset of field: pm_case_match_node::else_clause"]
        [::std::mem::offset_of!(pm_case_match_node, else_clause) - 56usize];
    ["Offset of field: pm_case_match_node::case_keyword_loc"]
        [::std::mem::offset_of!(pm_case_match_node, case_keyword_loc) - 64usize];
    ["Offset of field: pm_case_match_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_case_match_node, end_keyword_loc) - 80usize];
};
#[doc = " CaseMatchNode\n\n Represents the use of a case statement for pattern matching.\n\n     case true\n     in false\n     end\n     ^^^^^^^^^\n\n Type: ::PM_CASE_MATCH_NODE\n\n @extends pm_node_t"]
pub type pm_case_match_node_t = pm_case_match_node;
#[doc = " CaseNode\n\n Represents the use of a case statement.\n\n     case true\n     when false\n     end\n     ^^^^^^^^^^\n\n Type: ::PM_CASE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_case_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CaseNode#predicate\n\n Represents the predicate of the case statement. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     case true; when false; end\n     ^^^^"]
    pub predicate: *mut pm_node,
    #[doc = " CaseNode#conditions\n\n Represents the conditions of the case statement.\n\n     case true; when false; end\n                ^^^^^^^^^^"]
    pub conditions: pm_node_list,
    #[doc = " CaseNode#else_clause\n\n Represents the else clause of the case statement.\n\n     case true; when false; else; end\n                            ^^^^"]
    pub else_clause: *mut pm_else_node,
    #[doc = " CaseNode#case_keyword_loc\n\n Represents the location of the `case` keyword.\n\n     case true; when false; end\n     ^^^^"]
    pub case_keyword_loc: pm_location_t,
    #[doc = " CaseNode#end_keyword_loc\n\n Represents the location of the `end` keyword.\n\n     case true; when false; end\n                            ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_case_node"][::std::mem::size_of::<pm_case_node>() - 96usize];
    ["Alignment of pm_case_node"][::std::mem::align_of::<pm_case_node>() - 8usize];
    ["Offset of field: pm_case_node::base"][::std::mem::offset_of!(pm_case_node, base) - 0usize];
    ["Offset of field: pm_case_node::predicate"]
        [::std::mem::offset_of!(pm_case_node, predicate) - 24usize];
    ["Offset of field: pm_case_node::conditions"]
        [::std::mem::offset_of!(pm_case_node, conditions) - 32usize];
    ["Offset of field: pm_case_node::else_clause"]
        [::std::mem::offset_of!(pm_case_node, else_clause) - 56usize];
    ["Offset of field: pm_case_node::case_keyword_loc"]
        [::std::mem::offset_of!(pm_case_node, case_keyword_loc) - 64usize];
    ["Offset of field: pm_case_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_case_node, end_keyword_loc) - 80usize];
};
#[doc = " CaseNode\n\n Represents the use of a case statement.\n\n     case true\n     when false\n     end\n     ^^^^^^^^^^\n\n Type: ::PM_CASE_NODE\n\n @extends pm_node_t"]
pub type pm_case_node_t = pm_case_node;
#[doc = " ClassNode\n\n Represents a class declaration involving the `class` keyword.\n\n     class Foo end\n     ^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " ClassNode#class_keyword_loc"]
    pub class_keyword_loc: pm_location_t,
    #[doc = " ClassNode#constant_path"]
    pub constant_path: *mut pm_node,
    #[doc = " ClassNode#inheritance_operator_loc"]
    pub inheritance_operator_loc: pm_location_t,
    #[doc = " ClassNode#superclass"]
    pub superclass: *mut pm_node,
    #[doc = " ClassNode#body"]
    pub body: *mut pm_node,
    #[doc = " ClassNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
    #[doc = " ClassNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_node"][::std::mem::size_of::<pm_class_node>() - 128usize];
    ["Alignment of pm_class_node"][::std::mem::align_of::<pm_class_node>() - 8usize];
    ["Offset of field: pm_class_node::base"][::std::mem::offset_of!(pm_class_node, base) - 0usize];
    ["Offset of field: pm_class_node::locals"]
        [::std::mem::offset_of!(pm_class_node, locals) - 24usize];
    ["Offset of field: pm_class_node::class_keyword_loc"]
        [::std::mem::offset_of!(pm_class_node, class_keyword_loc) - 48usize];
    ["Offset of field: pm_class_node::constant_path"]
        [::std::mem::offset_of!(pm_class_node, constant_path) - 64usize];
    ["Offset of field: pm_class_node::inheritance_operator_loc"]
        [::std::mem::offset_of!(pm_class_node, inheritance_operator_loc) - 72usize];
    ["Offset of field: pm_class_node::superclass"]
        [::std::mem::offset_of!(pm_class_node, superclass) - 88usize];
    ["Offset of field: pm_class_node::body"][::std::mem::offset_of!(pm_class_node, body) - 96usize];
    ["Offset of field: pm_class_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_class_node, end_keyword_loc) - 104usize];
    ["Offset of field: pm_class_node::name"]
        [::std::mem::offset_of!(pm_class_node, name) - 120usize];
};
#[doc = " ClassNode\n\n Represents a class declaration involving the `class` keyword.\n\n     class Foo end\n     ^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_NODE\n\n @extends pm_node_t"]
pub type pm_class_node_t = pm_class_node;
#[doc = " ClassVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a class variable.\n\n     @@target &&= value\n     ^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableAndWriteNode#name\n\n The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @@target &&= value # name `:@@target`\n     ^^^^^^^^"]
    pub name: pm_constant_id_t,
    #[doc = " ClassVariableAndWriteNode#name_loc\n\n Represents the location of the variable name.\n\n     @@target &&= value\n     ^^^^^^^^"]
    pub name_loc: pm_location_t,
    #[doc = " ClassVariableAndWriteNode#operator_loc\n\n Represents the location of the `&&=` operator.\n\n     @@target &&= value\n              ^^^"]
    pub operator_loc: pm_location_t,
    #[doc = " ClassVariableAndWriteNode#value\n\n Represents the value being assigned. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     @@target &&= value\n                  ^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_and_write_node"]
        [::std::mem::size_of::<pm_class_variable_and_write_node>() - 72usize];
    ["Alignment of pm_class_variable_and_write_node"]
        [::std::mem::align_of::<pm_class_variable_and_write_node>() - 8usize];
    ["Offset of field: pm_class_variable_and_write_node::base"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, base) - 0usize];
    ["Offset of field: pm_class_variable_and_write_node::name"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, name) - 24usize];
    ["Offset of field: pm_class_variable_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, name_loc) - 32usize];
    ["Offset of field: pm_class_variable_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, operator_loc) - 48usize];
    ["Offset of field: pm_class_variable_and_write_node::value"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, value) - 64usize];
};
#[doc = " ClassVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a class variable.\n\n     @@target &&= value\n     ^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_and_write_node_t = pm_class_variable_and_write_node;
#[doc = " ClassVariableOperatorWriteNode\n\n Represents assigning to a class variable using an operator that isn't `=`.\n\n     @@target += value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ClassVariableOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ClassVariableOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " ClassVariableOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " ClassVariableOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_operator_write_node"]
        [::std::mem::size_of::<pm_class_variable_operator_write_node>() - 80usize];
    ["Alignment of pm_class_variable_operator_write_node"]
        [::std::mem::align_of::<pm_class_variable_operator_write_node>() - 8usize];
    ["Offset of field: pm_class_variable_operator_write_node::base"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, base) - 0usize];
    ["Offset of field: pm_class_variable_operator_write_node::name"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, name) - 24usize];
    ["Offset of field: pm_class_variable_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, name_loc) - 32usize];
    ["Offset of field: pm_class_variable_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_class_variable_operator_write_node,
        binary_operator_loc
    ) - 48usize];
    ["Offset of field: pm_class_variable_operator_write_node::value"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, value) - 64usize];
    ["Offset of field: pm_class_variable_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, binary_operator) - 72usize];
};
#[doc = " ClassVariableOperatorWriteNode\n\n Represents assigning to a class variable using an operator that isn't `=`.\n\n     @@target += value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_operator_write_node_t = pm_class_variable_operator_write_node;
#[doc = " ClassVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a class variable.\n\n     @@target ||= value\n     ^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ClassVariableOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ClassVariableOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ClassVariableOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_or_write_node"]
        [::std::mem::size_of::<pm_class_variable_or_write_node>() - 72usize];
    ["Alignment of pm_class_variable_or_write_node"]
        [::std::mem::align_of::<pm_class_variable_or_write_node>() - 8usize];
    ["Offset of field: pm_class_variable_or_write_node::base"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, base) - 0usize];
    ["Offset of field: pm_class_variable_or_write_node::name"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, name) - 24usize];
    ["Offset of field: pm_class_variable_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, name_loc) - 32usize];
    ["Offset of field: pm_class_variable_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, operator_loc) - 48usize];
    ["Offset of field: pm_class_variable_or_write_node::value"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, value) - 64usize];
};
#[doc = " ClassVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a class variable.\n\n     @@target ||= value\n     ^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_or_write_node_t = pm_class_variable_or_write_node;
#[doc = " ClassVariableReadNode\n\n Represents referencing a class variable.\n\n     @@foo\n     ^^^^^\n\n Type: ::PM_CLASS_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableReadNode#name\n\n The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @@abc   # name `:@@abc`\n\n     @@_test # name `:@@_test`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_read_node"]
        [::std::mem::size_of::<pm_class_variable_read_node>() - 32usize];
    ["Alignment of pm_class_variable_read_node"]
        [::std::mem::align_of::<pm_class_variable_read_node>() - 8usize];
    ["Offset of field: pm_class_variable_read_node::base"]
        [::std::mem::offset_of!(pm_class_variable_read_node, base) - 0usize];
    ["Offset of field: pm_class_variable_read_node::name"]
        [::std::mem::offset_of!(pm_class_variable_read_node, name) - 24usize];
};
#[doc = " ClassVariableReadNode\n\n Represents referencing a class variable.\n\n     @@foo\n     ^^^^^\n\n Type: ::PM_CLASS_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_read_node_t = pm_class_variable_read_node;
#[doc = " ClassVariableTargetNode\n\n Represents writing to a class variable in a context that doesn't have an explicit value.\n\n     @@foo, @@bar = baz\n     ^^^^^  ^^^^^\n\n Type: ::PM_CLASS_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableTargetNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_target_node"]
        [::std::mem::size_of::<pm_class_variable_target_node>() - 32usize];
    ["Alignment of pm_class_variable_target_node"]
        [::std::mem::align_of::<pm_class_variable_target_node>() - 8usize];
    ["Offset of field: pm_class_variable_target_node::base"]
        [::std::mem::offset_of!(pm_class_variable_target_node, base) - 0usize];
    ["Offset of field: pm_class_variable_target_node::name"]
        [::std::mem::offset_of!(pm_class_variable_target_node, name) - 24usize];
};
#[doc = " ClassVariableTargetNode\n\n Represents writing to a class variable in a context that doesn't have an explicit value.\n\n     @@foo, @@bar = baz\n     ^^^^^  ^^^^^\n\n Type: ::PM_CLASS_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_target_node_t = pm_class_variable_target_node;
#[doc = " ClassVariableWriteNode\n\n Represents writing to a class variable.\n\n     @@foo = 1\n     ^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableWriteNode#name\n\n The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @@abc = 123     # name `@@abc`\n\n     @@_test = :test # name `@@_test`"]
    pub name: pm_constant_id_t,
    #[doc = " ClassVariableWriteNode#name_loc\n\n The location of the variable name.\n\n     @@foo = :bar\n     ^^^^^"]
    pub name_loc: pm_location_t,
    #[doc = " ClassVariableWriteNode#value\n\n The value to write to the class variable. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     @@foo = :bar\n             ^^^^\n\n     @@_xyz = 123\n              ^^^"]
    pub value: *mut pm_node,
    #[doc = " ClassVariableWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     @@foo = :bar\n           ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_write_node"]
        [::std::mem::size_of::<pm_class_variable_write_node>() - 72usize];
    ["Alignment of pm_class_variable_write_node"]
        [::std::mem::align_of::<pm_class_variable_write_node>() - 8usize];
    ["Offset of field: pm_class_variable_write_node::base"]
        [::std::mem::offset_of!(pm_class_variable_write_node, base) - 0usize];
    ["Offset of field: pm_class_variable_write_node::name"]
        [::std::mem::offset_of!(pm_class_variable_write_node, name) - 24usize];
    ["Offset of field: pm_class_variable_write_node::name_loc"]
        [::std::mem::offset_of!(pm_class_variable_write_node, name_loc) - 32usize];
    ["Offset of field: pm_class_variable_write_node::value"]
        [::std::mem::offset_of!(pm_class_variable_write_node, value) - 48usize];
    ["Offset of field: pm_class_variable_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_class_variable_write_node, operator_loc) - 56usize];
};
#[doc = " ClassVariableWriteNode\n\n Represents writing to a class variable.\n\n     @@foo = 1\n     ^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_write_node_t = pm_class_variable_write_node;
#[doc = " ConstantAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a constant.\n\n     Target &&= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantAndWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantAndWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ConstantAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_and_write_node"]
        [::std::mem::size_of::<pm_constant_and_write_node>() - 72usize];
    ["Alignment of pm_constant_and_write_node"]
        [::std::mem::align_of::<pm_constant_and_write_node>() - 8usize];
    ["Offset of field: pm_constant_and_write_node::base"]
        [::std::mem::offset_of!(pm_constant_and_write_node, base) - 0usize];
    ["Offset of field: pm_constant_and_write_node::name"]
        [::std::mem::offset_of!(pm_constant_and_write_node, name) - 24usize];
    ["Offset of field: pm_constant_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_and_write_node, name_loc) - 32usize];
    ["Offset of field: pm_constant_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_and_write_node, operator_loc) - 48usize];
    ["Offset of field: pm_constant_and_write_node::value"]
        [::std::mem::offset_of!(pm_constant_and_write_node, value) - 64usize];
};
#[doc = " ConstantAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a constant.\n\n     Target &&= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_and_write_node_t = pm_constant_and_write_node;
#[doc = " ConstantOperatorWriteNode\n\n Represents assigning to a constant using an operator that isn't `=`.\n\n     Target += value\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ConstantOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " ConstantOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " ConstantOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_operator_write_node"]
        [::std::mem::size_of::<pm_constant_operator_write_node>() - 80usize];
    ["Alignment of pm_constant_operator_write_node"]
        [::std::mem::align_of::<pm_constant_operator_write_node>() - 8usize];
    ["Offset of field: pm_constant_operator_write_node::base"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, base) - 0usize];
    ["Offset of field: pm_constant_operator_write_node::name"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, name) - 24usize];
    ["Offset of field: pm_constant_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, name_loc) - 32usize];
    ["Offset of field: pm_constant_operator_write_node::binary_operator_loc"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, binary_operator_loc) - 48usize];
    ["Offset of field: pm_constant_operator_write_node::value"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, value) - 64usize];
    ["Offset of field: pm_constant_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, binary_operator) - 72usize];
};
#[doc = " ConstantOperatorWriteNode\n\n Represents assigning to a constant using an operator that isn't `=`.\n\n     Target += value\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_operator_write_node_t = pm_constant_operator_write_node;
#[doc = " ConstantOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a constant.\n\n     Target ||= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ConstantOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_or_write_node"]
        [::std::mem::size_of::<pm_constant_or_write_node>() - 72usize];
    ["Alignment of pm_constant_or_write_node"]
        [::std::mem::align_of::<pm_constant_or_write_node>() - 8usize];
    ["Offset of field: pm_constant_or_write_node::base"]
        [::std::mem::offset_of!(pm_constant_or_write_node, base) - 0usize];
    ["Offset of field: pm_constant_or_write_node::name"]
        [::std::mem::offset_of!(pm_constant_or_write_node, name) - 24usize];
    ["Offset of field: pm_constant_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_or_write_node, name_loc) - 32usize];
    ["Offset of field: pm_constant_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_or_write_node, operator_loc) - 48usize];
    ["Offset of field: pm_constant_or_write_node::value"]
        [::std::mem::offset_of!(pm_constant_or_write_node, value) - 64usize];
};
#[doc = " ConstantOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a constant.\n\n     Target ||= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_or_write_node_t = pm_constant_or_write_node;
#[doc = " ConstantPathAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a constant path.\n\n     Parent::Child &&= value\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathAndWriteNode#target"]
    pub target: *mut pm_constant_path_node,
    #[doc = " ConstantPathAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantPathAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_and_write_node"]
        [::std::mem::size_of::<pm_constant_path_and_write_node>() - 56usize];
    ["Alignment of pm_constant_path_and_write_node"]
        [::std::mem::align_of::<pm_constant_path_and_write_node>() - 8usize];
    ["Offset of field: pm_constant_path_and_write_node::base"]
        [::std::mem::offset_of!(pm_constant_path_and_write_node, base) - 0usize];
    ["Offset of field: pm_constant_path_and_write_node::target"]
        [::std::mem::offset_of!(pm_constant_path_and_write_node, target) - 24usize];
    ["Offset of field: pm_constant_path_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_path_and_write_node, operator_loc) - 32usize];
    ["Offset of field: pm_constant_path_and_write_node::value"]
        [::std::mem::offset_of!(pm_constant_path_and_write_node, value) - 48usize];
};
#[doc = " ConstantPathAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a constant path.\n\n     Parent::Child &&= value\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_and_write_node_t = pm_constant_path_and_write_node;
#[doc = " ConstantPathNode\n\n Represents accessing a constant through a path of `::` operators.\n\n     Foo::Bar\n     ^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathNode#parent\n\n The left-hand node of the path, if present. It can be `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression). It will be `nil` when the constant lookup is at the root of the module tree.\n\n     Foo::Bar\n     ^^^\n\n     self::Test\n     ^^^^\n\n     a.b::C\n     ^^^"]
    pub parent: *mut pm_node,
    #[doc = " ConstantPathNode#name\n\n The name of the constant being accessed. This could be `nil` in the event of a syntax error."]
    pub name: pm_constant_id_t,
    #[doc = " ConstantPathNode#delimiter_loc\n\n The location of the `::` delimiter.\n\n     ::Foo\n     ^^\n\n     One::Two\n        ^^"]
    pub delimiter_loc: pm_location_t,
    #[doc = " ConstantPathNode#name_loc\n\n The location of the name of the constant.\n\n     ::Foo\n       ^^^\n\n     One::Two\n          ^^^"]
    pub name_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_node"][::std::mem::size_of::<pm_constant_path_node>() - 72usize];
    ["Alignment of pm_constant_path_node"]
        [::std::mem::align_of::<pm_constant_path_node>() - 8usize];
    ["Offset of field: pm_constant_path_node::base"]
        [::std::mem::offset_of!(pm_constant_path_node, base) - 0usize];
    ["Offset of field: pm_constant_path_node::parent"]
        [::std::mem::offset_of!(pm_constant_path_node, parent) - 24usize];
    ["Offset of field: pm_constant_path_node::name"]
        [::std::mem::offset_of!(pm_constant_path_node, name) - 32usize];
    ["Offset of field: pm_constant_path_node::delimiter_loc"]
        [::std::mem::offset_of!(pm_constant_path_node, delimiter_loc) - 40usize];
    ["Offset of field: pm_constant_path_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_path_node, name_loc) - 56usize];
};
#[doc = " ConstantPathNode\n\n Represents accessing a constant through a path of `::` operators.\n\n     Foo::Bar\n     ^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_node_t = pm_constant_path_node;
#[doc = " ConstantPathOperatorWriteNode\n\n Represents assigning to a constant path using an operator that isn't `=`.\n\n     Parent::Child += value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathOperatorWriteNode#target"]
    pub target: *mut pm_constant_path_node,
    #[doc = " ConstantPathOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " ConstantPathOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " ConstantPathOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_operator_write_node"]
        [::std::mem::size_of::<pm_constant_path_operator_write_node>() - 64usize];
    ["Alignment of pm_constant_path_operator_write_node"]
        [::std::mem::align_of::<pm_constant_path_operator_write_node>() - 8usize];
    ["Offset of field: pm_constant_path_operator_write_node::base"]
        [::std::mem::offset_of!(pm_constant_path_operator_write_node, base) - 0usize];
    ["Offset of field: pm_constant_path_operator_write_node::target"]
        [::std::mem::offset_of!(pm_constant_path_operator_write_node, target) - 24usize];
    ["Offset of field: pm_constant_path_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_constant_path_operator_write_node,
        binary_operator_loc
    ) - 32usize];
    ["Offset of field: pm_constant_path_operator_write_node::value"]
        [::std::mem::offset_of!(pm_constant_path_operator_write_node, value) - 48usize];
    ["Offset of field: pm_constant_path_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_constant_path_operator_write_node, binary_operator) - 56usize];
};
#[doc = " ConstantPathOperatorWriteNode\n\n Represents assigning to a constant path using an operator that isn't `=`.\n\n     Parent::Child += value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_operator_write_node_t = pm_constant_path_operator_write_node;
#[doc = " ConstantPathOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a constant path.\n\n     Parent::Child ||= value\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathOrWriteNode#target"]
    pub target: *mut pm_constant_path_node,
    #[doc = " ConstantPathOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantPathOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_or_write_node"]
        [::std::mem::size_of::<pm_constant_path_or_write_node>() - 56usize];
    ["Alignment of pm_constant_path_or_write_node"]
        [::std::mem::align_of::<pm_constant_path_or_write_node>() - 8usize];
    ["Offset of field: pm_constant_path_or_write_node::base"]
        [::std::mem::offset_of!(pm_constant_path_or_write_node, base) - 0usize];
    ["Offset of field: pm_constant_path_or_write_node::target"]
        [::std::mem::offset_of!(pm_constant_path_or_write_node, target) - 24usize];
    ["Offset of field: pm_constant_path_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_path_or_write_node, operator_loc) - 32usize];
    ["Offset of field: pm_constant_path_or_write_node::value"]
        [::std::mem::offset_of!(pm_constant_path_or_write_node, value) - 48usize];
};
#[doc = " ConstantPathOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a constant path.\n\n     Parent::Child ||= value\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_or_write_node_t = pm_constant_path_or_write_node;
#[doc = " ConstantPathTargetNode\n\n Represents writing to a constant path in a context that doesn't have an explicit value.\n\n     Foo::Foo, Bar::Bar = baz\n     ^^^^^^^^  ^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathTargetNode#parent"]
    pub parent: *mut pm_node,
    #[doc = " ConstantPathTargetNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantPathTargetNode#delimiter_loc"]
    pub delimiter_loc: pm_location_t,
    #[doc = " ConstantPathTargetNode#name_loc"]
    pub name_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_target_node"]
        [::std::mem::size_of::<pm_constant_path_target_node>() - 72usize];
    ["Alignment of pm_constant_path_target_node"]
        [::std::mem::align_of::<pm_constant_path_target_node>() - 8usize];
    ["Offset of field: pm_constant_path_target_node::base"]
        [::std::mem::offset_of!(pm_constant_path_target_node, base) - 0usize];
    ["Offset of field: pm_constant_path_target_node::parent"]
        [::std::mem::offset_of!(pm_constant_path_target_node, parent) - 24usize];
    ["Offset of field: pm_constant_path_target_node::name"]
        [::std::mem::offset_of!(pm_constant_path_target_node, name) - 32usize];
    ["Offset of field: pm_constant_path_target_node::delimiter_loc"]
        [::std::mem::offset_of!(pm_constant_path_target_node, delimiter_loc) - 40usize];
    ["Offset of field: pm_constant_path_target_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_path_target_node, name_loc) - 56usize];
};
#[doc = " ConstantPathTargetNode\n\n Represents writing to a constant path in a context that doesn't have an explicit value.\n\n     Foo::Foo, Bar::Bar = baz\n     ^^^^^^^^  ^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_target_node_t = pm_constant_path_target_node;
#[doc = " ConstantPathWriteNode\n\n Represents writing to a constant path.\n\n     ::Foo = 1\n     ^^^^^^^^^\n\n     Foo::Bar = 1\n     ^^^^^^^^^^^^\n\n     ::Foo::Bar = 1\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathWriteNode#target\n\n A node representing the constant path being written to.\n\n     Foo::Bar = 1\n     ^^^^^^^^\n\n     ::Foo = :abc\n     ^^^^^"]
    pub target: *mut pm_constant_path_node,
    #[doc = " ConstantPathWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     ::ABC = 123\n           ^"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantPathWriteNode#value\n\n The value to write to the constant path. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     FOO::BAR = :abc\n                ^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_write_node"]
        [::std::mem::size_of::<pm_constant_path_write_node>() - 56usize];
    ["Alignment of pm_constant_path_write_node"]
        [::std::mem::align_of::<pm_constant_path_write_node>() - 8usize];
    ["Offset of field: pm_constant_path_write_node::base"]
        [::std::mem::offset_of!(pm_constant_path_write_node, base) - 0usize];
    ["Offset of field: pm_constant_path_write_node::target"]
        [::std::mem::offset_of!(pm_constant_path_write_node, target) - 24usize];
    ["Offset of field: pm_constant_path_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_path_write_node, operator_loc) - 32usize];
    ["Offset of field: pm_constant_path_write_node::value"]
        [::std::mem::offset_of!(pm_constant_path_write_node, value) - 48usize];
};
#[doc = " ConstantPathWriteNode\n\n Represents writing to a constant path.\n\n     ::Foo = 1\n     ^^^^^^^^^\n\n     Foo::Bar = 1\n     ^^^^^^^^^^^^\n\n     ::Foo::Bar = 1\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_write_node_t = pm_constant_path_write_node;
#[doc = " ConstantReadNode\n\n Represents referencing a constant.\n\n     Foo\n     ^^^\n\n Type: ::PM_CONSTANT_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantReadNode#name\n\n The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).\n\n     X              # name `:X`\n\n     SOME_CONSTANT  # name `:SOME_CONSTANT`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_read_node"][::std::mem::size_of::<pm_constant_read_node>() - 32usize];
    ["Alignment of pm_constant_read_node"]
        [::std::mem::align_of::<pm_constant_read_node>() - 8usize];
    ["Offset of field: pm_constant_read_node::base"]
        [::std::mem::offset_of!(pm_constant_read_node, base) - 0usize];
    ["Offset of field: pm_constant_read_node::name"]
        [::std::mem::offset_of!(pm_constant_read_node, name) - 24usize];
};
#[doc = " ConstantReadNode\n\n Represents referencing a constant.\n\n     Foo\n     ^^^\n\n Type: ::PM_CONSTANT_READ_NODE\n\n @extends pm_node_t"]
pub type pm_constant_read_node_t = pm_constant_read_node;
#[doc = " ConstantTargetNode\n\n Represents writing to a constant in a context that doesn't have an explicit value.\n\n     Foo, Bar = baz\n     ^^^  ^^^\n\n Type: ::PM_CONSTANT_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantTargetNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_target_node"][::std::mem::size_of::<pm_constant_target_node>() - 32usize];
    ["Alignment of pm_constant_target_node"]
        [::std::mem::align_of::<pm_constant_target_node>() - 8usize];
    ["Offset of field: pm_constant_target_node::base"]
        [::std::mem::offset_of!(pm_constant_target_node, base) - 0usize];
    ["Offset of field: pm_constant_target_node::name"]
        [::std::mem::offset_of!(pm_constant_target_node, name) - 24usize];
};
#[doc = " ConstantTargetNode\n\n Represents writing to a constant in a context that doesn't have an explicit value.\n\n     Foo, Bar = baz\n     ^^^  ^^^\n\n Type: ::PM_CONSTANT_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_constant_target_node_t = pm_constant_target_node;
#[doc = " ConstantWriteNode\n\n Represents writing to a constant.\n\n     Foo = 1\n     ^^^^^^^\n\n Type: ::PM_CONSTANT_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantWriteNode#name\n\n The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).\n\n     Foo = :bar # name `:Foo`\n\n     XYZ = 1    # name `:XYZ`"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantWriteNode#name_loc\n\n The location of the constant name.\n\n     FOO = 1\n     ^^^"]
    pub name_loc: pm_location_t,
    #[doc = " ConstantWriteNode#value\n\n The value to write to the constant. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     FOO = :bar\n           ^^^^\n\n     MyClass = Class.new\n               ^^^^^^^^^"]
    pub value: *mut pm_node,
    #[doc = " ConstantWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     FOO = :bar\n         ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_write_node"][::std::mem::size_of::<pm_constant_write_node>() - 72usize];
    ["Alignment of pm_constant_write_node"]
        [::std::mem::align_of::<pm_constant_write_node>() - 8usize];
    ["Offset of field: pm_constant_write_node::base"]
        [::std::mem::offset_of!(pm_constant_write_node, base) - 0usize];
    ["Offset of field: pm_constant_write_node::name"]
        [::std::mem::offset_of!(pm_constant_write_node, name) - 24usize];
    ["Offset of field: pm_constant_write_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_write_node, name_loc) - 32usize];
    ["Offset of field: pm_constant_write_node::value"]
        [::std::mem::offset_of!(pm_constant_write_node, value) - 48usize];
    ["Offset of field: pm_constant_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_write_node, operator_loc) - 56usize];
};
#[doc = " ConstantWriteNode\n\n Represents writing to a constant.\n\n     Foo = 1\n     ^^^^^^^\n\n Type: ::PM_CONSTANT_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_write_node_t = pm_constant_write_node;
#[doc = " DefNode\n\n Represents a method definition.\n\n     def method\n     end\n     ^^^^^^^^^^\n\n Type: ::PM_DEF_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_def_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " DefNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " DefNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " DefNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " DefNode#parameters"]
    pub parameters: *mut pm_parameters_node,
    #[doc = " DefNode#body"]
    pub body: *mut pm_node,
    #[doc = " DefNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " DefNode#def_keyword_loc"]
    pub def_keyword_loc: pm_location_t,
    #[doc = " DefNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " DefNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " DefNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
    #[doc = " DefNode#equal_loc"]
    pub equal_loc: pm_location_t,
    #[doc = " DefNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_def_node"][::std::mem::size_of::<pm_def_node>() - 192usize];
    ["Alignment of pm_def_node"][::std::mem::align_of::<pm_def_node>() - 8usize];
    ["Offset of field: pm_def_node::base"][::std::mem::offset_of!(pm_def_node, base) - 0usize];
    ["Offset of field: pm_def_node::name"][::std::mem::offset_of!(pm_def_node, name) - 24usize];
    ["Offset of field: pm_def_node::name_loc"]
        [::std::mem::offset_of!(pm_def_node, name_loc) - 32usize];
    ["Offset of field: pm_def_node::receiver"]
        [::std::mem::offset_of!(pm_def_node, receiver) - 48usize];
    ["Offset of field: pm_def_node::parameters"]
        [::std::mem::offset_of!(pm_def_node, parameters) - 56usize];
    ["Offset of field: pm_def_node::body"][::std::mem::offset_of!(pm_def_node, body) - 64usize];
    ["Offset of field: pm_def_node::locals"][::std::mem::offset_of!(pm_def_node, locals) - 72usize];
    ["Offset of field: pm_def_node::def_keyword_loc"]
        [::std::mem::offset_of!(pm_def_node, def_keyword_loc) - 96usize];
    ["Offset of field: pm_def_node::operator_loc"]
        [::std::mem::offset_of!(pm_def_node, operator_loc) - 112usize];
    ["Offset of field: pm_def_node::lparen_loc"]
        [::std::mem::offset_of!(pm_def_node, lparen_loc) - 128usize];
    ["Offset of field: pm_def_node::rparen_loc"]
        [::std::mem::offset_of!(pm_def_node, rparen_loc) - 144usize];
    ["Offset of field: pm_def_node::equal_loc"]
        [::std::mem::offset_of!(pm_def_node, equal_loc) - 160usize];
    ["Offset of field: pm_def_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_def_node, end_keyword_loc) - 176usize];
};
#[doc = " DefNode\n\n Represents a method definition.\n\n     def method\n     end\n     ^^^^^^^^^^\n\n Type: ::PM_DEF_NODE\n\n @extends pm_node_t"]
pub type pm_def_node_t = pm_def_node;
#[doc = " DefinedNode\n\n Represents the use of the `defined?` keyword.\n\n     defined?(a)\n     ^^^^^^^^^^^\n\n Type: ::PM_DEFINED_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_defined_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " DefinedNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " DefinedNode#value"]
    pub value: *mut pm_node,
    #[doc = " DefinedNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
    #[doc = " DefinedNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_defined_node"][::std::mem::size_of::<pm_defined_node>() - 80usize];
    ["Alignment of pm_defined_node"][::std::mem::align_of::<pm_defined_node>() - 8usize];
    ["Offset of field: pm_defined_node::base"]
        [::std::mem::offset_of!(pm_defined_node, base) - 0usize];
    ["Offset of field: pm_defined_node::lparen_loc"]
        [::std::mem::offset_of!(pm_defined_node, lparen_loc) - 24usize];
    ["Offset of field: pm_defined_node::value"]
        [::std::mem::offset_of!(pm_defined_node, value) - 40usize];
    ["Offset of field: pm_defined_node::rparen_loc"]
        [::std::mem::offset_of!(pm_defined_node, rparen_loc) - 48usize];
    ["Offset of field: pm_defined_node::keyword_loc"]
        [::std::mem::offset_of!(pm_defined_node, keyword_loc) - 64usize];
};
#[doc = " DefinedNode\n\n Represents the use of the `defined?` keyword.\n\n     defined?(a)\n     ^^^^^^^^^^^\n\n Type: ::PM_DEFINED_NODE\n\n @extends pm_node_t"]
pub type pm_defined_node_t = pm_defined_node;
#[doc = " ElseNode\n\n Represents an `else` clause in a `case`, `if`, or `unless` statement.\n\n     if a then b else c end\n                 ^^^^^^^^^^\n\n Type: ::PM_ELSE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_else_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ElseNode#else_keyword_loc"]
    pub else_keyword_loc: pm_location_t,
    #[doc = " ElseNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " ElseNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_else_node"][::std::mem::size_of::<pm_else_node>() - 64usize];
    ["Alignment of pm_else_node"][::std::mem::align_of::<pm_else_node>() - 8usize];
    ["Offset of field: pm_else_node::base"][::std::mem::offset_of!(pm_else_node, base) - 0usize];
    ["Offset of field: pm_else_node::else_keyword_loc"]
        [::std::mem::offset_of!(pm_else_node, else_keyword_loc) - 24usize];
    ["Offset of field: pm_else_node::statements"]
        [::std::mem::offset_of!(pm_else_node, statements) - 40usize];
    ["Offset of field: pm_else_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_else_node, end_keyword_loc) - 48usize];
};
#[doc = " ElseNode\n\n Represents an `else` clause in a `case`, `if`, or `unless` statement.\n\n     if a then b else c end\n                 ^^^^^^^^^^\n\n Type: ::PM_ELSE_NODE\n\n @extends pm_node_t"]
pub type pm_else_node_t = pm_else_node;
#[doc = " EmbeddedStatementsNode\n\n Represents an interpolated set of statements.\n\n     \"foo #{bar}\"\n          ^^^^^^\n\n Type: ::PM_EMBEDDED_STATEMENTS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_embedded_statements_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " EmbeddedStatementsNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " EmbeddedStatementsNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " EmbeddedStatementsNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_embedded_statements_node"]
        [::std::mem::size_of::<pm_embedded_statements_node>() - 64usize];
    ["Alignment of pm_embedded_statements_node"]
        [::std::mem::align_of::<pm_embedded_statements_node>() - 8usize];
    ["Offset of field: pm_embedded_statements_node::base"]
        [::std::mem::offset_of!(pm_embedded_statements_node, base) - 0usize];
    ["Offset of field: pm_embedded_statements_node::opening_loc"]
        [::std::mem::offset_of!(pm_embedded_statements_node, opening_loc) - 24usize];
    ["Offset of field: pm_embedded_statements_node::statements"]
        [::std::mem::offset_of!(pm_embedded_statements_node, statements) - 40usize];
    ["Offset of field: pm_embedded_statements_node::closing_loc"]
        [::std::mem::offset_of!(pm_embedded_statements_node, closing_loc) - 48usize];
};
#[doc = " EmbeddedStatementsNode\n\n Represents an interpolated set of statements.\n\n     \"foo #{bar}\"\n          ^^^^^^\n\n Type: ::PM_EMBEDDED_STATEMENTS_NODE\n\n @extends pm_node_t"]
pub type pm_embedded_statements_node_t = pm_embedded_statements_node;
#[doc = " EmbeddedVariableNode\n\n Represents an interpolated variable.\n\n     \"foo #@bar\"\n          ^^^^^\n\n Type: ::PM_EMBEDDED_VARIABLE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_embedded_variable_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " EmbeddedVariableNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " EmbeddedVariableNode#variable"]
    pub variable: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_embedded_variable_node"]
        [::std::mem::size_of::<pm_embedded_variable_node>() - 48usize];
    ["Alignment of pm_embedded_variable_node"]
        [::std::mem::align_of::<pm_embedded_variable_node>() - 8usize];
    ["Offset of field: pm_embedded_variable_node::base"]
        [::std::mem::offset_of!(pm_embedded_variable_node, base) - 0usize];
    ["Offset of field: pm_embedded_variable_node::operator_loc"]
        [::std::mem::offset_of!(pm_embedded_variable_node, operator_loc) - 24usize];
    ["Offset of field: pm_embedded_variable_node::variable"]
        [::std::mem::offset_of!(pm_embedded_variable_node, variable) - 40usize];
};
#[doc = " EmbeddedVariableNode\n\n Represents an interpolated variable.\n\n     \"foo #@bar\"\n          ^^^^^\n\n Type: ::PM_EMBEDDED_VARIABLE_NODE\n\n @extends pm_node_t"]
pub type pm_embedded_variable_node_t = pm_embedded_variable_node;
#[doc = " EnsureNode\n\n Represents an `ensure` clause in a `begin` statement.\n\n     begin\n       foo\n     ensure\n     ^^^^^^\n       bar\n     end\n\n Type: ::PM_ENSURE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_ensure_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " EnsureNode#ensure_keyword_loc"]
    pub ensure_keyword_loc: pm_location_t,
    #[doc = " EnsureNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " EnsureNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_ensure_node"][::std::mem::size_of::<pm_ensure_node>() - 64usize];
    ["Alignment of pm_ensure_node"][::std::mem::align_of::<pm_ensure_node>() - 8usize];
    ["Offset of field: pm_ensure_node::base"]
        [::std::mem::offset_of!(pm_ensure_node, base) - 0usize];
    ["Offset of field: pm_ensure_node::ensure_keyword_loc"]
        [::std::mem::offset_of!(pm_ensure_node, ensure_keyword_loc) - 24usize];
    ["Offset of field: pm_ensure_node::statements"]
        [::std::mem::offset_of!(pm_ensure_node, statements) - 40usize];
    ["Offset of field: pm_ensure_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_ensure_node, end_keyword_loc) - 48usize];
};
#[doc = " EnsureNode\n\n Represents an `ensure` clause in a `begin` statement.\n\n     begin\n       foo\n     ensure\n     ^^^^^^\n       bar\n     end\n\n Type: ::PM_ENSURE_NODE\n\n @extends pm_node_t"]
pub type pm_ensure_node_t = pm_ensure_node;
#[doc = " FalseNode\n\n Represents the use of the literal `false` keyword.\n\n     false\n     ^^^^^\n\n Type: ::PM_FALSE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_false_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_false_node"][::std::mem::size_of::<pm_false_node>() - 24usize];
    ["Alignment of pm_false_node"][::std::mem::align_of::<pm_false_node>() - 8usize];
    ["Offset of field: pm_false_node::base"][::std::mem::offset_of!(pm_false_node, base) - 0usize];
};
#[doc = " FalseNode\n\n Represents the use of the literal `false` keyword.\n\n     false\n     ^^^^^\n\n Type: ::PM_FALSE_NODE\n\n @extends pm_node_t"]
pub type pm_false_node_t = pm_false_node;
#[doc = " FindPatternNode\n\n Represents a find pattern in pattern matching.\n\n     foo in *bar, baz, *qux\n            ^^^^^^^^^^^^^^^\n\n     foo in [*bar, baz, *qux]\n            ^^^^^^^^^^^^^^^^^\n\n     foo in Foo(*bar, baz, *qux)\n            ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_FIND_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_find_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " FindPatternNode#constant"]
    pub constant: *mut pm_node,
    #[doc = " FindPatternNode#left"]
    pub left: *mut pm_splat_node,
    #[doc = " FindPatternNode#requireds"]
    pub requireds: pm_node_list,
    #[doc = " FindPatternNode#right"]
    pub right: *mut pm_node,
    #[doc = " FindPatternNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " FindPatternNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_find_pattern_node"][::std::mem::size_of::<pm_find_pattern_node>() - 104usize];
    ["Alignment of pm_find_pattern_node"][::std::mem::align_of::<pm_find_pattern_node>() - 8usize];
    ["Offset of field: pm_find_pattern_node::base"]
        [::std::mem::offset_of!(pm_find_pattern_node, base) - 0usize];
    ["Offset of field: pm_find_pattern_node::constant"]
        [::std::mem::offset_of!(pm_find_pattern_node, constant) - 24usize];
    ["Offset of field: pm_find_pattern_node::left"]
        [::std::mem::offset_of!(pm_find_pattern_node, left) - 32usize];
    ["Offset of field: pm_find_pattern_node::requireds"]
        [::std::mem::offset_of!(pm_find_pattern_node, requireds) - 40usize];
    ["Offset of field: pm_find_pattern_node::right"]
        [::std::mem::offset_of!(pm_find_pattern_node, right) - 64usize];
    ["Offset of field: pm_find_pattern_node::opening_loc"]
        [::std::mem::offset_of!(pm_find_pattern_node, opening_loc) - 72usize];
    ["Offset of field: pm_find_pattern_node::closing_loc"]
        [::std::mem::offset_of!(pm_find_pattern_node, closing_loc) - 88usize];
};
#[doc = " FindPatternNode\n\n Represents a find pattern in pattern matching.\n\n     foo in *bar, baz, *qux\n            ^^^^^^^^^^^^^^^\n\n     foo in [*bar, baz, *qux]\n            ^^^^^^^^^^^^^^^^^\n\n     foo in Foo(*bar, baz, *qux)\n            ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_FIND_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_find_pattern_node_t = pm_find_pattern_node;
#[doc = " FlipFlopNode\n\n Represents the use of the `..` or `...` operators to create flip flops.\n\n     baz if foo .. bar\n            ^^^^^^^^^^\n\n Type: ::PM_FLIP_FLOP_NODE\n\n Flags (#pm_range_flags):\n * ::PM_RANGE_FLAGS_EXCLUDE_END\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_flip_flop_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " FlipFlopNode#left"]
    pub left: *mut pm_node,
    #[doc = " FlipFlopNode#right"]
    pub right: *mut pm_node,
    #[doc = " FlipFlopNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_flip_flop_node"][::std::mem::size_of::<pm_flip_flop_node>() - 56usize];
    ["Alignment of pm_flip_flop_node"][::std::mem::align_of::<pm_flip_flop_node>() - 8usize];
    ["Offset of field: pm_flip_flop_node::base"]
        [::std::mem::offset_of!(pm_flip_flop_node, base) - 0usize];
    ["Offset of field: pm_flip_flop_node::left"]
        [::std::mem::offset_of!(pm_flip_flop_node, left) - 24usize];
    ["Offset of field: pm_flip_flop_node::right"]
        [::std::mem::offset_of!(pm_flip_flop_node, right) - 32usize];
    ["Offset of field: pm_flip_flop_node::operator_loc"]
        [::std::mem::offset_of!(pm_flip_flop_node, operator_loc) - 40usize];
};
#[doc = " FlipFlopNode\n\n Represents the use of the `..` or `...` operators to create flip flops.\n\n     baz if foo .. bar\n            ^^^^^^^^^^\n\n Type: ::PM_FLIP_FLOP_NODE\n\n Flags (#pm_range_flags):\n * ::PM_RANGE_FLAGS_EXCLUDE_END\n\n @extends pm_node_t"]
pub type pm_flip_flop_node_t = pm_flip_flop_node;
#[doc = " FloatNode\n\n Represents a floating point number literal.\n\n     1.0\n     ^^^\n\n Type: ::PM_FLOAT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_float_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " FloatNode#value\n\n The value of the floating point number as a Float."]
    pub value: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_float_node"][::std::mem::size_of::<pm_float_node>() - 32usize];
    ["Alignment of pm_float_node"][::std::mem::align_of::<pm_float_node>() - 8usize];
    ["Offset of field: pm_float_node::base"][::std::mem::offset_of!(pm_float_node, base) - 0usize];
    ["Offset of field: pm_float_node::value"]
        [::std::mem::offset_of!(pm_float_node, value) - 24usize];
};
#[doc = " FloatNode\n\n Represents a floating point number literal.\n\n     1.0\n     ^^^\n\n Type: ::PM_FLOAT_NODE\n\n @extends pm_node_t"]
pub type pm_float_node_t = pm_float_node;
#[doc = " ForNode\n\n Represents the use of the `for` keyword.\n\n     for i in a end\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_FOR_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_for_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ForNode#index\n\n The index expression for `for` loops.\n\n     for i in a end\n         ^"]
    pub index: *mut pm_node,
    #[doc = " ForNode#collection\n\n The collection to iterate over.\n\n     for i in a end\n              ^"]
    pub collection: *mut pm_node,
    #[doc = " ForNode#statements\n\n Represents the body of statements to execute for each iteration of the loop.\n\n     for i in a\n       foo(i)\n       ^^^^^^\n     end"]
    pub statements: *mut pm_statements_node,
    #[doc = " ForNode#for_keyword_loc\n\n The location of the `for` keyword.\n\n     for i in a end\n     ^^^"]
    pub for_keyword_loc: pm_location_t,
    #[doc = " ForNode#in_keyword_loc\n\n The location of the `in` keyword.\n\n     for i in a end\n           ^^"]
    pub in_keyword_loc: pm_location_t,
    #[doc = " ForNode#do_keyword_loc\n\n The location of the `do` keyword, if present.\n\n     for i in a do end\n                ^^"]
    pub do_keyword_loc: pm_location_t,
    #[doc = " ForNode#end_keyword_loc\n\n The location of the `end` keyword.\n\n     for i in a end\n                ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_for_node"][::std::mem::size_of::<pm_for_node>() - 112usize];
    ["Alignment of pm_for_node"][::std::mem::align_of::<pm_for_node>() - 8usize];
    ["Offset of field: pm_for_node::base"][::std::mem::offset_of!(pm_for_node, base) - 0usize];
    ["Offset of field: pm_for_node::index"][::std::mem::offset_of!(pm_for_node, index) - 24usize];
    ["Offset of field: pm_for_node::collection"]
        [::std::mem::offset_of!(pm_for_node, collection) - 32usize];
    ["Offset of field: pm_for_node::statements"]
        [::std::mem::offset_of!(pm_for_node, statements) - 40usize];
    ["Offset of field: pm_for_node::for_keyword_loc"]
        [::std::mem::offset_of!(pm_for_node, for_keyword_loc) - 48usize];
    ["Offset of field: pm_for_node::in_keyword_loc"]
        [::std::mem::offset_of!(pm_for_node, in_keyword_loc) - 64usize];
    ["Offset of field: pm_for_node::do_keyword_loc"]
        [::std::mem::offset_of!(pm_for_node, do_keyword_loc) - 80usize];
    ["Offset of field: pm_for_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_for_node, end_keyword_loc) - 96usize];
};
#[doc = " ForNode\n\n Represents the use of the `for` keyword.\n\n     for i in a end\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_FOR_NODE\n\n @extends pm_node_t"]
pub type pm_for_node_t = pm_for_node;
#[doc = " ForwardingArgumentsNode\n\n Represents forwarding all arguments to this method to another method.\n\n     def foo(...)\n       bar(...)\n           ^^^\n     end\n\n Type: ::PM_FORWARDING_ARGUMENTS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_forwarding_arguments_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_forwarding_arguments_node"]
        [::std::mem::size_of::<pm_forwarding_arguments_node>() - 24usize];
    ["Alignment of pm_forwarding_arguments_node"]
        [::std::mem::align_of::<pm_forwarding_arguments_node>() - 8usize];
    ["Offset of field: pm_forwarding_arguments_node::base"]
        [::std::mem::offset_of!(pm_forwarding_arguments_node, base) - 0usize];
};
#[doc = " ForwardingArgumentsNode\n\n Represents forwarding all arguments to this method to another method.\n\n     def foo(...)\n       bar(...)\n           ^^^\n     end\n\n Type: ::PM_FORWARDING_ARGUMENTS_NODE\n\n @extends pm_node_t"]
pub type pm_forwarding_arguments_node_t = pm_forwarding_arguments_node;
#[doc = " ForwardingParameterNode\n\n Represents the use of the forwarding parameter in a method, block, or lambda declaration.\n\n     def foo(...)\n             ^^^\n     end\n\n Type: ::PM_FORWARDING_PARAMETER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_forwarding_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_forwarding_parameter_node"]
        [::std::mem::size_of::<pm_forwarding_parameter_node>() - 24usize];
    ["Alignment of pm_forwarding_parameter_node"]
        [::std::mem::align_of::<pm_forwarding_parameter_node>() - 8usize];
    ["Offset of field: pm_forwarding_parameter_node::base"]
        [::std::mem::offset_of!(pm_forwarding_parameter_node, base) - 0usize];
};
#[doc = " ForwardingParameterNode\n\n Represents the use of the forwarding parameter in a method, block, or lambda declaration.\n\n     def foo(...)\n             ^^^\n     end\n\n Type: ::PM_FORWARDING_PARAMETER_NODE\n\n @extends pm_node_t"]
pub type pm_forwarding_parameter_node_t = pm_forwarding_parameter_node;
#[doc = " ForwardingSuperNode\n\n Represents the use of the `super` keyword without parentheses or arguments.\n\n     super\n     ^^^^^\n\n Type: ::PM_FORWARDING_SUPER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_forwarding_super_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ForwardingSuperNode#block"]
    pub block: *mut pm_block_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_forwarding_super_node"]
        [::std::mem::size_of::<pm_forwarding_super_node>() - 32usize];
    ["Alignment of pm_forwarding_super_node"]
        [::std::mem::align_of::<pm_forwarding_super_node>() - 8usize];
    ["Offset of field: pm_forwarding_super_node::base"]
        [::std::mem::offset_of!(pm_forwarding_super_node, base) - 0usize];
    ["Offset of field: pm_forwarding_super_node::block"]
        [::std::mem::offset_of!(pm_forwarding_super_node, block) - 24usize];
};
#[doc = " ForwardingSuperNode\n\n Represents the use of the `super` keyword without parentheses or arguments.\n\n     super\n     ^^^^^\n\n Type: ::PM_FORWARDING_SUPER_NODE\n\n @extends pm_node_t"]
pub type pm_forwarding_super_node_t = pm_forwarding_super_node;
#[doc = " GlobalVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a global variable.\n\n     $target &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableAndWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " GlobalVariableAndWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " GlobalVariableAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " GlobalVariableAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_and_write_node"]
        [::std::mem::size_of::<pm_global_variable_and_write_node>() - 72usize];
    ["Alignment of pm_global_variable_and_write_node"]
        [::std::mem::align_of::<pm_global_variable_and_write_node>() - 8usize];
    ["Offset of field: pm_global_variable_and_write_node::base"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, base) - 0usize];
    ["Offset of field: pm_global_variable_and_write_node::name"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, name) - 24usize];
    ["Offset of field: pm_global_variable_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, name_loc) - 32usize];
    ["Offset of field: pm_global_variable_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, operator_loc) - 48usize];
    ["Offset of field: pm_global_variable_and_write_node::value"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, value) - 64usize];
};
#[doc = " GlobalVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a global variable.\n\n     $target &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_and_write_node_t = pm_global_variable_and_write_node;
#[doc = " GlobalVariableOperatorWriteNode\n\n Represents assigning to a global variable using an operator that isn't `=`.\n\n     $target += value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " GlobalVariableOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " GlobalVariableOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " GlobalVariableOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " GlobalVariableOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_operator_write_node"]
        [::std::mem::size_of::<pm_global_variable_operator_write_node>() - 80usize];
    ["Alignment of pm_global_variable_operator_write_node"]
        [::std::mem::align_of::<pm_global_variable_operator_write_node>() - 8usize];
    ["Offset of field: pm_global_variable_operator_write_node::base"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, base) - 0usize];
    ["Offset of field: pm_global_variable_operator_write_node::name"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, name) - 24usize];
    ["Offset of field: pm_global_variable_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, name_loc) - 32usize];
    ["Offset of field: pm_global_variable_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_global_variable_operator_write_node,
        binary_operator_loc
    ) - 48usize];
    ["Offset of field: pm_global_variable_operator_write_node::value"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, value) - 64usize];
    ["Offset of field: pm_global_variable_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, binary_operator) - 72usize];
};
#[doc = " GlobalVariableOperatorWriteNode\n\n Represents assigning to a global variable using an operator that isn't `=`.\n\n     $target += value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_operator_write_node_t = pm_global_variable_operator_write_node;
#[doc = " GlobalVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a global variable.\n\n     $target ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " GlobalVariableOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " GlobalVariableOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " GlobalVariableOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_or_write_node"]
        [::std::mem::size_of::<pm_global_variable_or_write_node>() - 72usize];
    ["Alignment of pm_global_variable_or_write_node"]
        [::std::mem::align_of::<pm_global_variable_or_write_node>() - 8usize];
    ["Offset of field: pm_global_variable_or_write_node::base"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, base) - 0usize];
    ["Offset of field: pm_global_variable_or_write_node::name"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, name) - 24usize];
    ["Offset of field: pm_global_variable_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, name_loc) - 32usize];
    ["Offset of field: pm_global_variable_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, operator_loc) - 48usize];
    ["Offset of field: pm_global_variable_or_write_node::value"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, value) - 64usize];
};
#[doc = " GlobalVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a global variable.\n\n     $target ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_or_write_node_t = pm_global_variable_or_write_node;
#[doc = " GlobalVariableReadNode\n\n Represents referencing a global variable.\n\n     $foo\n     ^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableReadNode#name\n\n The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.\n\n     $foo   # name `:$foo`\n\n     $_Test # name `:$_Test`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_read_node"]
        [::std::mem::size_of::<pm_global_variable_read_node>() - 32usize];
    ["Alignment of pm_global_variable_read_node"]
        [::std::mem::align_of::<pm_global_variable_read_node>() - 8usize];
    ["Offset of field: pm_global_variable_read_node::base"]
        [::std::mem::offset_of!(pm_global_variable_read_node, base) - 0usize];
    ["Offset of field: pm_global_variable_read_node::name"]
        [::std::mem::offset_of!(pm_global_variable_read_node, name) - 24usize];
};
#[doc = " GlobalVariableReadNode\n\n Represents referencing a global variable.\n\n     $foo\n     ^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_read_node_t = pm_global_variable_read_node;
#[doc = " GlobalVariableTargetNode\n\n Represents writing to a global variable in a context that doesn't have an explicit value.\n\n     $foo, $bar = baz\n     ^^^^  ^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableTargetNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_target_node"]
        [::std::mem::size_of::<pm_global_variable_target_node>() - 32usize];
    ["Alignment of pm_global_variable_target_node"]
        [::std::mem::align_of::<pm_global_variable_target_node>() - 8usize];
    ["Offset of field: pm_global_variable_target_node::base"]
        [::std::mem::offset_of!(pm_global_variable_target_node, base) - 0usize];
    ["Offset of field: pm_global_variable_target_node::name"]
        [::std::mem::offset_of!(pm_global_variable_target_node, name) - 24usize];
};
#[doc = " GlobalVariableTargetNode\n\n Represents writing to a global variable in a context that doesn't have an explicit value.\n\n     $foo, $bar = baz\n     ^^^^  ^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_target_node_t = pm_global_variable_target_node;
#[doc = " GlobalVariableWriteNode\n\n Represents writing to a global variable.\n\n     $foo = 1\n     ^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableWriteNode#name\n\n The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.\n\n     $foo = :bar  # name `:$foo`\n\n     $_Test = 123 # name `:$_Test`"]
    pub name: pm_constant_id_t,
    #[doc = " GlobalVariableWriteNode#name_loc\n\n The location of the global variable's name.\n\n     $foo = :bar\n     ^^^^"]
    pub name_loc: pm_location_t,
    #[doc = " GlobalVariableWriteNode#value\n\n The value to write to the global variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     $foo = :bar\n            ^^^^\n\n     $-xyz = 123\n             ^^^"]
    pub value: *mut pm_node,
    #[doc = " GlobalVariableWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     $foo = :bar\n          ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_write_node"]
        [::std::mem::size_of::<pm_global_variable_write_node>() - 72usize];
    ["Alignment of pm_global_variable_write_node"]
        [::std::mem::align_of::<pm_global_variable_write_node>() - 8usize];
    ["Offset of field: pm_global_variable_write_node::base"]
        [::std::mem::offset_of!(pm_global_variable_write_node, base) - 0usize];
    ["Offset of field: pm_global_variable_write_node::name"]
        [::std::mem::offset_of!(pm_global_variable_write_node, name) - 24usize];
    ["Offset of field: pm_global_variable_write_node::name_loc"]
        [::std::mem::offset_of!(pm_global_variable_write_node, name_loc) - 32usize];
    ["Offset of field: pm_global_variable_write_node::value"]
        [::std::mem::offset_of!(pm_global_variable_write_node, value) - 48usize];
    ["Offset of field: pm_global_variable_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_global_variable_write_node, operator_loc) - 56usize];
};
#[doc = " GlobalVariableWriteNode\n\n Represents writing to a global variable.\n\n     $foo = 1\n     ^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_write_node_t = pm_global_variable_write_node;
#[doc = " HashNode\n\n Represents a hash literal.\n\n     { a => b }\n     ^^^^^^^^^^\n\n Type: ::PM_HASH_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_hash_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " HashNode#opening_loc\n\n The location of the opening brace.\n\n     { a => b }\n     ^"]
    pub opening_loc: pm_location_t,
    #[doc = " HashNode#elements\n\n The elements of the hash. These can be either `AssocNode`s or `AssocSplatNode`s.\n\n     { a: b }\n       ^^^^\n\n     { **foo }\n       ^^^^^"]
    pub elements: pm_node_list,
    #[doc = " HashNode#closing_loc\n\n The location of the closing brace.\n\n     { a => b }\n              ^"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_hash_node"][::std::mem::size_of::<pm_hash_node>() - 80usize];
    ["Alignment of pm_hash_node"][::std::mem::align_of::<pm_hash_node>() - 8usize];
    ["Offset of field: pm_hash_node::base"][::std::mem::offset_of!(pm_hash_node, base) - 0usize];
    ["Offset of field: pm_hash_node::opening_loc"]
        [::std::mem::offset_of!(pm_hash_node, opening_loc) - 24usize];
    ["Offset of field: pm_hash_node::elements"]
        [::std::mem::offset_of!(pm_hash_node, elements) - 40usize];
    ["Offset of field: pm_hash_node::closing_loc"]
        [::std::mem::offset_of!(pm_hash_node, closing_loc) - 64usize];
};
#[doc = " HashNode\n\n Represents a hash literal.\n\n     { a => b }\n     ^^^^^^^^^^\n\n Type: ::PM_HASH_NODE\n\n @extends pm_node_t"]
pub type pm_hash_node_t = pm_hash_node;
#[doc = " HashPatternNode\n\n Represents a hash pattern in pattern matching.\n\n     foo => { a: 1, b: 2 }\n            ^^^^^^^^^^^^^^\n\n     foo => { a: 1, b: 2, **c }\n            ^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_HASH_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_hash_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " HashPatternNode#constant"]
    pub constant: *mut pm_node,
    #[doc = " HashPatternNode#elements"]
    pub elements: pm_node_list,
    #[doc = " HashPatternNode#rest"]
    pub rest: *mut pm_node,
    #[doc = " HashPatternNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " HashPatternNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_hash_pattern_node"][::std::mem::size_of::<pm_hash_pattern_node>() - 96usize];
    ["Alignment of pm_hash_pattern_node"][::std::mem::align_of::<pm_hash_pattern_node>() - 8usize];
    ["Offset of field: pm_hash_pattern_node::base"]
        [::std::mem::offset_of!(pm_hash_pattern_node, base) - 0usize];
    ["Offset of field: pm_hash_pattern_node::constant"]
        [::std::mem::offset_of!(pm_hash_pattern_node, constant) - 24usize];
    ["Offset of field: pm_hash_pattern_node::elements"]
        [::std::mem::offset_of!(pm_hash_pattern_node, elements) - 32usize];
    ["Offset of field: pm_hash_pattern_node::rest"]
        [::std::mem::offset_of!(pm_hash_pattern_node, rest) - 56usize];
    ["Offset of field: pm_hash_pattern_node::opening_loc"]
        [::std::mem::offset_of!(pm_hash_pattern_node, opening_loc) - 64usize];
    ["Offset of field: pm_hash_pattern_node::closing_loc"]
        [::std::mem::offset_of!(pm_hash_pattern_node, closing_loc) - 80usize];
};
#[doc = " HashPatternNode\n\n Represents a hash pattern in pattern matching.\n\n     foo => { a: 1, b: 2 }\n            ^^^^^^^^^^^^^^\n\n     foo => { a: 1, b: 2, **c }\n            ^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_HASH_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_hash_pattern_node_t = pm_hash_pattern_node;
#[doc = " IfNode\n\n Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.\n\n     bar if foo\n     ^^^^^^^^^^\n\n     if foo then bar end\n     ^^^^^^^^^^^^^^^^^^^\n\n     foo ? bar : baz\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_IF_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_if_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IfNode#if_keyword_loc\n\n The location of the `if` keyword if present.\n\n     bar if foo\n         ^^\n\n The `if_keyword_loc` field will be `nil` when the `IfNode` represents a ternary expression."]
    pub if_keyword_loc: pm_location_t,
    #[doc = " IfNode#predicate\n\n The node for the condition the `IfNode` is testing.\n\n     if foo\n        ^^^\n       bar\n     end\n\n     bar if foo\n            ^^^\n\n     foo ? bar : baz\n     ^^^"]
    pub predicate: *mut pm_node,
    #[doc = " IfNode#then_keyword_loc\n\n The location of the `then` keyword (if present) or the `?` in a ternary expression, `nil` otherwise.\n\n     if foo then bar end\n            ^^^^\n\n     a ? b : c\n       ^"]
    pub then_keyword_loc: pm_location_t,
    #[doc = " IfNode#statements\n\n Represents the body of statements that will be executed when the predicate is evaluated as truthy. Will be `nil` when no body is provided.\n\n     if foo\n       bar\n       ^^^\n       baz\n       ^^^\n     end"]
    pub statements: *mut pm_statements_node,
    #[doc = " IfNode#subsequent\n\n Represents an `ElseNode` or an `IfNode` when there is an `else` or an `elsif` in the `if` statement.\n\n     if foo\n       bar\n     elsif baz\n     ^^^^^^^^^\n       qux\n       ^^^\n     end\n     ^^^\n\n     if foo then bar else baz end\n                     ^^^^^^^^^^^^"]
    pub subsequent: *mut pm_node,
    #[doc = " IfNode#end_keyword_loc\n\n The location of the `end` keyword if present, `nil` otherwise.\n\n     if foo\n       bar\n     end\n     ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_if_node"][::std::mem::size_of::<pm_if_node>() - 96usize];
    ["Alignment of pm_if_node"][::std::mem::align_of::<pm_if_node>() - 8usize];
    ["Offset of field: pm_if_node::base"][::std::mem::offset_of!(pm_if_node, base) - 0usize];
    ["Offset of field: pm_if_node::if_keyword_loc"]
        [::std::mem::offset_of!(pm_if_node, if_keyword_loc) - 24usize];
    ["Offset of field: pm_if_node::predicate"]
        [::std::mem::offset_of!(pm_if_node, predicate) - 40usize];
    ["Offset of field: pm_if_node::then_keyword_loc"]
        [::std::mem::offset_of!(pm_if_node, then_keyword_loc) - 48usize];
    ["Offset of field: pm_if_node::statements"]
        [::std::mem::offset_of!(pm_if_node, statements) - 64usize];
    ["Offset of field: pm_if_node::subsequent"]
        [::std::mem::offset_of!(pm_if_node, subsequent) - 72usize];
    ["Offset of field: pm_if_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_if_node, end_keyword_loc) - 80usize];
};
#[doc = " IfNode\n\n Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.\n\n     bar if foo\n     ^^^^^^^^^^\n\n     if foo then bar end\n     ^^^^^^^^^^^^^^^^^^^\n\n     foo ? bar : baz\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_IF_NODE\n\n @extends pm_node_t"]
pub type pm_if_node_t = pm_if_node;
#[doc = " ImaginaryNode\n\n Represents an imaginary number literal.\n\n     1.0i\n     ^^^^\n\n Type: ::PM_IMAGINARY_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_imaginary_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ImaginaryNode#numeric"]
    pub numeric: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_imaginary_node"][::std::mem::size_of::<pm_imaginary_node>() - 32usize];
    ["Alignment of pm_imaginary_node"][::std::mem::align_of::<pm_imaginary_node>() - 8usize];
    ["Offset of field: pm_imaginary_node::base"]
        [::std::mem::offset_of!(pm_imaginary_node, base) - 0usize];
    ["Offset of field: pm_imaginary_node::numeric"]
        [::std::mem::offset_of!(pm_imaginary_node, numeric) - 24usize];
};
#[doc = " ImaginaryNode\n\n Represents an imaginary number literal.\n\n     1.0i\n     ^^^^\n\n Type: ::PM_IMAGINARY_NODE\n\n @extends pm_node_t"]
pub type pm_imaginary_node_t = pm_imaginary_node;
#[doc = " ImplicitNode\n\n Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.\n\n     { foo: }\n       ^^^^\n\n     { Foo: }\n       ^^^^\n\n     foo in { bar: }\n              ^^^^\n\n Type: ::PM_IMPLICIT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_implicit_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ImplicitNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_implicit_node"][::std::mem::size_of::<pm_implicit_node>() - 32usize];
    ["Alignment of pm_implicit_node"][::std::mem::align_of::<pm_implicit_node>() - 8usize];
    ["Offset of field: pm_implicit_node::base"]
        [::std::mem::offset_of!(pm_implicit_node, base) - 0usize];
    ["Offset of field: pm_implicit_node::value"]
        [::std::mem::offset_of!(pm_implicit_node, value) - 24usize];
};
#[doc = " ImplicitNode\n\n Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.\n\n     { foo: }\n       ^^^^\n\n     { Foo: }\n       ^^^^\n\n     foo in { bar: }\n              ^^^^\n\n Type: ::PM_IMPLICIT_NODE\n\n @extends pm_node_t"]
pub type pm_implicit_node_t = pm_implicit_node;
#[doc = " ImplicitRestNode\n\n Represents using a trailing comma to indicate an implicit rest parameter.\n\n     foo { |bar,| }\n               ^\n\n     foo in [bar,]\n                ^\n\n     for foo, in bar do end\n            ^\n\n     foo, = bar\n        ^\n\n Type: ::PM_IMPLICIT_REST_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_implicit_rest_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_implicit_rest_node"][::std::mem::size_of::<pm_implicit_rest_node>() - 24usize];
    ["Alignment of pm_implicit_rest_node"]
        [::std::mem::align_of::<pm_implicit_rest_node>() - 8usize];
    ["Offset of field: pm_implicit_rest_node::base"]
        [::std::mem::offset_of!(pm_implicit_rest_node, base) - 0usize];
};
#[doc = " ImplicitRestNode\n\n Represents using a trailing comma to indicate an implicit rest parameter.\n\n     foo { |bar,| }\n               ^\n\n     foo in [bar,]\n                ^\n\n     for foo, in bar do end\n            ^\n\n     foo, = bar\n        ^\n\n Type: ::PM_IMPLICIT_REST_NODE\n\n @extends pm_node_t"]
pub type pm_implicit_rest_node_t = pm_implicit_rest_node;
#[doc = " InNode\n\n Represents the use of the `in` keyword in a case statement.\n\n     case a; in b then c end\n             ^^^^^^^^^^^\n\n Type: ::PM_IN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_in_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InNode#pattern"]
    pub pattern: *mut pm_node,
    #[doc = " InNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " InNode#in_loc"]
    pub in_loc: pm_location_t,
    #[doc = " InNode#then_loc"]
    pub then_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_in_node"][::std::mem::size_of::<pm_in_node>() - 72usize];
    ["Alignment of pm_in_node"][::std::mem::align_of::<pm_in_node>() - 8usize];
    ["Offset of field: pm_in_node::base"][::std::mem::offset_of!(pm_in_node, base) - 0usize];
    ["Offset of field: pm_in_node::pattern"][::std::mem::offset_of!(pm_in_node, pattern) - 24usize];
    ["Offset of field: pm_in_node::statements"]
        [::std::mem::offset_of!(pm_in_node, statements) - 32usize];
    ["Offset of field: pm_in_node::in_loc"][::std::mem::offset_of!(pm_in_node, in_loc) - 40usize];
    ["Offset of field: pm_in_node::then_loc"]
        [::std::mem::offset_of!(pm_in_node, then_loc) - 56usize];
};
#[doc = " InNode\n\n Represents the use of the `in` keyword in a case statement.\n\n     case a; in b then c end\n             ^^^^^^^^^^^\n\n Type: ::PM_IN_NODE\n\n @extends pm_node_t"]
pub type pm_in_node_t = pm_in_node;
#[doc = " IndexAndWriteNode\n\n Represents the use of the `&&=` operator on a call to the `[]` method.\n\n     foo.bar[baz] &&= value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_AND_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_index_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IndexAndWriteNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " IndexAndWriteNode#call_operator_loc"]
    pub call_operator_loc: pm_location_t,
    #[doc = " IndexAndWriteNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " IndexAndWriteNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " IndexAndWriteNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " IndexAndWriteNode#block"]
    pub block: *mut pm_block_argument_node,
    #[doc = " IndexAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " IndexAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_index_and_write_node"]
        [::std::mem::size_of::<pm_index_and_write_node>() - 120usize];
    ["Alignment of pm_index_and_write_node"]
        [::std::mem::align_of::<pm_index_and_write_node>() - 8usize];
    ["Offset of field: pm_index_and_write_node::base"]
        [::std::mem::offset_of!(pm_index_and_write_node, base) - 0usize];
    ["Offset of field: pm_index_and_write_node::receiver"]
        [::std::mem::offset_of!(pm_index_and_write_node, receiver) - 24usize];
    ["Offset of field: pm_index_and_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_index_and_write_node, call_operator_loc) - 32usize];
    ["Offset of field: pm_index_and_write_node::opening_loc"]
        [::std::mem::offset_of!(pm_index_and_write_node, opening_loc) - 48usize];
    ["Offset of field: pm_index_and_write_node::arguments"]
        [::std::mem::offset_of!(pm_index_and_write_node, arguments) - 64usize];
    ["Offset of field: pm_index_and_write_node::closing_loc"]
        [::std::mem::offset_of!(pm_index_and_write_node, closing_loc) - 72usize];
    ["Offset of field: pm_index_and_write_node::block"]
        [::std::mem::offset_of!(pm_index_and_write_node, block) - 88usize];
    ["Offset of field: pm_index_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_index_and_write_node, operator_loc) - 96usize];
    ["Offset of field: pm_index_and_write_node::value"]
        [::std::mem::offset_of!(pm_index_and_write_node, value) - 112usize];
};
#[doc = " IndexAndWriteNode\n\n Represents the use of the `&&=` operator on a call to the `[]` method.\n\n     foo.bar[baz] &&= value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_AND_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_index_and_write_node_t = pm_index_and_write_node;
#[doc = " IndexOperatorWriteNode\n\n Represents the use of an assignment operator on a call to `[]`.\n\n     foo.bar[baz] += value\n     ^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_OPERATOR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_index_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IndexOperatorWriteNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " IndexOperatorWriteNode#call_operator_loc"]
    pub call_operator_loc: pm_location_t,
    #[doc = " IndexOperatorWriteNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " IndexOperatorWriteNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " IndexOperatorWriteNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " IndexOperatorWriteNode#block"]
    pub block: *mut pm_block_argument_node,
    #[doc = " IndexOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
    #[doc = " IndexOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " IndexOperatorWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_index_operator_write_node"]
        [::std::mem::size_of::<pm_index_operator_write_node>() - 128usize];
    ["Alignment of pm_index_operator_write_node"]
        [::std::mem::align_of::<pm_index_operator_write_node>() - 8usize];
    ["Offset of field: pm_index_operator_write_node::base"]
        [::std::mem::offset_of!(pm_index_operator_write_node, base) - 0usize];
    ["Offset of field: pm_index_operator_write_node::receiver"]
        [::std::mem::offset_of!(pm_index_operator_write_node, receiver) - 24usize];
    ["Offset of field: pm_index_operator_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_index_operator_write_node, call_operator_loc) - 32usize];
    ["Offset of field: pm_index_operator_write_node::opening_loc"]
        [::std::mem::offset_of!(pm_index_operator_write_node, opening_loc) - 48usize];
    ["Offset of field: pm_index_operator_write_node::arguments"]
        [::std::mem::offset_of!(pm_index_operator_write_node, arguments) - 64usize];
    ["Offset of field: pm_index_operator_write_node::closing_loc"]
        [::std::mem::offset_of!(pm_index_operator_write_node, closing_loc) - 72usize];
    ["Offset of field: pm_index_operator_write_node::block"]
        [::std::mem::offset_of!(pm_index_operator_write_node, block) - 88usize];
    ["Offset of field: pm_index_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_index_operator_write_node, binary_operator) - 96usize];
    ["Offset of field: pm_index_operator_write_node::binary_operator_loc"]
        [::std::mem::offset_of!(pm_index_operator_write_node, binary_operator_loc) - 104usize];
    ["Offset of field: pm_index_operator_write_node::value"]
        [::std::mem::offset_of!(pm_index_operator_write_node, value) - 120usize];
};
#[doc = " IndexOperatorWriteNode\n\n Represents the use of an assignment operator on a call to `[]`.\n\n     foo.bar[baz] += value\n     ^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_OPERATOR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_index_operator_write_node_t = pm_index_operator_write_node;
#[doc = " IndexOrWriteNode\n\n Represents the use of the `||=` operator on a call to `[]`.\n\n     foo.bar[baz] ||= value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_OR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_index_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IndexOrWriteNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " IndexOrWriteNode#call_operator_loc"]
    pub call_operator_loc: pm_location_t,
    #[doc = " IndexOrWriteNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " IndexOrWriteNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " IndexOrWriteNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " IndexOrWriteNode#block"]
    pub block: *mut pm_block_argument_node,
    #[doc = " IndexOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " IndexOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_index_or_write_node"][::std::mem::size_of::<pm_index_or_write_node>() - 120usize];
    ["Alignment of pm_index_or_write_node"]
        [::std::mem::align_of::<pm_index_or_write_node>() - 8usize];
    ["Offset of field: pm_index_or_write_node::base"]
        [::std::mem::offset_of!(pm_index_or_write_node, base) - 0usize];
    ["Offset of field: pm_index_or_write_node::receiver"]
        [::std::mem::offset_of!(pm_index_or_write_node, receiver) - 24usize];
    ["Offset of field: pm_index_or_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_index_or_write_node, call_operator_loc) - 32usize];
    ["Offset of field: pm_index_or_write_node::opening_loc"]
        [::std::mem::offset_of!(pm_index_or_write_node, opening_loc) - 48usize];
    ["Offset of field: pm_index_or_write_node::arguments"]
        [::std::mem::offset_of!(pm_index_or_write_node, arguments) - 64usize];
    ["Offset of field: pm_index_or_write_node::closing_loc"]
        [::std::mem::offset_of!(pm_index_or_write_node, closing_loc) - 72usize];
    ["Offset of field: pm_index_or_write_node::block"]
        [::std::mem::offset_of!(pm_index_or_write_node, block) - 88usize];
    ["Offset of field: pm_index_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_index_or_write_node, operator_loc) - 96usize];
    ["Offset of field: pm_index_or_write_node::value"]
        [::std::mem::offset_of!(pm_index_or_write_node, value) - 112usize];
};
#[doc = " IndexOrWriteNode\n\n Represents the use of the `||=` operator on a call to `[]`.\n\n     foo.bar[baz] ||= value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_OR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_index_or_write_node_t = pm_index_or_write_node;
#[doc = " IndexTargetNode\n\n Represents assigning to an index.\n\n     foo[bar], = 1\n     ^^^^^^^^\n\n     begin\n     rescue => foo[bar]\n               ^^^^^^^^\n     end\n\n     for foo[bar] in baz do end\n         ^^^^^^^^\n\n Type: ::PM_INDEX_TARGET_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_index_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IndexTargetNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " IndexTargetNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " IndexTargetNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " IndexTargetNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " IndexTargetNode#block"]
    pub block: *mut pm_block_argument_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_index_target_node"][::std::mem::size_of::<pm_index_target_node>() - 80usize];
    ["Alignment of pm_index_target_node"][::std::mem::align_of::<pm_index_target_node>() - 8usize];
    ["Offset of field: pm_index_target_node::base"]
        [::std::mem::offset_of!(pm_index_target_node, base) - 0usize];
    ["Offset of field: pm_index_target_node::receiver"]
        [::std::mem::offset_of!(pm_index_target_node, receiver) - 24usize];
    ["Offset of field: pm_index_target_node::opening_loc"]
        [::std::mem::offset_of!(pm_index_target_node, opening_loc) - 32usize];
    ["Offset of field: pm_index_target_node::arguments"]
        [::std::mem::offset_of!(pm_index_target_node, arguments) - 48usize];
    ["Offset of field: pm_index_target_node::closing_loc"]
        [::std::mem::offset_of!(pm_index_target_node, closing_loc) - 56usize];
    ["Offset of field: pm_index_target_node::block"]
        [::std::mem::offset_of!(pm_index_target_node, block) - 72usize];
};
#[doc = " IndexTargetNode\n\n Represents assigning to an index.\n\n     foo[bar], = 1\n     ^^^^^^^^\n\n     begin\n     rescue => foo[bar]\n               ^^^^^^^^\n     end\n\n     for foo[bar] in baz do end\n         ^^^^^^^^\n\n Type: ::PM_INDEX_TARGET_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_index_target_node_t = pm_index_target_node;
#[doc = " InstanceVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to an instance variable.\n\n     @target &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableAndWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " InstanceVariableAndWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " InstanceVariableAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " InstanceVariableAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_and_write_node"]
        [::std::mem::size_of::<pm_instance_variable_and_write_node>() - 72usize];
    ["Alignment of pm_instance_variable_and_write_node"]
        [::std::mem::align_of::<pm_instance_variable_and_write_node>() - 8usize];
    ["Offset of field: pm_instance_variable_and_write_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_and_write_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, name) - 24usize];
    ["Offset of field: pm_instance_variable_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, name_loc) - 32usize];
    ["Offset of field: pm_instance_variable_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, operator_loc) - 48usize];
    ["Offset of field: pm_instance_variable_and_write_node::value"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, value) - 64usize];
};
#[doc = " InstanceVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to an instance variable.\n\n     @target &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_and_write_node_t = pm_instance_variable_and_write_node;
#[doc = " InstanceVariableOperatorWriteNode\n\n Represents assigning to an instance variable using an operator that isn't `=`.\n\n     @target += value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " InstanceVariableOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " InstanceVariableOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " InstanceVariableOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " InstanceVariableOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_operator_write_node"]
        [::std::mem::size_of::<pm_instance_variable_operator_write_node>() - 80usize];
    ["Alignment of pm_instance_variable_operator_write_node"]
        [::std::mem::align_of::<pm_instance_variable_operator_write_node>() - 8usize];
    ["Offset of field: pm_instance_variable_operator_write_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_operator_write_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_operator_write_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_operator_write_node, name) - 24usize];
    ["Offset of field: pm_instance_variable_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_instance_variable_operator_write_node, name_loc) - 32usize];
    ["Offset of field: pm_instance_variable_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_instance_variable_operator_write_node,
        binary_operator_loc
    ) - 48usize];
    ["Offset of field: pm_instance_variable_operator_write_node::value"]
        [::std::mem::offset_of!(pm_instance_variable_operator_write_node, value) - 64usize];
    ["Offset of field: pm_instance_variable_operator_write_node::binary_operator"][::std::mem::offset_of!(
        pm_instance_variable_operator_write_node,
        binary_operator
    ) - 72usize];
};
#[doc = " InstanceVariableOperatorWriteNode\n\n Represents assigning to an instance variable using an operator that isn't `=`.\n\n     @target += value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_operator_write_node_t = pm_instance_variable_operator_write_node;
#[doc = " InstanceVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to an instance variable.\n\n     @target ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " InstanceVariableOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " InstanceVariableOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " InstanceVariableOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_or_write_node"]
        [::std::mem::size_of::<pm_instance_variable_or_write_node>() - 72usize];
    ["Alignment of pm_instance_variable_or_write_node"]
        [::std::mem::align_of::<pm_instance_variable_or_write_node>() - 8usize];
    ["Offset of field: pm_instance_variable_or_write_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_or_write_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, name) - 24usize];
    ["Offset of field: pm_instance_variable_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, name_loc) - 32usize];
    ["Offset of field: pm_instance_variable_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, operator_loc) - 48usize];
    ["Offset of field: pm_instance_variable_or_write_node::value"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, value) - 64usize];
};
#[doc = " InstanceVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to an instance variable.\n\n     @target ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_or_write_node_t = pm_instance_variable_or_write_node;
#[doc = " InstanceVariableReadNode\n\n Represents referencing an instance variable.\n\n     @foo\n     ^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableReadNode#name\n\n The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @x     # name `:@x`\n\n     @_test # name `:@_test`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_read_node"]
        [::std::mem::size_of::<pm_instance_variable_read_node>() - 32usize];
    ["Alignment of pm_instance_variable_read_node"]
        [::std::mem::align_of::<pm_instance_variable_read_node>() - 8usize];
    ["Offset of field: pm_instance_variable_read_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_read_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_read_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_read_node, name) - 24usize];
};
#[doc = " InstanceVariableReadNode\n\n Represents referencing an instance variable.\n\n     @foo\n     ^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_read_node_t = pm_instance_variable_read_node;
#[doc = " InstanceVariableTargetNode\n\n Represents writing to an instance variable in a context that doesn't have an explicit value.\n\n     @foo, @bar = baz\n     ^^^^  ^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableTargetNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_target_node"]
        [::std::mem::size_of::<pm_instance_variable_target_node>() - 32usize];
    ["Alignment of pm_instance_variable_target_node"]
        [::std::mem::align_of::<pm_instance_variable_target_node>() - 8usize];
    ["Offset of field: pm_instance_variable_target_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_target_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_target_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_target_node, name) - 24usize];
};
#[doc = " InstanceVariableTargetNode\n\n Represents writing to an instance variable in a context that doesn't have an explicit value.\n\n     @foo, @bar = baz\n     ^^^^  ^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_target_node_t = pm_instance_variable_target_node;
#[doc = " InstanceVariableWriteNode\n\n Represents writing to an instance variable.\n\n     @foo = 1\n     ^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableWriteNode#name\n\n The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @x = :y       # name `:@x`\n\n     @_foo = \"bar\" # name `@_foo`"]
    pub name: pm_constant_id_t,
    #[doc = " InstanceVariableWriteNode#name_loc\n\n The location of the variable name.\n\n     @_x = 1\n     ^^^"]
    pub name_loc: pm_location_t,
    #[doc = " InstanceVariableWriteNode#value\n\n The value to write to the instance variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     @foo = :bar\n            ^^^^\n\n     @_x = 1234\n           ^^^^"]
    pub value: *mut pm_node,
    #[doc = " InstanceVariableWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     @x = y\n        ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_write_node"]
        [::std::mem::size_of::<pm_instance_variable_write_node>() - 72usize];
    ["Alignment of pm_instance_variable_write_node"]
        [::std::mem::align_of::<pm_instance_variable_write_node>() - 8usize];
    ["Offset of field: pm_instance_variable_write_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_write_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, name) - 24usize];
    ["Offset of field: pm_instance_variable_write_node::name_loc"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, name_loc) - 32usize];
    ["Offset of field: pm_instance_variable_write_node::value"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, value) - 48usize];
    ["Offset of field: pm_instance_variable_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, operator_loc) - 56usize];
};
#[doc = " InstanceVariableWriteNode\n\n Represents writing to an instance variable.\n\n     @foo = 1\n     ^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_write_node_t = pm_instance_variable_write_node;
#[doc = " IntegerNode\n\n Represents an integer number literal.\n\n     1\n     ^\n\n Type: ::PM_INTEGER_NODE\n\n Flags (#pm_integer_base_flags):\n * ::PM_INTEGER_BASE_FLAGS_BINARY\n * ::PM_INTEGER_BASE_FLAGS_DECIMAL\n * ::PM_INTEGER_BASE_FLAGS_OCTAL\n * ::PM_INTEGER_BASE_FLAGS_HEXADECIMAL\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_integer_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IntegerNode#value\n\n The value of the integer literal as a number."]
    pub value: pm_integer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_integer_node"][::std::mem::size_of::<pm_integer_node>() - 48usize];
    ["Alignment of pm_integer_node"][::std::mem::align_of::<pm_integer_node>() - 8usize];
    ["Offset of field: pm_integer_node::base"]
        [::std::mem::offset_of!(pm_integer_node, base) - 0usize];
    ["Offset of field: pm_integer_node::value"]
        [::std::mem::offset_of!(pm_integer_node, value) - 24usize];
};
#[doc = " IntegerNode\n\n Represents an integer number literal.\n\n     1\n     ^\n\n Type: ::PM_INTEGER_NODE\n\n Flags (#pm_integer_base_flags):\n * ::PM_INTEGER_BASE_FLAGS_BINARY\n * ::PM_INTEGER_BASE_FLAGS_DECIMAL\n * ::PM_INTEGER_BASE_FLAGS_OCTAL\n * ::PM_INTEGER_BASE_FLAGS_HEXADECIMAL\n\n @extends pm_node_t"]
pub type pm_integer_node_t = pm_integer_node;
#[doc = " InterpolatedMatchLastLineNode\n\n Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.\n\n     if /foo #{bar} baz/ then end\n        ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_MATCH_LAST_LINE_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_match_last_line_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedMatchLastLineNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedMatchLastLineNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedMatchLastLineNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_match_last_line_node"]
        [::std::mem::size_of::<pm_interpolated_match_last_line_node>() - 80usize];
    ["Alignment of pm_interpolated_match_last_line_node"]
        [::std::mem::align_of::<pm_interpolated_match_last_line_node>() - 8usize];
    ["Offset of field: pm_interpolated_match_last_line_node::base"]
        [::std::mem::offset_of!(pm_interpolated_match_last_line_node, base) - 0usize];
    ["Offset of field: pm_interpolated_match_last_line_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_match_last_line_node, opening_loc) - 24usize];
    ["Offset of field: pm_interpolated_match_last_line_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_match_last_line_node, parts) - 40usize];
    ["Offset of field: pm_interpolated_match_last_line_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_match_last_line_node, closing_loc) - 64usize];
};
#[doc = " InterpolatedMatchLastLineNode\n\n Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.\n\n     if /foo #{bar} baz/ then end\n        ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_MATCH_LAST_LINE_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_interpolated_match_last_line_node_t = pm_interpolated_match_last_line_node;
#[doc = " InterpolatedRegularExpressionNode\n\n Represents a regular expression literal that contains interpolation.\n\n     /foo #{bar} baz/\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_REGULAR_EXPRESSION_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_regular_expression_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedRegularExpressionNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedRegularExpressionNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedRegularExpressionNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_regular_expression_node"]
        [::std::mem::size_of::<pm_interpolated_regular_expression_node>() - 80usize];
    ["Alignment of pm_interpolated_regular_expression_node"]
        [::std::mem::align_of::<pm_interpolated_regular_expression_node>() - 8usize];
    ["Offset of field: pm_interpolated_regular_expression_node::base"]
        [::std::mem::offset_of!(pm_interpolated_regular_expression_node, base) - 0usize];
    ["Offset of field: pm_interpolated_regular_expression_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_regular_expression_node, opening_loc) - 24usize];
    ["Offset of field: pm_interpolated_regular_expression_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_regular_expression_node, parts) - 40usize];
    ["Offset of field: pm_interpolated_regular_expression_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_regular_expression_node, closing_loc) - 64usize];
};
#[doc = " InterpolatedRegularExpressionNode\n\n Represents a regular expression literal that contains interpolation.\n\n     /foo #{bar} baz/\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_REGULAR_EXPRESSION_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_interpolated_regular_expression_node_t = pm_interpolated_regular_expression_node;
#[doc = " InterpolatedStringNode\n\n Represents a string literal that contains interpolation.\n\n     \"foo #{bar} baz\"\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_STRING_NODE\n\n Flags (#pm_interpolated_string_node_flags):\n * ::PM_INTERPOLATED_STRING_NODE_FLAGS_FROZEN\n * ::PM_INTERPOLATED_STRING_NODE_FLAGS_MUTABLE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_string_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedStringNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedStringNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedStringNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_string_node"]
        [::std::mem::size_of::<pm_interpolated_string_node>() - 80usize];
    ["Alignment of pm_interpolated_string_node"]
        [::std::mem::align_of::<pm_interpolated_string_node>() - 8usize];
    ["Offset of field: pm_interpolated_string_node::base"]
        [::std::mem::offset_of!(pm_interpolated_string_node, base) - 0usize];
    ["Offset of field: pm_interpolated_string_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_string_node, opening_loc) - 24usize];
    ["Offset of field: pm_interpolated_string_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_string_node, parts) - 40usize];
    ["Offset of field: pm_interpolated_string_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_string_node, closing_loc) - 64usize];
};
#[doc = " InterpolatedStringNode\n\n Represents a string literal that contains interpolation.\n\n     \"foo #{bar} baz\"\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_STRING_NODE\n\n Flags (#pm_interpolated_string_node_flags):\n * ::PM_INTERPOLATED_STRING_NODE_FLAGS_FROZEN\n * ::PM_INTERPOLATED_STRING_NODE_FLAGS_MUTABLE\n\n @extends pm_node_t"]
pub type pm_interpolated_string_node_t = pm_interpolated_string_node;
#[doc = " InterpolatedSymbolNode\n\n Represents a symbol literal that contains interpolation.\n\n     :\"foo #{bar} baz\"\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_SYMBOL_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_symbol_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedSymbolNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedSymbolNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedSymbolNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_symbol_node"]
        [::std::mem::size_of::<pm_interpolated_symbol_node>() - 80usize];
    ["Alignment of pm_interpolated_symbol_node"]
        [::std::mem::align_of::<pm_interpolated_symbol_node>() - 8usize];
    ["Offset of field: pm_interpolated_symbol_node::base"]
        [::std::mem::offset_of!(pm_interpolated_symbol_node, base) - 0usize];
    ["Offset of field: pm_interpolated_symbol_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_symbol_node, opening_loc) - 24usize];
    ["Offset of field: pm_interpolated_symbol_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_symbol_node, parts) - 40usize];
    ["Offset of field: pm_interpolated_symbol_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_symbol_node, closing_loc) - 64usize];
};
#[doc = " InterpolatedSymbolNode\n\n Represents a symbol literal that contains interpolation.\n\n     :\"foo #{bar} baz\"\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_SYMBOL_NODE\n\n @extends pm_node_t"]
pub type pm_interpolated_symbol_node_t = pm_interpolated_symbol_node;
#[doc = " InterpolatedXStringNode\n\n Represents an xstring literal that contains interpolation.\n\n     `foo #{bar} baz`\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_X_STRING_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_x_string_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedXStringNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedXStringNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedXStringNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_x_string_node"]
        [::std::mem::size_of::<pm_interpolated_x_string_node>() - 80usize];
    ["Alignment of pm_interpolated_x_string_node"]
        [::std::mem::align_of::<pm_interpolated_x_string_node>() - 8usize];
    ["Offset of field: pm_interpolated_x_string_node::base"]
        [::std::mem::offset_of!(pm_interpolated_x_string_node, base) - 0usize];
    ["Offset of field: pm_interpolated_x_string_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_x_string_node, opening_loc) - 24usize];
    ["Offset of field: pm_interpolated_x_string_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_x_string_node, parts) - 40usize];
    ["Offset of field: pm_interpolated_x_string_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_x_string_node, closing_loc) - 64usize];
};
#[doc = " InterpolatedXStringNode\n\n Represents an xstring literal that contains interpolation.\n\n     `foo #{bar} baz`\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_X_STRING_NODE\n\n @extends pm_node_t"]
pub type pm_interpolated_x_string_node_t = pm_interpolated_x_string_node;
#[doc = " ItLocalVariableReadNode\n\n Represents reading from the implicit `it` local variable.\n\n     -> { it }\n          ^^\n\n Type: ::PM_IT_LOCAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_it_local_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_it_local_variable_read_node"]
        [::std::mem::size_of::<pm_it_local_variable_read_node>() - 24usize];
    ["Alignment of pm_it_local_variable_read_node"]
        [::std::mem::align_of::<pm_it_local_variable_read_node>() - 8usize];
    ["Offset of field: pm_it_local_variable_read_node::base"]
        [::std::mem::offset_of!(pm_it_local_variable_read_node, base) - 0usize];
};
#[doc = " ItLocalVariableReadNode\n\n Represents reading from the implicit `it` local variable.\n\n     -> { it }\n          ^^\n\n Type: ::PM_IT_LOCAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_it_local_variable_read_node_t = pm_it_local_variable_read_node;
#[doc = " ItParametersNode\n\n Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.\n\n     -> { it + it }\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_IT_PARAMETERS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_it_parameters_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_it_parameters_node"][::std::mem::size_of::<pm_it_parameters_node>() - 24usize];
    ["Alignment of pm_it_parameters_node"]
        [::std::mem::align_of::<pm_it_parameters_node>() - 8usize];
    ["Offset of field: pm_it_parameters_node::base"]
        [::std::mem::offset_of!(pm_it_parameters_node, base) - 0usize];
};
#[doc = " ItParametersNode\n\n Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.\n\n     -> { it + it }\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_IT_PARAMETERS_NODE\n\n @extends pm_node_t"]
pub type pm_it_parameters_node_t = pm_it_parameters_node;
#[doc = " KeywordHashNode\n\n Represents a hash literal without opening and closing braces.\n\n     foo(a: b)\n         ^^^^\n\n Type: ::PM_KEYWORD_HASH_NODE\n\n Flags (#pm_keyword_hash_node_flags):\n * ::PM_KEYWORD_HASH_NODE_FLAGS_SYMBOL_KEYS\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_keyword_hash_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " KeywordHashNode#elements"]
    pub elements: pm_node_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_keyword_hash_node"][::std::mem::size_of::<pm_keyword_hash_node>() - 48usize];
    ["Alignment of pm_keyword_hash_node"][::std::mem::align_of::<pm_keyword_hash_node>() - 8usize];
    ["Offset of field: pm_keyword_hash_node::base"]
        [::std::mem::offset_of!(pm_keyword_hash_node, base) - 0usize];
    ["Offset of field: pm_keyword_hash_node::elements"]
        [::std::mem::offset_of!(pm_keyword_hash_node, elements) - 24usize];
};
#[doc = " KeywordHashNode\n\n Represents a hash literal without opening and closing braces.\n\n     foo(a: b)\n         ^^^^\n\n Type: ::PM_KEYWORD_HASH_NODE\n\n Flags (#pm_keyword_hash_node_flags):\n * ::PM_KEYWORD_HASH_NODE_FLAGS_SYMBOL_KEYS\n\n @extends pm_node_t"]
pub type pm_keyword_hash_node_t = pm_keyword_hash_node;
#[doc = " KeywordRestParameterNode\n\n Represents a keyword rest parameter to a method, block, or lambda definition.\n\n     def a(**b)\n           ^^^\n     end\n\n Type: ::PM_KEYWORD_REST_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_keyword_rest_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " KeywordRestParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " KeywordRestParameterNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " KeywordRestParameterNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_keyword_rest_parameter_node"]
        [::std::mem::size_of::<pm_keyword_rest_parameter_node>() - 64usize];
    ["Alignment of pm_keyword_rest_parameter_node"]
        [::std::mem::align_of::<pm_keyword_rest_parameter_node>() - 8usize];
    ["Offset of field: pm_keyword_rest_parameter_node::base"]
        [::std::mem::offset_of!(pm_keyword_rest_parameter_node, base) - 0usize];
    ["Offset of field: pm_keyword_rest_parameter_node::name"]
        [::std::mem::offset_of!(pm_keyword_rest_parameter_node, name) - 24usize];
    ["Offset of field: pm_keyword_rest_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_keyword_rest_parameter_node, name_loc) - 32usize];
    ["Offset of field: pm_keyword_rest_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_keyword_rest_parameter_node, operator_loc) - 48usize];
};
#[doc = " KeywordRestParameterNode\n\n Represents a keyword rest parameter to a method, block, or lambda definition.\n\n     def a(**b)\n           ^^^\n     end\n\n Type: ::PM_KEYWORD_REST_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_keyword_rest_parameter_node_t = pm_keyword_rest_parameter_node;
#[doc = " LambdaNode\n\n Represents using a lambda literal (not the lambda method call).\n\n     ->(value) { value * 2 }\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_LAMBDA_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lambda_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LambdaNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " LambdaNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " LambdaNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " LambdaNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " LambdaNode#parameters"]
    pub parameters: *mut pm_node,
    #[doc = " LambdaNode#body"]
    pub body: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lambda_node"][::std::mem::size_of::<pm_lambda_node>() - 112usize];
    ["Alignment of pm_lambda_node"][::std::mem::align_of::<pm_lambda_node>() - 8usize];
    ["Offset of field: pm_lambda_node::base"]
        [::std::mem::offset_of!(pm_lambda_node, base) - 0usize];
    ["Offset of field: pm_lambda_node::locals"]
        [::std::mem::offset_of!(pm_lambda_node, locals) - 24usize];
    ["Offset of field: pm_lambda_node::operator_loc"]
        [::std::mem::offset_of!(pm_lambda_node, operator_loc) - 48usize];
    ["Offset of field: pm_lambda_node::opening_loc"]
        [::std::mem::offset_of!(pm_lambda_node, opening_loc) - 64usize];
    ["Offset of field: pm_lambda_node::closing_loc"]
        [::std::mem::offset_of!(pm_lambda_node, closing_loc) - 80usize];
    ["Offset of field: pm_lambda_node::parameters"]
        [::std::mem::offset_of!(pm_lambda_node, parameters) - 96usize];
    ["Offset of field: pm_lambda_node::body"]
        [::std::mem::offset_of!(pm_lambda_node, body) - 104usize];
};
#[doc = " LambdaNode\n\n Represents using a lambda literal (not the lambda method call).\n\n     ->(value) { value * 2 }\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_LAMBDA_NODE\n\n @extends pm_node_t"]
pub type pm_lambda_node_t = pm_lambda_node;
#[doc = " LocalVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a local variable.\n\n     target &&= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableAndWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " LocalVariableAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " LocalVariableAndWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " LocalVariableAndWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableAndWriteNode#depth"]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_and_write_node"]
        [::std::mem::size_of::<pm_local_variable_and_write_node>() - 72usize];
    ["Alignment of pm_local_variable_and_write_node"]
        [::std::mem::align_of::<pm_local_variable_and_write_node>() - 8usize];
    ["Offset of field: pm_local_variable_and_write_node::base"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, base) - 0usize];
    ["Offset of field: pm_local_variable_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, name_loc) - 24usize];
    ["Offset of field: pm_local_variable_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, operator_loc) - 40usize];
    ["Offset of field: pm_local_variable_and_write_node::value"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, value) - 56usize];
    ["Offset of field: pm_local_variable_and_write_node::name"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, name) - 64usize];
    ["Offset of field: pm_local_variable_and_write_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, depth) - 68usize];
};
#[doc = " LocalVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a local variable.\n\n     target &&= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_and_write_node_t = pm_local_variable_and_write_node;
#[doc = " LocalVariableOperatorWriteNode\n\n Represents assigning to a local variable using an operator that isn't `=`.\n\n     target += value\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " LocalVariableOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " LocalVariableOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " LocalVariableOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
    #[doc = " LocalVariableOperatorWriteNode#depth"]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_operator_write_node"]
        [::std::mem::size_of::<pm_local_variable_operator_write_node>() - 80usize];
    ["Alignment of pm_local_variable_operator_write_node"]
        [::std::mem::align_of::<pm_local_variable_operator_write_node>() - 8usize];
    ["Offset of field: pm_local_variable_operator_write_node::base"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, base) - 0usize];
    ["Offset of field: pm_local_variable_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, name_loc) - 24usize];
    ["Offset of field: pm_local_variable_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_local_variable_operator_write_node,
        binary_operator_loc
    ) - 40usize];
    ["Offset of field: pm_local_variable_operator_write_node::value"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, value) - 56usize];
    ["Offset of field: pm_local_variable_operator_write_node::name"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, name) - 64usize];
    ["Offset of field: pm_local_variable_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, binary_operator) - 68usize];
    ["Offset of field: pm_local_variable_operator_write_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, depth) - 72usize];
};
#[doc = " LocalVariableOperatorWriteNode\n\n Represents assigning to a local variable using an operator that isn't `=`.\n\n     target += value\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_operator_write_node_t = pm_local_variable_operator_write_node;
#[doc = " LocalVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a local variable.\n\n     target ||= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " LocalVariableOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " LocalVariableOrWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " LocalVariableOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableOrWriteNode#depth"]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_or_write_node"]
        [::std::mem::size_of::<pm_local_variable_or_write_node>() - 72usize];
    ["Alignment of pm_local_variable_or_write_node"]
        [::std::mem::align_of::<pm_local_variable_or_write_node>() - 8usize];
    ["Offset of field: pm_local_variable_or_write_node::base"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, base) - 0usize];
    ["Offset of field: pm_local_variable_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, name_loc) - 24usize];
    ["Offset of field: pm_local_variable_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, operator_loc) - 40usize];
    ["Offset of field: pm_local_variable_or_write_node::value"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, value) - 56usize];
    ["Offset of field: pm_local_variable_or_write_node::name"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, name) - 64usize];
    ["Offset of field: pm_local_variable_or_write_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, depth) - 68usize];
};
#[doc = " LocalVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a local variable.\n\n     target ||= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_or_write_node_t = pm_local_variable_or_write_node;
#[doc = " LocalVariableReadNode\n\n Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.\n\n     foo\n     ^^^\n\n Type: ::PM_LOCAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableReadNode#name\n\n The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     x      # name `:x`\n\n     _Test  # name `:_Test`\n\n Note that this can also be an underscore followed by a number for the default block parameters.\n\n     _1     # name `:_1`"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableReadNode#depth\n\n The number of visible scopes that should be searched to find the origin of this local variable.\n\n     foo = 1; foo # depth 0\n\n     bar = 2; tap { bar } # depth 1\n\n The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md)."]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_read_node"]
        [::std::mem::size_of::<pm_local_variable_read_node>() - 32usize];
    ["Alignment of pm_local_variable_read_node"]
        [::std::mem::align_of::<pm_local_variable_read_node>() - 8usize];
    ["Offset of field: pm_local_variable_read_node::base"]
        [::std::mem::offset_of!(pm_local_variable_read_node, base) - 0usize];
    ["Offset of field: pm_local_variable_read_node::name"]
        [::std::mem::offset_of!(pm_local_variable_read_node, name) - 24usize];
    ["Offset of field: pm_local_variable_read_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_read_node, depth) - 28usize];
};
#[doc = " LocalVariableReadNode\n\n Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.\n\n     foo\n     ^^^\n\n Type: ::PM_LOCAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_read_node_t = pm_local_variable_read_node;
#[doc = " LocalVariableTargetNode\n\n Represents writing to a local variable in a context that doesn't have an explicit value.\n\n     foo, bar = baz\n     ^^^  ^^^\n\n Type: ::PM_LOCAL_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableTargetNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableTargetNode#depth"]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_target_node"]
        [::std::mem::size_of::<pm_local_variable_target_node>() - 32usize];
    ["Alignment of pm_local_variable_target_node"]
        [::std::mem::align_of::<pm_local_variable_target_node>() - 8usize];
    ["Offset of field: pm_local_variable_target_node::base"]
        [::std::mem::offset_of!(pm_local_variable_target_node, base) - 0usize];
    ["Offset of field: pm_local_variable_target_node::name"]
        [::std::mem::offset_of!(pm_local_variable_target_node, name) - 24usize];
    ["Offset of field: pm_local_variable_target_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_target_node, depth) - 28usize];
};
#[doc = " LocalVariableTargetNode\n\n Represents writing to a local variable in a context that doesn't have an explicit value.\n\n     foo, bar = baz\n     ^^^  ^^^\n\n Type: ::PM_LOCAL_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_target_node_t = pm_local_variable_target_node;
#[doc = " LocalVariableWriteNode\n\n Represents writing to a local variable.\n\n     foo = 1\n     ^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableWriteNode#name\n\n The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     foo = :bar # name `:foo`\n\n     abc = 123  # name `:abc`"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableWriteNode#depth\n\n The number of semantic scopes we have to traverse to find the declaration of this variable.\n\n     foo = 1         # depth 0\n\n     tap { foo = 1 } # depth 1\n\n The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md)."]
    pub depth: u32,
    #[doc = " LocalVariableWriteNode#name_loc\n\n The location of the variable name.\n\n     foo = :bar\n     ^^^"]
    pub name_loc: pm_location_t,
    #[doc = " LocalVariableWriteNode#value\n\n The value to write to the local variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo = :bar\n           ^^^^\n\n     abc = 1234\n           ^^^^\n\n Note that since the name of a local variable is known before the value is parsed, it is valid for a local variable to appear within the value of its own write.\n\n     foo = foo"]
    pub value: *mut pm_node,
    #[doc = " LocalVariableWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     x = :y\n       ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_write_node"]
        [::std::mem::size_of::<pm_local_variable_write_node>() - 72usize];
    ["Alignment of pm_local_variable_write_node"]
        [::std::mem::align_of::<pm_local_variable_write_node>() - 8usize];
    ["Offset of field: pm_local_variable_write_node::base"]
        [::std::mem::offset_of!(pm_local_variable_write_node, base) - 0usize];
    ["Offset of field: pm_local_variable_write_node::name"]
        [::std::mem::offset_of!(pm_local_variable_write_node, name) - 24usize];
    ["Offset of field: pm_local_variable_write_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_write_node, depth) - 28usize];
    ["Offset of field: pm_local_variable_write_node::name_loc"]
        [::std::mem::offset_of!(pm_local_variable_write_node, name_loc) - 32usize];
    ["Offset of field: pm_local_variable_write_node::value"]
        [::std::mem::offset_of!(pm_local_variable_write_node, value) - 48usize];
    ["Offset of field: pm_local_variable_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_local_variable_write_node, operator_loc) - 56usize];
};
#[doc = " LocalVariableWriteNode\n\n Represents writing to a local variable.\n\n     foo = 1\n     ^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_write_node_t = pm_local_variable_write_node;
#[doc = " MatchLastLineNode\n\n Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.\n\n     if /foo/i then end\n        ^^^^^^\n\n Type: ::PM_MATCH_LAST_LINE_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_match_last_line_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MatchLastLineNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " MatchLastLineNode#content_loc"]
    pub content_loc: pm_location_t,
    #[doc = " MatchLastLineNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " MatchLastLineNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_match_last_line_node"][::std::mem::size_of::<pm_match_last_line_node>() - 96usize];
    ["Alignment of pm_match_last_line_node"]
        [::std::mem::align_of::<pm_match_last_line_node>() - 8usize];
    ["Offset of field: pm_match_last_line_node::base"]
        [::std::mem::offset_of!(pm_match_last_line_node, base) - 0usize];
    ["Offset of field: pm_match_last_line_node::opening_loc"]
        [::std::mem::offset_of!(pm_match_last_line_node, opening_loc) - 24usize];
    ["Offset of field: pm_match_last_line_node::content_loc"]
        [::std::mem::offset_of!(pm_match_last_line_node, content_loc) - 40usize];
    ["Offset of field: pm_match_last_line_node::closing_loc"]
        [::std::mem::offset_of!(pm_match_last_line_node, closing_loc) - 56usize];
    ["Offset of field: pm_match_last_line_node::unescaped"]
        [::std::mem::offset_of!(pm_match_last_line_node, unescaped) - 72usize];
};
#[doc = " MatchLastLineNode\n\n Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.\n\n     if /foo/i then end\n        ^^^^^^\n\n Type: ::PM_MATCH_LAST_LINE_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_match_last_line_node_t = pm_match_last_line_node;
#[doc = " MatchPredicateNode\n\n Represents the use of the modifier `in` operator.\n\n     foo in bar\n     ^^^^^^^^^^\n\n Type: ::PM_MATCH_PREDICATE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_match_predicate_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MatchPredicateNode#value"]
    pub value: *mut pm_node,
    #[doc = " MatchPredicateNode#pattern"]
    pub pattern: *mut pm_node,
    #[doc = " MatchPredicateNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_match_predicate_node"][::std::mem::size_of::<pm_match_predicate_node>() - 56usize];
    ["Alignment of pm_match_predicate_node"]
        [::std::mem::align_of::<pm_match_predicate_node>() - 8usize];
    ["Offset of field: pm_match_predicate_node::base"]
        [::std::mem::offset_of!(pm_match_predicate_node, base) - 0usize];
    ["Offset of field: pm_match_predicate_node::value"]
        [::std::mem::offset_of!(pm_match_predicate_node, value) - 24usize];
    ["Offset of field: pm_match_predicate_node::pattern"]
        [::std::mem::offset_of!(pm_match_predicate_node, pattern) - 32usize];
    ["Offset of field: pm_match_predicate_node::operator_loc"]
        [::std::mem::offset_of!(pm_match_predicate_node, operator_loc) - 40usize];
};
#[doc = " MatchPredicateNode\n\n Represents the use of the modifier `in` operator.\n\n     foo in bar\n     ^^^^^^^^^^\n\n Type: ::PM_MATCH_PREDICATE_NODE\n\n @extends pm_node_t"]
pub type pm_match_predicate_node_t = pm_match_predicate_node;
#[doc = " MatchRequiredNode\n\n Represents the use of the `=>` operator.\n\n     foo => bar\n     ^^^^^^^^^^\n\n Type: ::PM_MATCH_REQUIRED_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_match_required_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MatchRequiredNode#value"]
    pub value: *mut pm_node,
    #[doc = " MatchRequiredNode#pattern"]
    pub pattern: *mut pm_node,
    #[doc = " MatchRequiredNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_match_required_node"][::std::mem::size_of::<pm_match_required_node>() - 56usize];
    ["Alignment of pm_match_required_node"]
        [::std::mem::align_of::<pm_match_required_node>() - 8usize];
    ["Offset of field: pm_match_required_node::base"]
        [::std::mem::offset_of!(pm_match_required_node, base) - 0usize];
    ["Offset of field: pm_match_required_node::value"]
        [::std::mem::offset_of!(pm_match_required_node, value) - 24usize];
    ["Offset of field: pm_match_required_node::pattern"]
        [::std::mem::offset_of!(pm_match_required_node, pattern) - 32usize];
    ["Offset of field: pm_match_required_node::operator_loc"]
        [::std::mem::offset_of!(pm_match_required_node, operator_loc) - 40usize];
};
#[doc = " MatchRequiredNode\n\n Represents the use of the `=>` operator.\n\n     foo => bar\n     ^^^^^^^^^^\n\n Type: ::PM_MATCH_REQUIRED_NODE\n\n @extends pm_node_t"]
pub type pm_match_required_node_t = pm_match_required_node;
#[doc = " MatchWriteNode\n\n Represents writing local variables using a regular expression match with named capture groups.\n\n     /(?<foo>bar)/ =~ baz\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_MATCH_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_match_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MatchWriteNode#call"]
    pub call: *mut pm_call_node,
    #[doc = " MatchWriteNode#targets"]
    pub targets: pm_node_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_match_write_node"][::std::mem::size_of::<pm_match_write_node>() - 56usize];
    ["Alignment of pm_match_write_node"][::std::mem::align_of::<pm_match_write_node>() - 8usize];
    ["Offset of field: pm_match_write_node::base"]
        [::std::mem::offset_of!(pm_match_write_node, base) - 0usize];
    ["Offset of field: pm_match_write_node::call"]
        [::std::mem::offset_of!(pm_match_write_node, call) - 24usize];
    ["Offset of field: pm_match_write_node::targets"]
        [::std::mem::offset_of!(pm_match_write_node, targets) - 32usize];
};
#[doc = " MatchWriteNode\n\n Represents writing local variables using a regular expression match with named capture groups.\n\n     /(?<foo>bar)/ =~ baz\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_MATCH_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_match_write_node_t = pm_match_write_node;
#[doc = " MissingNode\n\n Represents a node that is missing from the source and results in a syntax error.\n\n Type: ::PM_MISSING_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_missing_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_missing_node"][::std::mem::size_of::<pm_missing_node>() - 24usize];
    ["Alignment of pm_missing_node"][::std::mem::align_of::<pm_missing_node>() - 8usize];
    ["Offset of field: pm_missing_node::base"]
        [::std::mem::offset_of!(pm_missing_node, base) - 0usize];
};
#[doc = " MissingNode\n\n Represents a node that is missing from the source and results in a syntax error.\n\n Type: ::PM_MISSING_NODE\n\n @extends pm_node_t"]
pub type pm_missing_node_t = pm_missing_node;
#[doc = " ModuleNode\n\n Represents a module declaration involving the `module` keyword.\n\n     module Foo end\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_MODULE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_module_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ModuleNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " ModuleNode#module_keyword_loc"]
    pub module_keyword_loc: pm_location_t,
    #[doc = " ModuleNode#constant_path"]
    pub constant_path: *mut pm_node,
    #[doc = " ModuleNode#body"]
    pub body: *mut pm_node,
    #[doc = " ModuleNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
    #[doc = " ModuleNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_module_node"][::std::mem::size_of::<pm_module_node>() - 104usize];
    ["Alignment of pm_module_node"][::std::mem::align_of::<pm_module_node>() - 8usize];
    ["Offset of field: pm_module_node::base"]
        [::std::mem::offset_of!(pm_module_node, base) - 0usize];
    ["Offset of field: pm_module_node::locals"]
        [::std::mem::offset_of!(pm_module_node, locals) - 24usize];
    ["Offset of field: pm_module_node::module_keyword_loc"]
        [::std::mem::offset_of!(pm_module_node, module_keyword_loc) - 48usize];
    ["Offset of field: pm_module_node::constant_path"]
        [::std::mem::offset_of!(pm_module_node, constant_path) - 64usize];
    ["Offset of field: pm_module_node::body"]
        [::std::mem::offset_of!(pm_module_node, body) - 72usize];
    ["Offset of field: pm_module_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_module_node, end_keyword_loc) - 80usize];
    ["Offset of field: pm_module_node::name"]
        [::std::mem::offset_of!(pm_module_node, name) - 96usize];
};
#[doc = " ModuleNode\n\n Represents a module declaration involving the `module` keyword.\n\n     module Foo end\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_MODULE_NODE\n\n @extends pm_node_t"]
pub type pm_module_node_t = pm_module_node;
#[doc = " MultiTargetNode\n\n Represents a multi-target expression.\n\n     a, (b, c) = 1, 2, 3\n        ^^^^^^\n\n This can be a part of `MultiWriteNode` as above, or the target of a `for` loop\n\n     for a, b in [[1, 2], [3, 4]]\n         ^^^^\n\n Type: ::PM_MULTI_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_multi_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MultiTargetNode#lefts\n\n Represents the targets expressions before a splat node.\n\n     a, (b, c, *) = 1, 2, 3, 4, 5\n         ^^^^\n\n The splat node can be absent, in that case all target expressions are in the left field.\n\n     a, (b, c) = 1, 2, 3, 4, 5\n         ^^^^"]
    pub lefts: pm_node_list,
    #[doc = " MultiTargetNode#rest\n\n Represents a splat node in the target expression.\n\n     a, (b, *c) = 1, 2, 3, 4\n            ^^\n\n The variable can be empty, this results in a `SplatNode` with a `nil` expression field.\n\n     a, (b, *) = 1, 2, 3, 4\n            ^\n\n If the `*` is omitted, this field will contain an `ImplicitRestNode`\n\n     a, (b,) = 1, 2, 3, 4\n          ^"]
    pub rest: *mut pm_node,
    #[doc = " MultiTargetNode#rights\n\n Represents the targets expressions after a splat node.\n\n     a, (*, b, c) = 1, 2, 3, 4, 5\n            ^^^^"]
    pub rights: pm_node_list,
    #[doc = " MultiTargetNode#lparen_loc\n\n The location of the opening parenthesis.\n\n     a, (b, c) = 1, 2, 3\n        ^"]
    pub lparen_loc: pm_location_t,
    #[doc = " MultiTargetNode#rparen_loc\n\n The location of the closing parenthesis.\n\n     a, (b, c) = 1, 2, 3\n             ^"]
    pub rparen_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_multi_target_node"][::std::mem::size_of::<pm_multi_target_node>() - 112usize];
    ["Alignment of pm_multi_target_node"][::std::mem::align_of::<pm_multi_target_node>() - 8usize];
    ["Offset of field: pm_multi_target_node::base"]
        [::std::mem::offset_of!(pm_multi_target_node, base) - 0usize];
    ["Offset of field: pm_multi_target_node::lefts"]
        [::std::mem::offset_of!(pm_multi_target_node, lefts) - 24usize];
    ["Offset of field: pm_multi_target_node::rest"]
        [::std::mem::offset_of!(pm_multi_target_node, rest) - 48usize];
    ["Offset of field: pm_multi_target_node::rights"]
        [::std::mem::offset_of!(pm_multi_target_node, rights) - 56usize];
    ["Offset of field: pm_multi_target_node::lparen_loc"]
        [::std::mem::offset_of!(pm_multi_target_node, lparen_loc) - 80usize];
    ["Offset of field: pm_multi_target_node::rparen_loc"]
        [::std::mem::offset_of!(pm_multi_target_node, rparen_loc) - 96usize];
};
#[doc = " MultiTargetNode\n\n Represents a multi-target expression.\n\n     a, (b, c) = 1, 2, 3\n        ^^^^^^\n\n This can be a part of `MultiWriteNode` as above, or the target of a `for` loop\n\n     for a, b in [[1, 2], [3, 4]]\n         ^^^^\n\n Type: ::PM_MULTI_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_multi_target_node_t = pm_multi_target_node;
#[doc = " MultiWriteNode\n\n Represents a write to a multi-target expression.\n\n     a, b, c = 1, 2, 3\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_MULTI_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_multi_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MultiWriteNode#lefts\n\n Represents the targets expressions before a splat node.\n\n     a, b, * = 1, 2, 3, 4, 5\n     ^^^^\n\n The splat node can be absent, in that case all target expressions are in the left field.\n\n     a, b, c = 1, 2, 3, 4, 5\n     ^^^^^^^"]
    pub lefts: pm_node_list,
    #[doc = " MultiWriteNode#rest\n\n Represents a splat node in the target expression.\n\n     a, b, *c = 1, 2, 3, 4\n           ^^\n\n The variable can be empty, this results in a `SplatNode` with a `nil` expression field.\n\n     a, b, * = 1, 2, 3, 4\n           ^\n\n If the `*` is omitted, this field will contain an `ImplicitRestNode`\n\n     a, b, = 1, 2, 3, 4\n         ^"]
    pub rest: *mut pm_node,
    #[doc = " MultiWriteNode#rights\n\n Represents the targets expressions after a splat node.\n\n     a, *, b, c = 1, 2, 3, 4, 5\n           ^^^^"]
    pub rights: pm_node_list,
    #[doc = " MultiWriteNode#lparen_loc\n\n The location of the opening parenthesis.\n\n     (a, b, c) = 1, 2, 3\n     ^"]
    pub lparen_loc: pm_location_t,
    #[doc = " MultiWriteNode#rparen_loc\n\n The location of the closing parenthesis.\n\n     (a, b, c) = 1, 2, 3\n             ^"]
    pub rparen_loc: pm_location_t,
    #[doc = " MultiWriteNode#operator_loc\n\n The location of the operator.\n\n     a, b, c = 1, 2, 3\n             ^"]
    pub operator_loc: pm_location_t,
    #[doc = " MultiWriteNode#value\n\n The value to write to the targets. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     a, b, c = 1, 2, 3\n               ^^^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_multi_write_node"][::std::mem::size_of::<pm_multi_write_node>() - 136usize];
    ["Alignment of pm_multi_write_node"][::std::mem::align_of::<pm_multi_write_node>() - 8usize];
    ["Offset of field: pm_multi_write_node::base"]
        [::std::mem::offset_of!(pm_multi_write_node, base) - 0usize];
    ["Offset of field: pm_multi_write_node::lefts"]
        [::std::mem::offset_of!(pm_multi_write_node, lefts) - 24usize];
    ["Offset of field: pm_multi_write_node::rest"]
        [::std::mem::offset_of!(pm_multi_write_node, rest) - 48usize];
    ["Offset of field: pm_multi_write_node::rights"]
        [::std::mem::offset_of!(pm_multi_write_node, rights) - 56usize];
    ["Offset of field: pm_multi_write_node::lparen_loc"]
        [::std::mem::offset_of!(pm_multi_write_node, lparen_loc) - 80usize];
    ["Offset of field: pm_multi_write_node::rparen_loc"]
        [::std::mem::offset_of!(pm_multi_write_node, rparen_loc) - 96usize];
    ["Offset of field: pm_multi_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_multi_write_node, operator_loc) - 112usize];
    ["Offset of field: pm_multi_write_node::value"]
        [::std::mem::offset_of!(pm_multi_write_node, value) - 128usize];
};
#[doc = " MultiWriteNode\n\n Represents a write to a multi-target expression.\n\n     a, b, c = 1, 2, 3\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_MULTI_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_multi_write_node_t = pm_multi_write_node;
#[doc = " NextNode\n\n Represents the use of the `next` keyword.\n\n     next 1\n     ^^^^^^\n\n Type: ::PM_NEXT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_next_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " NextNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " NextNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_next_node"][::std::mem::size_of::<pm_next_node>() - 48usize];
    ["Alignment of pm_next_node"][::std::mem::align_of::<pm_next_node>() - 8usize];
    ["Offset of field: pm_next_node::base"][::std::mem::offset_of!(pm_next_node, base) - 0usize];
    ["Offset of field: pm_next_node::arguments"]
        [::std::mem::offset_of!(pm_next_node, arguments) - 24usize];
    ["Offset of field: pm_next_node::keyword_loc"]
        [::std::mem::offset_of!(pm_next_node, keyword_loc) - 32usize];
};
#[doc = " NextNode\n\n Represents the use of the `next` keyword.\n\n     next 1\n     ^^^^^^\n\n Type: ::PM_NEXT_NODE\n\n @extends pm_node_t"]
pub type pm_next_node_t = pm_next_node;
#[doc = " NilNode\n\n Represents the use of the `nil` keyword.\n\n     nil\n     ^^^\n\n Type: ::PM_NIL_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_nil_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_nil_node"][::std::mem::size_of::<pm_nil_node>() - 24usize];
    ["Alignment of pm_nil_node"][::std::mem::align_of::<pm_nil_node>() - 8usize];
    ["Offset of field: pm_nil_node::base"][::std::mem::offset_of!(pm_nil_node, base) - 0usize];
};
#[doc = " NilNode\n\n Represents the use of the `nil` keyword.\n\n     nil\n     ^^^\n\n Type: ::PM_NIL_NODE\n\n @extends pm_node_t"]
pub type pm_nil_node_t = pm_nil_node;
#[doc = " NoKeywordsParameterNode\n\n Represents the use of `**nil` inside method arguments.\n\n     def a(**nil)\n           ^^^^^\n     end\n\n Type: ::PM_NO_KEYWORDS_PARAMETER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_no_keywords_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " NoKeywordsParameterNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " NoKeywordsParameterNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_no_keywords_parameter_node"]
        [::std::mem::size_of::<pm_no_keywords_parameter_node>() - 56usize];
    ["Alignment of pm_no_keywords_parameter_node"]
        [::std::mem::align_of::<pm_no_keywords_parameter_node>() - 8usize];
    ["Offset of field: pm_no_keywords_parameter_node::base"]
        [::std::mem::offset_of!(pm_no_keywords_parameter_node, base) - 0usize];
    ["Offset of field: pm_no_keywords_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_no_keywords_parameter_node, operator_loc) - 24usize];
    ["Offset of field: pm_no_keywords_parameter_node::keyword_loc"]
        [::std::mem::offset_of!(pm_no_keywords_parameter_node, keyword_loc) - 40usize];
};
#[doc = " NoKeywordsParameterNode\n\n Represents the use of `**nil` inside method arguments.\n\n     def a(**nil)\n           ^^^^^\n     end\n\n Type: ::PM_NO_KEYWORDS_PARAMETER_NODE\n\n @extends pm_node_t"]
pub type pm_no_keywords_parameter_node_t = pm_no_keywords_parameter_node;
#[doc = " NumberedParametersNode\n\n Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.\n\n     -> { _1 + _2 }\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_NUMBERED_PARAMETERS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_numbered_parameters_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " NumberedParametersNode#maximum"]
    pub maximum: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_numbered_parameters_node"]
        [::std::mem::size_of::<pm_numbered_parameters_node>() - 32usize];
    ["Alignment of pm_numbered_parameters_node"]
        [::std::mem::align_of::<pm_numbered_parameters_node>() - 8usize];
    ["Offset of field: pm_numbered_parameters_node::base"]
        [::std::mem::offset_of!(pm_numbered_parameters_node, base) - 0usize];
    ["Offset of field: pm_numbered_parameters_node::maximum"]
        [::std::mem::offset_of!(pm_numbered_parameters_node, maximum) - 24usize];
};
#[doc = " NumberedParametersNode\n\n Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.\n\n     -> { _1 + _2 }\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_NUMBERED_PARAMETERS_NODE\n\n @extends pm_node_t"]
pub type pm_numbered_parameters_node_t = pm_numbered_parameters_node;
#[doc = " NumberedReferenceReadNode\n\n Represents reading a numbered reference to a capture in the previous match.\n\n     $1\n     ^^\n\n Type: ::PM_NUMBERED_REFERENCE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_numbered_reference_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " NumberedReferenceReadNode#number\n\n The (1-indexed, from the left) number of the capture group. Numbered references that are too large result in this value being `0`.\n\n     $1          # number `1`\n\n     $5432       # number `5432`\n\n     $4294967296 # number `0`"]
    pub number: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_numbered_reference_read_node"]
        [::std::mem::size_of::<pm_numbered_reference_read_node>() - 32usize];
    ["Alignment of pm_numbered_reference_read_node"]
        [::std::mem::align_of::<pm_numbered_reference_read_node>() - 8usize];
    ["Offset of field: pm_numbered_reference_read_node::base"]
        [::std::mem::offset_of!(pm_numbered_reference_read_node, base) - 0usize];
    ["Offset of field: pm_numbered_reference_read_node::number"]
        [::std::mem::offset_of!(pm_numbered_reference_read_node, number) - 24usize];
};
#[doc = " NumberedReferenceReadNode\n\n Represents reading a numbered reference to a capture in the previous match.\n\n     $1\n     ^^\n\n Type: ::PM_NUMBERED_REFERENCE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_numbered_reference_read_node_t = pm_numbered_reference_read_node;
#[doc = " OptionalKeywordParameterNode\n\n Represents an optional keyword parameter to a method, block, or lambda definition.\n\n     def a(b: 1)\n           ^^^^\n     end\n\n Type: ::PM_OPTIONAL_KEYWORD_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_optional_keyword_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " OptionalKeywordParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " OptionalKeywordParameterNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " OptionalKeywordParameterNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_optional_keyword_parameter_node"]
        [::std::mem::size_of::<pm_optional_keyword_parameter_node>() - 56usize];
    ["Alignment of pm_optional_keyword_parameter_node"]
        [::std::mem::align_of::<pm_optional_keyword_parameter_node>() - 8usize];
    ["Offset of field: pm_optional_keyword_parameter_node::base"]
        [::std::mem::offset_of!(pm_optional_keyword_parameter_node, base) - 0usize];
    ["Offset of field: pm_optional_keyword_parameter_node::name"]
        [::std::mem::offset_of!(pm_optional_keyword_parameter_node, name) - 24usize];
    ["Offset of field: pm_optional_keyword_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_optional_keyword_parameter_node, name_loc) - 32usize];
    ["Offset of field: pm_optional_keyword_parameter_node::value"]
        [::std::mem::offset_of!(pm_optional_keyword_parameter_node, value) - 48usize];
};
#[doc = " OptionalKeywordParameterNode\n\n Represents an optional keyword parameter to a method, block, or lambda definition.\n\n     def a(b: 1)\n           ^^^^\n     end\n\n Type: ::PM_OPTIONAL_KEYWORD_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_optional_keyword_parameter_node_t = pm_optional_keyword_parameter_node;
#[doc = " OptionalParameterNode\n\n Represents an optional parameter to a method, block, or lambda definition.\n\n     def a(b = 1)\n           ^^^^^\n     end\n\n Type: ::PM_OPTIONAL_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_optional_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " OptionalParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " OptionalParameterNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " OptionalParameterNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " OptionalParameterNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_optional_parameter_node"]
        [::std::mem::size_of::<pm_optional_parameter_node>() - 72usize];
    ["Alignment of pm_optional_parameter_node"]
        [::std::mem::align_of::<pm_optional_parameter_node>() - 8usize];
    ["Offset of field: pm_optional_parameter_node::base"]
        [::std::mem::offset_of!(pm_optional_parameter_node, base) - 0usize];
    ["Offset of field: pm_optional_parameter_node::name"]
        [::std::mem::offset_of!(pm_optional_parameter_node, name) - 24usize];
    ["Offset of field: pm_optional_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_optional_parameter_node, name_loc) - 32usize];
    ["Offset of field: pm_optional_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_optional_parameter_node, operator_loc) - 48usize];
    ["Offset of field: pm_optional_parameter_node::value"]
        [::std::mem::offset_of!(pm_optional_parameter_node, value) - 64usize];
};
#[doc = " OptionalParameterNode\n\n Represents an optional parameter to a method, block, or lambda definition.\n\n     def a(b = 1)\n           ^^^^^\n     end\n\n Type: ::PM_OPTIONAL_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_optional_parameter_node_t = pm_optional_parameter_node;
#[doc = " OrNode\n\n Represents the use of the `||` operator or the `or` keyword.\n\n     left or right\n     ^^^^^^^^^^^^^\n\n Type: ::PM_OR_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_or_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " OrNode#left\n\n Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     left or right\n     ^^^^\n\n     1 || 2\n     ^"]
    pub left: *mut pm_node,
    #[doc = " OrNode#right\n\n Represents the right side of the expression.\n\n     left || right\n             ^^^^^\n\n     1 or 2\n          ^"]
    pub right: *mut pm_node,
    #[doc = " OrNode#operator_loc\n\n The location of the `or` keyword or the `||` operator.\n\n     left or right\n          ^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_or_node"][::std::mem::size_of::<pm_or_node>() - 56usize];
    ["Alignment of pm_or_node"][::std::mem::align_of::<pm_or_node>() - 8usize];
    ["Offset of field: pm_or_node::base"][::std::mem::offset_of!(pm_or_node, base) - 0usize];
    ["Offset of field: pm_or_node::left"][::std::mem::offset_of!(pm_or_node, left) - 24usize];
    ["Offset of field: pm_or_node::right"][::std::mem::offset_of!(pm_or_node, right) - 32usize];
    ["Offset of field: pm_or_node::operator_loc"]
        [::std::mem::offset_of!(pm_or_node, operator_loc) - 40usize];
};
#[doc = " OrNode\n\n Represents the use of the `||` operator or the `or` keyword.\n\n     left or right\n     ^^^^^^^^^^^^^\n\n Type: ::PM_OR_NODE\n\n @extends pm_node_t"]
pub type pm_or_node_t = pm_or_node;
#[doc = " ParametersNode\n\n Represents the list of parameters on a method, block, or lambda definition.\n\n     def a(b, c, d)\n           ^^^^^^^\n     end\n\n Type: ::PM_PARAMETERS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_parameters_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ParametersNode#requireds"]
    pub requireds: pm_node_list,
    #[doc = " ParametersNode#optionals"]
    pub optionals: pm_node_list,
    #[doc = " ParametersNode#rest"]
    pub rest: *mut pm_node,
    #[doc = " ParametersNode#posts"]
    pub posts: pm_node_list,
    #[doc = " ParametersNode#keywords"]
    pub keywords: pm_node_list,
    #[doc = " ParametersNode#keyword_rest"]
    pub keyword_rest: *mut pm_node,
    #[doc = " ParametersNode#block"]
    pub block: *mut pm_block_parameter_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parameters_node"][::std::mem::size_of::<pm_parameters_node>() - 144usize];
    ["Alignment of pm_parameters_node"][::std::mem::align_of::<pm_parameters_node>() - 8usize];
    ["Offset of field: pm_parameters_node::base"]
        [::std::mem::offset_of!(pm_parameters_node, base) - 0usize];
    ["Offset of field: pm_parameters_node::requireds"]
        [::std::mem::offset_of!(pm_parameters_node, requireds) - 24usize];
    ["Offset of field: pm_parameters_node::optionals"]
        [::std::mem::offset_of!(pm_parameters_node, optionals) - 48usize];
    ["Offset of field: pm_parameters_node::rest"]
        [::std::mem::offset_of!(pm_parameters_node, rest) - 72usize];
    ["Offset of field: pm_parameters_node::posts"]
        [::std::mem::offset_of!(pm_parameters_node, posts) - 80usize];
    ["Offset of field: pm_parameters_node::keywords"]
        [::std::mem::offset_of!(pm_parameters_node, keywords) - 104usize];
    ["Offset of field: pm_parameters_node::keyword_rest"]
        [::std::mem::offset_of!(pm_parameters_node, keyword_rest) - 128usize];
    ["Offset of field: pm_parameters_node::block"]
        [::std::mem::offset_of!(pm_parameters_node, block) - 136usize];
};
#[doc = " ParametersNode\n\n Represents the list of parameters on a method, block, or lambda definition.\n\n     def a(b, c, d)\n           ^^^^^^^\n     end\n\n Type: ::PM_PARAMETERS_NODE\n\n @extends pm_node_t"]
pub type pm_parameters_node_t = pm_parameters_node;
#[doc = " ParenthesesNode\n\n Represents a parenthesized expression\n\n     (10 + 34)\n     ^^^^^^^^^\n\n Type: ::PM_PARENTHESES_NODE\n\n Flags (#pm_parentheses_node_flags):\n * ::PM_PARENTHESES_NODE_FLAGS_MULTIPLE_STATEMENTS\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_parentheses_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ParenthesesNode#body"]
    pub body: *mut pm_node,
    #[doc = " ParenthesesNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " ParenthesesNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parentheses_node"][::std::mem::size_of::<pm_parentheses_node>() - 64usize];
    ["Alignment of pm_parentheses_node"][::std::mem::align_of::<pm_parentheses_node>() - 8usize];
    ["Offset of field: pm_parentheses_node::base"]
        [::std::mem::offset_of!(pm_parentheses_node, base) - 0usize];
    ["Offset of field: pm_parentheses_node::body"]
        [::std::mem::offset_of!(pm_parentheses_node, body) - 24usize];
    ["Offset of field: pm_parentheses_node::opening_loc"]
        [::std::mem::offset_of!(pm_parentheses_node, opening_loc) - 32usize];
    ["Offset of field: pm_parentheses_node::closing_loc"]
        [::std::mem::offset_of!(pm_parentheses_node, closing_loc) - 48usize];
};
#[doc = " ParenthesesNode\n\n Represents a parenthesized expression\n\n     (10 + 34)\n     ^^^^^^^^^\n\n Type: ::PM_PARENTHESES_NODE\n\n Flags (#pm_parentheses_node_flags):\n * ::PM_PARENTHESES_NODE_FLAGS_MULTIPLE_STATEMENTS\n\n @extends pm_node_t"]
pub type pm_parentheses_node_t = pm_parentheses_node;
#[doc = " PinnedExpressionNode\n\n Represents the use of the `^` operator for pinning an expression in a pattern matching expression.\n\n     foo in ^(bar)\n            ^^^^^^\n\n Type: ::PM_PINNED_EXPRESSION_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_pinned_expression_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " PinnedExpressionNode#expression"]
    pub expression: *mut pm_node,
    #[doc = " PinnedExpressionNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " PinnedExpressionNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " PinnedExpressionNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_pinned_expression_node"]
        [::std::mem::size_of::<pm_pinned_expression_node>() - 80usize];
    ["Alignment of pm_pinned_expression_node"]
        [::std::mem::align_of::<pm_pinned_expression_node>() - 8usize];
    ["Offset of field: pm_pinned_expression_node::base"]
        [::std::mem::offset_of!(pm_pinned_expression_node, base) - 0usize];
    ["Offset of field: pm_pinned_expression_node::expression"]
        [::std::mem::offset_of!(pm_pinned_expression_node, expression) - 24usize];
    ["Offset of field: pm_pinned_expression_node::operator_loc"]
        [::std::mem::offset_of!(pm_pinned_expression_node, operator_loc) - 32usize];
    ["Offset of field: pm_pinned_expression_node::lparen_loc"]
        [::std::mem::offset_of!(pm_pinned_expression_node, lparen_loc) - 48usize];
    ["Offset of field: pm_pinned_expression_node::rparen_loc"]
        [::std::mem::offset_of!(pm_pinned_expression_node, rparen_loc) - 64usize];
};
#[doc = " PinnedExpressionNode\n\n Represents the use of the `^` operator for pinning an expression in a pattern matching expression.\n\n     foo in ^(bar)\n            ^^^^^^\n\n Type: ::PM_PINNED_EXPRESSION_NODE\n\n @extends pm_node_t"]
pub type pm_pinned_expression_node_t = pm_pinned_expression_node;
#[doc = " PinnedVariableNode\n\n Represents the use of the `^` operator for pinning a variable in a pattern matching expression.\n\n     foo in ^bar\n            ^^^^\n\n Type: ::PM_PINNED_VARIABLE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_pinned_variable_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " PinnedVariableNode#variable"]
    pub variable: *mut pm_node,
    #[doc = " PinnedVariableNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_pinned_variable_node"][::std::mem::size_of::<pm_pinned_variable_node>() - 48usize];
    ["Alignment of pm_pinned_variable_node"]
        [::std::mem::align_of::<pm_pinned_variable_node>() - 8usize];
    ["Offset of field: pm_pinned_variable_node::base"]
        [::std::mem::offset_of!(pm_pinned_variable_node, base) - 0usize];
    ["Offset of field: pm_pinned_variable_node::variable"]
        [::std::mem::offset_of!(pm_pinned_variable_node, variable) - 24usize];
    ["Offset of field: pm_pinned_variable_node::operator_loc"]
        [::std::mem::offset_of!(pm_pinned_variable_node, operator_loc) - 32usize];
};
#[doc = " PinnedVariableNode\n\n Represents the use of the `^` operator for pinning a variable in a pattern matching expression.\n\n     foo in ^bar\n            ^^^^\n\n Type: ::PM_PINNED_VARIABLE_NODE\n\n @extends pm_node_t"]
pub type pm_pinned_variable_node_t = pm_pinned_variable_node;
#[doc = " PostExecutionNode\n\n Represents the use of the `END` keyword.\n\n     END { foo }\n     ^^^^^^^^^^^\n\n Type: ::PM_POST_EXECUTION_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_post_execution_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " PostExecutionNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " PostExecutionNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " PostExecutionNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " PostExecutionNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_post_execution_node"][::std::mem::size_of::<pm_post_execution_node>() - 80usize];
    ["Alignment of pm_post_execution_node"]
        [::std::mem::align_of::<pm_post_execution_node>() - 8usize];
    ["Offset of field: pm_post_execution_node::base"]
        [::std::mem::offset_of!(pm_post_execution_node, base) - 0usize];
    ["Offset of field: pm_post_execution_node::statements"]
        [::std::mem::offset_of!(pm_post_execution_node, statements) - 24usize];
    ["Offset of field: pm_post_execution_node::keyword_loc"]
        [::std::mem::offset_of!(pm_post_execution_node, keyword_loc) - 32usize];
    ["Offset of field: pm_post_execution_node::opening_loc"]
        [::std::mem::offset_of!(pm_post_execution_node, opening_loc) - 48usize];
    ["Offset of field: pm_post_execution_node::closing_loc"]
        [::std::mem::offset_of!(pm_post_execution_node, closing_loc) - 64usize];
};
#[doc = " PostExecutionNode\n\n Represents the use of the `END` keyword.\n\n     END { foo }\n     ^^^^^^^^^^^\n\n Type: ::PM_POST_EXECUTION_NODE\n\n @extends pm_node_t"]
pub type pm_post_execution_node_t = pm_post_execution_node;
#[doc = " PreExecutionNode\n\n Represents the use of the `BEGIN` keyword.\n\n     BEGIN { foo }\n     ^^^^^^^^^^^^^\n\n Type: ::PM_PRE_EXECUTION_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_pre_execution_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " PreExecutionNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " PreExecutionNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " PreExecutionNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " PreExecutionNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_pre_execution_node"][::std::mem::size_of::<pm_pre_execution_node>() - 80usize];
    ["Alignment of pm_pre_execution_node"]
        [::std::mem::align_of::<pm_pre_execution_node>() - 8usize];
    ["Offset of field: pm_pre_execution_node::base"]
        [::std::mem::offset_of!(pm_pre_execution_node, base) - 0usize];
    ["Offset of field: pm_pre_execution_node::statements"]
        [::std::mem::offset_of!(pm_pre_execution_node, statements) - 24usize];
    ["Offset of field: pm_pre_execution_node::keyword_loc"]
        [::std::mem::offset_of!(pm_pre_execution_node, keyword_loc) - 32usize];
    ["Offset of field: pm_pre_execution_node::opening_loc"]
        [::std::mem::offset_of!(pm_pre_execution_node, opening_loc) - 48usize];
    ["Offset of field: pm_pre_execution_node::closing_loc"]
        [::std::mem::offset_of!(pm_pre_execution_node, closing_loc) - 64usize];
};
#[doc = " PreExecutionNode\n\n Represents the use of the `BEGIN` keyword.\n\n     BEGIN { foo }\n     ^^^^^^^^^^^^^\n\n Type: ::PM_PRE_EXECUTION_NODE\n\n @extends pm_node_t"]
pub type pm_pre_execution_node_t = pm_pre_execution_node;
#[doc = " ProgramNode\n\n The top level node of any parse tree.\n\n Type: ::PM_PROGRAM_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_program_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ProgramNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " ProgramNode#statements"]
    pub statements: *mut pm_statements_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_program_node"][::std::mem::size_of::<pm_program_node>() - 56usize];
    ["Alignment of pm_program_node"][::std::mem::align_of::<pm_program_node>() - 8usize];
    ["Offset of field: pm_program_node::base"]
        [::std::mem::offset_of!(pm_program_node, base) - 0usize];
    ["Offset of field: pm_program_node::locals"]
        [::std::mem::offset_of!(pm_program_node, locals) - 24usize];
    ["Offset of field: pm_program_node::statements"]
        [::std::mem::offset_of!(pm_program_node, statements) - 48usize];
};
#[doc = " ProgramNode\n\n The top level node of any parse tree.\n\n Type: ::PM_PROGRAM_NODE\n\n @extends pm_node_t"]
pub type pm_program_node_t = pm_program_node;
#[doc = " RangeNode\n\n Represents the use of the `..` or `...` operators.\n\n     1..2\n     ^^^^\n\n     c if a =~ /left/ ... b =~ /right/\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_RANGE_NODE\n\n Flags (#pm_range_flags):\n * ::PM_RANGE_FLAGS_EXCLUDE_END\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_range_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RangeNode#left\n\n The left-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     1...\n     ^\n\n     hello...goodbye\n     ^^^^^"]
    pub left: *mut pm_node,
    #[doc = " RangeNode#right\n\n The right-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     ..5\n       ^\n\n     1...foo\n         ^^^\n If neither right-hand or left-hand side was included, this will be a MissingNode."]
    pub right: *mut pm_node,
    #[doc = " RangeNode#operator_loc\n\n The location of the `..` or `...` operator."]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_range_node"][::std::mem::size_of::<pm_range_node>() - 56usize];
    ["Alignment of pm_range_node"][::std::mem::align_of::<pm_range_node>() - 8usize];
    ["Offset of field: pm_range_node::base"][::std::mem::offset_of!(pm_range_node, base) - 0usize];
    ["Offset of field: pm_range_node::left"][::std::mem::offset_of!(pm_range_node, left) - 24usize];
    ["Offset of field: pm_range_node::right"]
        [::std::mem::offset_of!(pm_range_node, right) - 32usize];
    ["Offset of field: pm_range_node::operator_loc"]
        [::std::mem::offset_of!(pm_range_node, operator_loc) - 40usize];
};
#[doc = " RangeNode\n\n Represents the use of the `..` or `...` operators.\n\n     1..2\n     ^^^^\n\n     c if a =~ /left/ ... b =~ /right/\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_RANGE_NODE\n\n Flags (#pm_range_flags):\n * ::PM_RANGE_FLAGS_EXCLUDE_END\n\n @extends pm_node_t"]
pub type pm_range_node_t = pm_range_node;
#[doc = " RationalNode\n\n Represents a rational number literal.\n\n     1.0r\n     ^^^^\n\n Type: ::PM_RATIONAL_NODE\n\n Flags (#pm_integer_base_flags):\n * ::PM_INTEGER_BASE_FLAGS_BINARY\n * ::PM_INTEGER_BASE_FLAGS_DECIMAL\n * ::PM_INTEGER_BASE_FLAGS_OCTAL\n * ::PM_INTEGER_BASE_FLAGS_HEXADECIMAL\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_rational_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RationalNode#numerator\n\n The numerator of the rational number.\n\n     1.5r # numerator 3"]
    pub numerator: pm_integer_t,
    #[doc = " RationalNode#denominator\n\n The denominator of the rational number.\n\n     1.5r # denominator 2"]
    pub denominator: pm_integer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_rational_node"][::std::mem::size_of::<pm_rational_node>() - 72usize];
    ["Alignment of pm_rational_node"][::std::mem::align_of::<pm_rational_node>() - 8usize];
    ["Offset of field: pm_rational_node::base"]
        [::std::mem::offset_of!(pm_rational_node, base) - 0usize];
    ["Offset of field: pm_rational_node::numerator"]
        [::std::mem::offset_of!(pm_rational_node, numerator) - 24usize];
    ["Offset of field: pm_rational_node::denominator"]
        [::std::mem::offset_of!(pm_rational_node, denominator) - 48usize];
};
#[doc = " RationalNode\n\n Represents a rational number literal.\n\n     1.0r\n     ^^^^\n\n Type: ::PM_RATIONAL_NODE\n\n Flags (#pm_integer_base_flags):\n * ::PM_INTEGER_BASE_FLAGS_BINARY\n * ::PM_INTEGER_BASE_FLAGS_DECIMAL\n * ::PM_INTEGER_BASE_FLAGS_OCTAL\n * ::PM_INTEGER_BASE_FLAGS_HEXADECIMAL\n\n @extends pm_node_t"]
pub type pm_rational_node_t = pm_rational_node;
#[doc = " RedoNode\n\n Represents the use of the `redo` keyword.\n\n     redo\n     ^^^^\n\n Type: ::PM_REDO_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_redo_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_redo_node"][::std::mem::size_of::<pm_redo_node>() - 24usize];
    ["Alignment of pm_redo_node"][::std::mem::align_of::<pm_redo_node>() - 8usize];
    ["Offset of field: pm_redo_node::base"][::std::mem::offset_of!(pm_redo_node, base) - 0usize];
};
#[doc = " RedoNode\n\n Represents the use of the `redo` keyword.\n\n     redo\n     ^^^^\n\n Type: ::PM_REDO_NODE\n\n @extends pm_node_t"]
pub type pm_redo_node_t = pm_redo_node;
#[doc = " RegularExpressionNode\n\n Represents a regular expression literal with no interpolation.\n\n     /foo/i\n     ^^^^^^\n\n Type: ::PM_REGULAR_EXPRESSION_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_regular_expression_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RegularExpressionNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " RegularExpressionNode#content_loc"]
    pub content_loc: pm_location_t,
    #[doc = " RegularExpressionNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " RegularExpressionNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_regular_expression_node"]
        [::std::mem::size_of::<pm_regular_expression_node>() - 96usize];
    ["Alignment of pm_regular_expression_node"]
        [::std::mem::align_of::<pm_regular_expression_node>() - 8usize];
    ["Offset of field: pm_regular_expression_node::base"]
        [::std::mem::offset_of!(pm_regular_expression_node, base) - 0usize];
    ["Offset of field: pm_regular_expression_node::opening_loc"]
        [::std::mem::offset_of!(pm_regular_expression_node, opening_loc) - 24usize];
    ["Offset of field: pm_regular_expression_node::content_loc"]
        [::std::mem::offset_of!(pm_regular_expression_node, content_loc) - 40usize];
    ["Offset of field: pm_regular_expression_node::closing_loc"]
        [::std::mem::offset_of!(pm_regular_expression_node, closing_loc) - 56usize];
    ["Offset of field: pm_regular_expression_node::unescaped"]
        [::std::mem::offset_of!(pm_regular_expression_node, unescaped) - 72usize];
};
#[doc = " RegularExpressionNode\n\n Represents a regular expression literal with no interpolation.\n\n     /foo/i\n     ^^^^^^\n\n Type: ::PM_REGULAR_EXPRESSION_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_regular_expression_node_t = pm_regular_expression_node;
#[doc = " RequiredKeywordParameterNode\n\n Represents a required keyword parameter to a method, block, or lambda definition.\n\n     def a(b: )\n           ^^\n     end\n\n Type: ::PM_REQUIRED_KEYWORD_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_required_keyword_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RequiredKeywordParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " RequiredKeywordParameterNode#name_loc"]
    pub name_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_required_keyword_parameter_node"]
        [::std::mem::size_of::<pm_required_keyword_parameter_node>() - 48usize];
    ["Alignment of pm_required_keyword_parameter_node"]
        [::std::mem::align_of::<pm_required_keyword_parameter_node>() - 8usize];
    ["Offset of field: pm_required_keyword_parameter_node::base"]
        [::std::mem::offset_of!(pm_required_keyword_parameter_node, base) - 0usize];
    ["Offset of field: pm_required_keyword_parameter_node::name"]
        [::std::mem::offset_of!(pm_required_keyword_parameter_node, name) - 24usize];
    ["Offset of field: pm_required_keyword_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_required_keyword_parameter_node, name_loc) - 32usize];
};
#[doc = " RequiredKeywordParameterNode\n\n Represents a required keyword parameter to a method, block, or lambda definition.\n\n     def a(b: )\n           ^^\n     end\n\n Type: ::PM_REQUIRED_KEYWORD_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_required_keyword_parameter_node_t = pm_required_keyword_parameter_node;
#[doc = " RequiredParameterNode\n\n Represents a required parameter to a method, block, or lambda definition.\n\n     def a(b)\n           ^\n     end\n\n Type: ::PM_REQUIRED_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_required_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RequiredParameterNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_required_parameter_node"]
        [::std::mem::size_of::<pm_required_parameter_node>() - 32usize];
    ["Alignment of pm_required_parameter_node"]
        [::std::mem::align_of::<pm_required_parameter_node>() - 8usize];
    ["Offset of field: pm_required_parameter_node::base"]
        [::std::mem::offset_of!(pm_required_parameter_node, base) - 0usize];
    ["Offset of field: pm_required_parameter_node::name"]
        [::std::mem::offset_of!(pm_required_parameter_node, name) - 24usize];
};
#[doc = " RequiredParameterNode\n\n Represents a required parameter to a method, block, or lambda definition.\n\n     def a(b)\n           ^\n     end\n\n Type: ::PM_REQUIRED_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_required_parameter_node_t = pm_required_parameter_node;
#[doc = " RescueModifierNode\n\n Represents an expression modified with a rescue.\n\n     foo rescue nil\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_RESCUE_MODIFIER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_rescue_modifier_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RescueModifierNode#expression"]
    pub expression: *mut pm_node,
    #[doc = " RescueModifierNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " RescueModifierNode#rescue_expression"]
    pub rescue_expression: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_rescue_modifier_node"][::std::mem::size_of::<pm_rescue_modifier_node>() - 56usize];
    ["Alignment of pm_rescue_modifier_node"]
        [::std::mem::align_of::<pm_rescue_modifier_node>() - 8usize];
    ["Offset of field: pm_rescue_modifier_node::base"]
        [::std::mem::offset_of!(pm_rescue_modifier_node, base) - 0usize];
    ["Offset of field: pm_rescue_modifier_node::expression"]
        [::std::mem::offset_of!(pm_rescue_modifier_node, expression) - 24usize];
    ["Offset of field: pm_rescue_modifier_node::keyword_loc"]
        [::std::mem::offset_of!(pm_rescue_modifier_node, keyword_loc) - 32usize];
    ["Offset of field: pm_rescue_modifier_node::rescue_expression"]
        [::std::mem::offset_of!(pm_rescue_modifier_node, rescue_expression) - 48usize];
};
#[doc = " RescueModifierNode\n\n Represents an expression modified with a rescue.\n\n     foo rescue nil\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_RESCUE_MODIFIER_NODE\n\n @extends pm_node_t"]
pub type pm_rescue_modifier_node_t = pm_rescue_modifier_node;
#[doc = " RescueNode\n\n Represents a rescue statement.\n\n     begin\n     rescue Foo, *splat, Bar => ex\n       foo\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     end\n\n `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `reference` field.\n\n Type: ::PM_RESCUE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_rescue_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RescueNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " RescueNode#exceptions"]
    pub exceptions: pm_node_list,
    #[doc = " RescueNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " RescueNode#reference"]
    pub reference: *mut pm_node,
    #[doc = " RescueNode#then_keyword_loc"]
    pub then_keyword_loc: pm_location_t,
    #[doc = " RescueNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " RescueNode#subsequent"]
    pub subsequent: *mut pm_rescue_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_rescue_node"][::std::mem::size_of::<pm_rescue_node>() - 120usize];
    ["Alignment of pm_rescue_node"][::std::mem::align_of::<pm_rescue_node>() - 8usize];
    ["Offset of field: pm_rescue_node::base"]
        [::std::mem::offset_of!(pm_rescue_node, base) - 0usize];
    ["Offset of field: pm_rescue_node::keyword_loc"]
        [::std::mem::offset_of!(pm_rescue_node, keyword_loc) - 24usize];
    ["Offset of field: pm_rescue_node::exceptions"]
        [::std::mem::offset_of!(pm_rescue_node, exceptions) - 40usize];
    ["Offset of field: pm_rescue_node::operator_loc"]
        [::std::mem::offset_of!(pm_rescue_node, operator_loc) - 64usize];
    ["Offset of field: pm_rescue_node::reference"]
        [::std::mem::offset_of!(pm_rescue_node, reference) - 80usize];
    ["Offset of field: pm_rescue_node::then_keyword_loc"]
        [::std::mem::offset_of!(pm_rescue_node, then_keyword_loc) - 88usize];
    ["Offset of field: pm_rescue_node::statements"]
        [::std::mem::offset_of!(pm_rescue_node, statements) - 104usize];
    ["Offset of field: pm_rescue_node::subsequent"]
        [::std::mem::offset_of!(pm_rescue_node, subsequent) - 112usize];
};
#[doc = " RescueNode\n\n Represents a rescue statement.\n\n     begin\n     rescue Foo, *splat, Bar => ex\n       foo\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     end\n\n `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `reference` field.\n\n Type: ::PM_RESCUE_NODE\n\n @extends pm_node_t"]
pub type pm_rescue_node_t = pm_rescue_node;
#[doc = " RestParameterNode\n\n Represents a rest parameter to a method, block, or lambda definition.\n\n     def a(*b)\n           ^^\n     end\n\n Type: ::PM_REST_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_rest_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RestParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " RestParameterNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " RestParameterNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_rest_parameter_node"][::std::mem::size_of::<pm_rest_parameter_node>() - 64usize];
    ["Alignment of pm_rest_parameter_node"]
        [::std::mem::align_of::<pm_rest_parameter_node>() - 8usize];
    ["Offset of field: pm_rest_parameter_node::base"]
        [::std::mem::offset_of!(pm_rest_parameter_node, base) - 0usize];
    ["Offset of field: pm_rest_parameter_node::name"]
        [::std::mem::offset_of!(pm_rest_parameter_node, name) - 24usize];
    ["Offset of field: pm_rest_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_rest_parameter_node, name_loc) - 32usize];
    ["Offset of field: pm_rest_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_rest_parameter_node, operator_loc) - 48usize];
};
#[doc = " RestParameterNode\n\n Represents a rest parameter to a method, block, or lambda definition.\n\n     def a(*b)\n           ^^\n     end\n\n Type: ::PM_REST_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_rest_parameter_node_t = pm_rest_parameter_node;
#[doc = " RetryNode\n\n Represents the use of the `retry` keyword.\n\n     retry\n     ^^^^^\n\n Type: ::PM_RETRY_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_retry_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_retry_node"][::std::mem::size_of::<pm_retry_node>() - 24usize];
    ["Alignment of pm_retry_node"][::std::mem::align_of::<pm_retry_node>() - 8usize];
    ["Offset of field: pm_retry_node::base"][::std::mem::offset_of!(pm_retry_node, base) - 0usize];
};
#[doc = " RetryNode\n\n Represents the use of the `retry` keyword.\n\n     retry\n     ^^^^^\n\n Type: ::PM_RETRY_NODE\n\n @extends pm_node_t"]
pub type pm_retry_node_t = pm_retry_node;
#[doc = " ReturnNode\n\n Represents the use of the `return` keyword.\n\n     return 1\n     ^^^^^^^^\n\n Type: ::PM_RETURN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_return_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ReturnNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " ReturnNode#arguments"]
    pub arguments: *mut pm_arguments_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_return_node"][::std::mem::size_of::<pm_return_node>() - 48usize];
    ["Alignment of pm_return_node"][::std::mem::align_of::<pm_return_node>() - 8usize];
    ["Offset of field: pm_return_node::base"]
        [::std::mem::offset_of!(pm_return_node, base) - 0usize];
    ["Offset of field: pm_return_node::keyword_loc"]
        [::std::mem::offset_of!(pm_return_node, keyword_loc) - 24usize];
    ["Offset of field: pm_return_node::arguments"]
        [::std::mem::offset_of!(pm_return_node, arguments) - 40usize];
};
#[doc = " ReturnNode\n\n Represents the use of the `return` keyword.\n\n     return 1\n     ^^^^^^^^\n\n Type: ::PM_RETURN_NODE\n\n @extends pm_node_t"]
pub type pm_return_node_t = pm_return_node;
#[doc = " SelfNode\n\n Represents the `self` keyword.\n\n     self\n     ^^^^\n\n Type: ::PM_SELF_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_self_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_self_node"][::std::mem::size_of::<pm_self_node>() - 24usize];
    ["Alignment of pm_self_node"][::std::mem::align_of::<pm_self_node>() - 8usize];
    ["Offset of field: pm_self_node::base"][::std::mem::offset_of!(pm_self_node, base) - 0usize];
};
#[doc = " SelfNode\n\n Represents the `self` keyword.\n\n     self\n     ^^^^\n\n Type: ::PM_SELF_NODE\n\n @extends pm_node_t"]
pub type pm_self_node_t = pm_self_node;
#[doc = " ShareableConstantNode\n\n This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.\n\n     # shareable_constant_value: literal\n     C = { a: 1 }\n     ^^^^^^^^^^^^\n\n Type: ::PM_SHAREABLE_CONSTANT_NODE\n\n Flags (#pm_shareable_constant_node_flags):\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_LITERAL\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_EVERYTHING\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_COPY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_shareable_constant_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ShareableConstantNode#write\n\n The constant write that should be modified with the shareability state."]
    pub write: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_shareable_constant_node"]
        [::std::mem::size_of::<pm_shareable_constant_node>() - 32usize];
    ["Alignment of pm_shareable_constant_node"]
        [::std::mem::align_of::<pm_shareable_constant_node>() - 8usize];
    ["Offset of field: pm_shareable_constant_node::base"]
        [::std::mem::offset_of!(pm_shareable_constant_node, base) - 0usize];
    ["Offset of field: pm_shareable_constant_node::write"]
        [::std::mem::offset_of!(pm_shareable_constant_node, write) - 24usize];
};
#[doc = " ShareableConstantNode\n\n This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.\n\n     # shareable_constant_value: literal\n     C = { a: 1 }\n     ^^^^^^^^^^^^\n\n Type: ::PM_SHAREABLE_CONSTANT_NODE\n\n Flags (#pm_shareable_constant_node_flags):\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_LITERAL\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_EVERYTHING\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_COPY\n\n @extends pm_node_t"]
pub type pm_shareable_constant_node_t = pm_shareable_constant_node;
#[doc = " SingletonClassNode\n\n Represents a singleton class declaration involving the `class` keyword.\n\n     class << self end\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_SINGLETON_CLASS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_singleton_class_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SingletonClassNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " SingletonClassNode#class_keyword_loc"]
    pub class_keyword_loc: pm_location_t,
    #[doc = " SingletonClassNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " SingletonClassNode#expression"]
    pub expression: *mut pm_node,
    #[doc = " SingletonClassNode#body"]
    pub body: *mut pm_node,
    #[doc = " SingletonClassNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_singleton_class_node"]
        [::std::mem::size_of::<pm_singleton_class_node>() - 112usize];
    ["Alignment of pm_singleton_class_node"]
        [::std::mem::align_of::<pm_singleton_class_node>() - 8usize];
    ["Offset of field: pm_singleton_class_node::base"]
        [::std::mem::offset_of!(pm_singleton_class_node, base) - 0usize];
    ["Offset of field: pm_singleton_class_node::locals"]
        [::std::mem::offset_of!(pm_singleton_class_node, locals) - 24usize];
    ["Offset of field: pm_singleton_class_node::class_keyword_loc"]
        [::std::mem::offset_of!(pm_singleton_class_node, class_keyword_loc) - 48usize];
    ["Offset of field: pm_singleton_class_node::operator_loc"]
        [::std::mem::offset_of!(pm_singleton_class_node, operator_loc) - 64usize];
    ["Offset of field: pm_singleton_class_node::expression"]
        [::std::mem::offset_of!(pm_singleton_class_node, expression) - 80usize];
    ["Offset of field: pm_singleton_class_node::body"]
        [::std::mem::offset_of!(pm_singleton_class_node, body) - 88usize];
    ["Offset of field: pm_singleton_class_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_singleton_class_node, end_keyword_loc) - 96usize];
};
#[doc = " SingletonClassNode\n\n Represents a singleton class declaration involving the `class` keyword.\n\n     class << self end\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_SINGLETON_CLASS_NODE\n\n @extends pm_node_t"]
pub type pm_singleton_class_node_t = pm_singleton_class_node;
#[doc = " SourceEncodingNode\n\n Represents the use of the `__ENCODING__` keyword.\n\n     __ENCODING__\n     ^^^^^^^^^^^^\n\n Type: ::PM_SOURCE_ENCODING_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_source_encoding_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_source_encoding_node"][::std::mem::size_of::<pm_source_encoding_node>() - 24usize];
    ["Alignment of pm_source_encoding_node"]
        [::std::mem::align_of::<pm_source_encoding_node>() - 8usize];
    ["Offset of field: pm_source_encoding_node::base"]
        [::std::mem::offset_of!(pm_source_encoding_node, base) - 0usize];
};
#[doc = " SourceEncodingNode\n\n Represents the use of the `__ENCODING__` keyword.\n\n     __ENCODING__\n     ^^^^^^^^^^^^\n\n Type: ::PM_SOURCE_ENCODING_NODE\n\n @extends pm_node_t"]
pub type pm_source_encoding_node_t = pm_source_encoding_node;
#[doc = " SourceFileNode\n\n Represents the use of the `__FILE__` keyword.\n\n     __FILE__\n     ^^^^^^^^\n\n Type: ::PM_SOURCE_FILE_NODE\n\n Flags (#pm_string_flags):\n * ::PM_STRING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_STRING_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_STRING_FLAGS_FROZEN\n * ::PM_STRING_FLAGS_MUTABLE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_source_file_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SourceFileNode#filepath\n\n Represents the file path being parsed. This corresponds directly to the `filepath` option given to the various `Prism::parse*` APIs."]
    pub filepath: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_source_file_node"][::std::mem::size_of::<pm_source_file_node>() - 48usize];
    ["Alignment of pm_source_file_node"][::std::mem::align_of::<pm_source_file_node>() - 8usize];
    ["Offset of field: pm_source_file_node::base"]
        [::std::mem::offset_of!(pm_source_file_node, base) - 0usize];
    ["Offset of field: pm_source_file_node::filepath"]
        [::std::mem::offset_of!(pm_source_file_node, filepath) - 24usize];
};
#[doc = " SourceFileNode\n\n Represents the use of the `__FILE__` keyword.\n\n     __FILE__\n     ^^^^^^^^\n\n Type: ::PM_SOURCE_FILE_NODE\n\n Flags (#pm_string_flags):\n * ::PM_STRING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_STRING_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_STRING_FLAGS_FROZEN\n * ::PM_STRING_FLAGS_MUTABLE\n\n @extends pm_node_t"]
pub type pm_source_file_node_t = pm_source_file_node;
#[doc = " SourceLineNode\n\n Represents the use of the `__LINE__` keyword.\n\n     __LINE__\n     ^^^^^^^^\n\n Type: ::PM_SOURCE_LINE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_source_line_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_source_line_node"][::std::mem::size_of::<pm_source_line_node>() - 24usize];
    ["Alignment of pm_source_line_node"][::std::mem::align_of::<pm_source_line_node>() - 8usize];
    ["Offset of field: pm_source_line_node::base"]
        [::std::mem::offset_of!(pm_source_line_node, base) - 0usize];
};
#[doc = " SourceLineNode\n\n Represents the use of the `__LINE__` keyword.\n\n     __LINE__\n     ^^^^^^^^\n\n Type: ::PM_SOURCE_LINE_NODE\n\n @extends pm_node_t"]
pub type pm_source_line_node_t = pm_source_line_node;
#[doc = " SplatNode\n\n Represents the use of the splat operator.\n\n     [*a]\n      ^^\n\n Type: ::PM_SPLAT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_splat_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SplatNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " SplatNode#expression"]
    pub expression: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_splat_node"][::std::mem::size_of::<pm_splat_node>() - 48usize];
    ["Alignment of pm_splat_node"][::std::mem::align_of::<pm_splat_node>() - 8usize];
    ["Offset of field: pm_splat_node::base"][::std::mem::offset_of!(pm_splat_node, base) - 0usize];
    ["Offset of field: pm_splat_node::operator_loc"]
        [::std::mem::offset_of!(pm_splat_node, operator_loc) - 24usize];
    ["Offset of field: pm_splat_node::expression"]
        [::std::mem::offset_of!(pm_splat_node, expression) - 40usize];
};
#[doc = " SplatNode\n\n Represents the use of the splat operator.\n\n     [*a]\n      ^^\n\n Type: ::PM_SPLAT_NODE\n\n @extends pm_node_t"]
pub type pm_splat_node_t = pm_splat_node;
#[doc = " StatementsNode\n\n Represents a set of statements contained within some scope.\n\n     foo; bar; baz\n     ^^^^^^^^^^^^^\n\n Type: ::PM_STATEMENTS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_statements_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " StatementsNode#body"]
    pub body: pm_node_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_statements_node"][::std::mem::size_of::<pm_statements_node>() - 48usize];
    ["Alignment of pm_statements_node"][::std::mem::align_of::<pm_statements_node>() - 8usize];
    ["Offset of field: pm_statements_node::base"]
        [::std::mem::offset_of!(pm_statements_node, base) - 0usize];
    ["Offset of field: pm_statements_node::body"]
        [::std::mem::offset_of!(pm_statements_node, body) - 24usize];
};
#[doc = " StatementsNode\n\n Represents a set of statements contained within some scope.\n\n     foo; bar; baz\n     ^^^^^^^^^^^^^\n\n Type: ::PM_STATEMENTS_NODE\n\n @extends pm_node_t"]
pub type pm_statements_node_t = pm_statements_node;
#[doc = " StringNode\n\n Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.\n\n     \"foo\"\n     ^^^^^\n\n     %w[foo]\n        ^^^\n\n     \"foo #{bar} baz\"\n      ^^^^      ^^^^\n\n Type: ::PM_STRING_NODE\n\n Flags (#pm_string_flags):\n * ::PM_STRING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_STRING_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_STRING_FLAGS_FROZEN\n * ::PM_STRING_FLAGS_MUTABLE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_string_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " StringNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " StringNode#content_loc"]
    pub content_loc: pm_location_t,
    #[doc = " StringNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " StringNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_string_node"][::std::mem::size_of::<pm_string_node>() - 96usize];
    ["Alignment of pm_string_node"][::std::mem::align_of::<pm_string_node>() - 8usize];
    ["Offset of field: pm_string_node::base"]
        [::std::mem::offset_of!(pm_string_node, base) - 0usize];
    ["Offset of field: pm_string_node::opening_loc"]
        [::std::mem::offset_of!(pm_string_node, opening_loc) - 24usize];
    ["Offset of field: pm_string_node::content_loc"]
        [::std::mem::offset_of!(pm_string_node, content_loc) - 40usize];
    ["Offset of field: pm_string_node::closing_loc"]
        [::std::mem::offset_of!(pm_string_node, closing_loc) - 56usize];
    ["Offset of field: pm_string_node::unescaped"]
        [::std::mem::offset_of!(pm_string_node, unescaped) - 72usize];
};
#[doc = " StringNode\n\n Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.\n\n     \"foo\"\n     ^^^^^\n\n     %w[foo]\n        ^^^\n\n     \"foo #{bar} baz\"\n      ^^^^      ^^^^\n\n Type: ::PM_STRING_NODE\n\n Flags (#pm_string_flags):\n * ::PM_STRING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_STRING_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_STRING_FLAGS_FROZEN\n * ::PM_STRING_FLAGS_MUTABLE\n\n @extends pm_node_t"]
pub type pm_string_node_t = pm_string_node;
#[doc = " SuperNode\n\n Represents the use of the `super` keyword with parentheses or arguments.\n\n     super()\n     ^^^^^^^\n\n     super foo, bar\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_SUPER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_super_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SuperNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " SuperNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " SuperNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " SuperNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
    #[doc = " SuperNode#block"]
    pub block: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_super_node"][::std::mem::size_of::<pm_super_node>() - 88usize];
    ["Alignment of pm_super_node"][::std::mem::align_of::<pm_super_node>() - 8usize];
    ["Offset of field: pm_super_node::base"][::std::mem::offset_of!(pm_super_node, base) - 0usize];
    ["Offset of field: pm_super_node::keyword_loc"]
        [::std::mem::offset_of!(pm_super_node, keyword_loc) - 24usize];
    ["Offset of field: pm_super_node::lparen_loc"]
        [::std::mem::offset_of!(pm_super_node, lparen_loc) - 40usize];
    ["Offset of field: pm_super_node::arguments"]
        [::std::mem::offset_of!(pm_super_node, arguments) - 56usize];
    ["Offset of field: pm_super_node::rparen_loc"]
        [::std::mem::offset_of!(pm_super_node, rparen_loc) - 64usize];
    ["Offset of field: pm_super_node::block"]
        [::std::mem::offset_of!(pm_super_node, block) - 80usize];
};
#[doc = " SuperNode\n\n Represents the use of the `super` keyword with parentheses or arguments.\n\n     super()\n     ^^^^^^^\n\n     super foo, bar\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_SUPER_NODE\n\n @extends pm_node_t"]
pub type pm_super_node_t = pm_super_node;
#[doc = " SymbolNode\n\n Represents a symbol literal or a symbol contained within a `%i` list.\n\n     :foo\n     ^^^^\n\n     %i[foo]\n        ^^^\n\n Type: ::PM_SYMBOL_NODE\n\n Flags (#pm_symbol_flags):\n * ::PM_SYMBOL_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_SYMBOL_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_SYMBOL_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_symbol_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SymbolNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " SymbolNode#value_loc"]
    pub value_loc: pm_location_t,
    #[doc = " SymbolNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " SymbolNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_symbol_node"][::std::mem::size_of::<pm_symbol_node>() - 96usize];
    ["Alignment of pm_symbol_node"][::std::mem::align_of::<pm_symbol_node>() - 8usize];
    ["Offset of field: pm_symbol_node::base"]
        [::std::mem::offset_of!(pm_symbol_node, base) - 0usize];
    ["Offset of field: pm_symbol_node::opening_loc"]
        [::std::mem::offset_of!(pm_symbol_node, opening_loc) - 24usize];
    ["Offset of field: pm_symbol_node::value_loc"]
        [::std::mem::offset_of!(pm_symbol_node, value_loc) - 40usize];
    ["Offset of field: pm_symbol_node::closing_loc"]
        [::std::mem::offset_of!(pm_symbol_node, closing_loc) - 56usize];
    ["Offset of field: pm_symbol_node::unescaped"]
        [::std::mem::offset_of!(pm_symbol_node, unescaped) - 72usize];
};
#[doc = " SymbolNode\n\n Represents a symbol literal or a symbol contained within a `%i` list.\n\n     :foo\n     ^^^^\n\n     %i[foo]\n        ^^^\n\n Type: ::PM_SYMBOL_NODE\n\n Flags (#pm_symbol_flags):\n * ::PM_SYMBOL_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_SYMBOL_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_SYMBOL_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_symbol_node_t = pm_symbol_node;
#[doc = " TrueNode\n\n Represents the use of the literal `true` keyword.\n\n     true\n     ^^^^\n\n Type: ::PM_TRUE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_true_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_true_node"][::std::mem::size_of::<pm_true_node>() - 24usize];
    ["Alignment of pm_true_node"][::std::mem::align_of::<pm_true_node>() - 8usize];
    ["Offset of field: pm_true_node::base"][::std::mem::offset_of!(pm_true_node, base) - 0usize];
};
#[doc = " TrueNode\n\n Represents the use of the literal `true` keyword.\n\n     true\n     ^^^^\n\n Type: ::PM_TRUE_NODE\n\n @extends pm_node_t"]
pub type pm_true_node_t = pm_true_node;
#[doc = " UndefNode\n\n Represents the use of the `undef` keyword.\n\n     undef :foo, :bar, :baz\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNDEF_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_undef_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " UndefNode#names"]
    pub names: pm_node_list,
    #[doc = " UndefNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_undef_node"][::std::mem::size_of::<pm_undef_node>() - 64usize];
    ["Alignment of pm_undef_node"][::std::mem::align_of::<pm_undef_node>() - 8usize];
    ["Offset of field: pm_undef_node::base"][::std::mem::offset_of!(pm_undef_node, base) - 0usize];
    ["Offset of field: pm_undef_node::names"]
        [::std::mem::offset_of!(pm_undef_node, names) - 24usize];
    ["Offset of field: pm_undef_node::keyword_loc"]
        [::std::mem::offset_of!(pm_undef_node, keyword_loc) - 48usize];
};
#[doc = " UndefNode\n\n Represents the use of the `undef` keyword.\n\n     undef :foo, :bar, :baz\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNDEF_NODE\n\n @extends pm_node_t"]
pub type pm_undef_node_t = pm_undef_node;
#[doc = " UnlessNode\n\n Represents the use of the `unless` keyword, either in the block form or the modifier form.\n\n     bar unless foo\n     ^^^^^^^^^^^^^^\n\n     unless foo then bar end\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNLESS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_unless_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " UnlessNode#keyword_loc\n\n The location of the `unless` keyword.\n\n     unless cond then bar end\n     ^^^^^^\n\n     bar unless cond\n         ^^^^^^"]
    pub keyword_loc: pm_location_t,
    #[doc = " UnlessNode#predicate\n\n The condition to be evaluated for the unless expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     unless cond then bar end\n            ^^^^\n\n     bar unless cond\n                ^^^^"]
    pub predicate: *mut pm_node,
    #[doc = " UnlessNode#then_keyword_loc\n\n The location of the `then` keyword, if present.\n\n     unless cond then bar end\n                 ^^^^"]
    pub then_keyword_loc: pm_location_t,
    #[doc = " UnlessNode#statements\n\n The body of statements that will executed if the unless condition is\n falsey. Will be `nil` if no body is provided.\n\n     unless cond then bar end\n                      ^^^"]
    pub statements: *mut pm_statements_node,
    #[doc = " UnlessNode#else_clause\n\n The else clause of the unless expression, if present.\n\n     unless cond then bar else baz end\n                          ^^^^^^^^"]
    pub else_clause: *mut pm_else_node,
    #[doc = " UnlessNode#end_keyword_loc\n\n The location of the `end` keyword, if present.\n\n     unless cond then bar end\n                          ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_unless_node"][::std::mem::size_of::<pm_unless_node>() - 96usize];
    ["Alignment of pm_unless_node"][::std::mem::align_of::<pm_unless_node>() - 8usize];
    ["Offset of field: pm_unless_node::base"]
        [::std::mem::offset_of!(pm_unless_node, base) - 0usize];
    ["Offset of field: pm_unless_node::keyword_loc"]
        [::std::mem::offset_of!(pm_unless_node, keyword_loc) - 24usize];
    ["Offset of field: pm_unless_node::predicate"]
        [::std::mem::offset_of!(pm_unless_node, predicate) - 40usize];
    ["Offset of field: pm_unless_node::then_keyword_loc"]
        [::std::mem::offset_of!(pm_unless_node, then_keyword_loc) - 48usize];
    ["Offset of field: pm_unless_node::statements"]
        [::std::mem::offset_of!(pm_unless_node, statements) - 64usize];
    ["Offset of field: pm_unless_node::else_clause"]
        [::std::mem::offset_of!(pm_unless_node, else_clause) - 72usize];
    ["Offset of field: pm_unless_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_unless_node, end_keyword_loc) - 80usize];
};
#[doc = " UnlessNode\n\n Represents the use of the `unless` keyword, either in the block form or the modifier form.\n\n     bar unless foo\n     ^^^^^^^^^^^^^^\n\n     unless foo then bar end\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNLESS_NODE\n\n @extends pm_node_t"]
pub type pm_unless_node_t = pm_unless_node;
#[doc = " UntilNode\n\n Represents the use of the `until` keyword, either in the block form or the modifier form.\n\n     bar until foo\n     ^^^^^^^^^^^^^\n\n     until foo do bar end\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNTIL_NODE\n\n Flags (#pm_loop_flags):\n * ::PM_LOOP_FLAGS_BEGIN_MODIFIER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_until_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " UntilNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " UntilNode#do_keyword_loc"]
    pub do_keyword_loc: pm_location_t,
    #[doc = " UntilNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " UntilNode#predicate"]
    pub predicate: *mut pm_node,
    #[doc = " UntilNode#statements"]
    pub statements: *mut pm_statements_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_until_node"][::std::mem::size_of::<pm_until_node>() - 88usize];
    ["Alignment of pm_until_node"][::std::mem::align_of::<pm_until_node>() - 8usize];
    ["Offset of field: pm_until_node::base"][::std::mem::offset_of!(pm_until_node, base) - 0usize];
    ["Offset of field: pm_until_node::keyword_loc"]
        [::std::mem::offset_of!(pm_until_node, keyword_loc) - 24usize];
    ["Offset of field: pm_until_node::do_keyword_loc"]
        [::std::mem::offset_of!(pm_until_node, do_keyword_loc) - 40usize];
    ["Offset of field: pm_until_node::closing_loc"]
        [::std::mem::offset_of!(pm_until_node, closing_loc) - 56usize];
    ["Offset of field: pm_until_node::predicate"]
        [::std::mem::offset_of!(pm_until_node, predicate) - 72usize];
    ["Offset of field: pm_until_node::statements"]
        [::std::mem::offset_of!(pm_until_node, statements) - 80usize];
};
#[doc = " UntilNode\n\n Represents the use of the `until` keyword, either in the block form or the modifier form.\n\n     bar until foo\n     ^^^^^^^^^^^^^\n\n     until foo do bar end\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNTIL_NODE\n\n Flags (#pm_loop_flags):\n * ::PM_LOOP_FLAGS_BEGIN_MODIFIER\n\n @extends pm_node_t"]
pub type pm_until_node_t = pm_until_node;
#[doc = " WhenNode\n\n Represents the use of the `when` keyword within a case statement.\n\n     case true\n     when true\n     ^^^^^^^^^\n     end\n\n Type: ::PM_WHEN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_when_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " WhenNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " WhenNode#conditions"]
    pub conditions: pm_node_list,
    #[doc = " WhenNode#then_keyword_loc"]
    pub then_keyword_loc: pm_location_t,
    #[doc = " WhenNode#statements"]
    pub statements: *mut pm_statements_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_when_node"][::std::mem::size_of::<pm_when_node>() - 88usize];
    ["Alignment of pm_when_node"][::std::mem::align_of::<pm_when_node>() - 8usize];
    ["Offset of field: pm_when_node::base"][::std::mem::offset_of!(pm_when_node, base) - 0usize];
    ["Offset of field: pm_when_node::keyword_loc"]
        [::std::mem::offset_of!(pm_when_node, keyword_loc) - 24usize];
    ["Offset of field: pm_when_node::conditions"]
        [::std::mem::offset_of!(pm_when_node, conditions) - 40usize];
    ["Offset of field: pm_when_node::then_keyword_loc"]
        [::std::mem::offset_of!(pm_when_node, then_keyword_loc) - 64usize];
    ["Offset of field: pm_when_node::statements"]
        [::std::mem::offset_of!(pm_when_node, statements) - 80usize];
};
#[doc = " WhenNode\n\n Represents the use of the `when` keyword within a case statement.\n\n     case true\n     when true\n     ^^^^^^^^^\n     end\n\n Type: ::PM_WHEN_NODE\n\n @extends pm_node_t"]
pub type pm_when_node_t = pm_when_node;
#[doc = " WhileNode\n\n Represents the use of the `while` keyword, either in the block form or the modifier form.\n\n     bar while foo\n     ^^^^^^^^^^^^^\n\n     while foo do bar end\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_WHILE_NODE\n\n Flags (#pm_loop_flags):\n * ::PM_LOOP_FLAGS_BEGIN_MODIFIER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_while_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " WhileNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " WhileNode#do_keyword_loc"]
    pub do_keyword_loc: pm_location_t,
    #[doc = " WhileNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " WhileNode#predicate"]
    pub predicate: *mut pm_node,
    #[doc = " WhileNode#statements"]
    pub statements: *mut pm_statements_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_while_node"][::std::mem::size_of::<pm_while_node>() - 88usize];
    ["Alignment of pm_while_node"][::std::mem::align_of::<pm_while_node>() - 8usize];
    ["Offset of field: pm_while_node::base"][::std::mem::offset_of!(pm_while_node, base) - 0usize];
    ["Offset of field: pm_while_node::keyword_loc"]
        [::std::mem::offset_of!(pm_while_node, keyword_loc) - 24usize];
    ["Offset of field: pm_while_node::do_keyword_loc"]
        [::std::mem::offset_of!(pm_while_node, do_keyword_loc) - 40usize];
    ["Offset of field: pm_while_node::closing_loc"]
        [::std::mem::offset_of!(pm_while_node, closing_loc) - 56usize];
    ["Offset of field: pm_while_node::predicate"]
        [::std::mem::offset_of!(pm_while_node, predicate) - 72usize];
    ["Offset of field: pm_while_node::statements"]
        [::std::mem::offset_of!(pm_while_node, statements) - 80usize];
};
#[doc = " WhileNode\n\n Represents the use of the `while` keyword, either in the block form or the modifier form.\n\n     bar while foo\n     ^^^^^^^^^^^^^\n\n     while foo do bar end\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_WHILE_NODE\n\n Flags (#pm_loop_flags):\n * ::PM_LOOP_FLAGS_BEGIN_MODIFIER\n\n @extends pm_node_t"]
pub type pm_while_node_t = pm_while_node;
#[doc = " XStringNode\n\n Represents an xstring literal with no interpolation.\n\n     `foo`\n     ^^^^^\n\n Type: ::PM_X_STRING_NODE\n\n Flags (#pm_encoding_flags):\n * ::PM_ENCODING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_ENCODING_FLAGS_FORCED_BINARY_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_x_string_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " XStringNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " XStringNode#content_loc"]
    pub content_loc: pm_location_t,
    #[doc = " XStringNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " XStringNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_x_string_node"][::std::mem::size_of::<pm_x_string_node>() - 96usize];
    ["Alignment of pm_x_string_node"][::std::mem::align_of::<pm_x_string_node>() - 8usize];
    ["Offset of field: pm_x_string_node::base"]
        [::std::mem::offset_of!(pm_x_string_node, base) - 0usize];
    ["Offset of field: pm_x_string_node::opening_loc"]
        [::std::mem::offset_of!(pm_x_string_node, opening_loc) - 24usize];
    ["Offset of field: pm_x_string_node::content_loc"]
        [::std::mem::offset_of!(pm_x_string_node, content_loc) - 40usize];
    ["Offset of field: pm_x_string_node::closing_loc"]
        [::std::mem::offset_of!(pm_x_string_node, closing_loc) - 56usize];
    ["Offset of field: pm_x_string_node::unescaped"]
        [::std::mem::offset_of!(pm_x_string_node, unescaped) - 72usize];
};
#[doc = " XStringNode\n\n Represents an xstring literal with no interpolation.\n\n     `foo`\n     ^^^^^\n\n Type: ::PM_X_STRING_NODE\n\n Flags (#pm_encoding_flags):\n * ::PM_ENCODING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_ENCODING_FLAGS_FORCED_BINARY_ENCODING\n\n @extends pm_node_t"]
pub type pm_x_string_node_t = pm_x_string_node;
#[doc = " YieldNode\n\n Represents the use of the `yield` keyword.\n\n     yield 1\n     ^^^^^^^\n\n Type: ::PM_YIELD_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_yield_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " YieldNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " YieldNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " YieldNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " YieldNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_yield_node"][::std::mem::size_of::<pm_yield_node>() - 80usize];
    ["Alignment of pm_yield_node"][::std::mem::align_of::<pm_yield_node>() - 8usize];
    ["Offset of field: pm_yield_node::base"][::std::mem::offset_of!(pm_yield_node, base) - 0usize];
    ["Offset of field: pm_yield_node::keyword_loc"]
        [::std::mem::offset_of!(pm_yield_node, keyword_loc) - 24usize];
    ["Offset of field: pm_yield_node::lparen_loc"]
        [::std::mem::offset_of!(pm_yield_node, lparen_loc) - 40usize];
    ["Offset of field: pm_yield_node::arguments"]
        [::std::mem::offset_of!(pm_yield_node, arguments) - 56usize];
    ["Offset of field: pm_yield_node::rparen_loc"]
        [::std::mem::offset_of!(pm_yield_node, rparen_loc) - 64usize];
};
#[doc = " YieldNode\n\n Represents the use of the `yield` keyword.\n\n     yield 1\n     ^^^^^^^\n\n Type: ::PM_YIELD_NODE\n\n @extends pm_node_t"]
pub type pm_yield_node_t = pm_yield_node;
#[doc = " if the arguments contain forwarding"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_FORWARDING:
    pm_arguments_node_flags = 4;
#[doc = " if the arguments contain keywords"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORDS:
    pm_arguments_node_flags = 8;
#[doc = " if the arguments contain a keyword splat"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORD_SPLAT:
    pm_arguments_node_flags = 16;
#[doc = " if the arguments contain a splat"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_SPLAT: pm_arguments_node_flags =
    32;
#[doc = " if the arguments contain multiple splats"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_MULTIPLE_SPLATS:
    pm_arguments_node_flags = 64;
#[doc = " Flags for arguments nodes."]
pub type pm_arguments_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for arguments nodes."]
pub use self::pm_arguments_node_flags as pm_arguments_node_flags_t;
#[doc = " if array contains splat nodes"]
pub const pm_array_node_flags_PM_ARRAY_NODE_FLAGS_CONTAINS_SPLAT: pm_array_node_flags = 4;
#[doc = " Flags for array nodes."]
pub type pm_array_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for array nodes."]
pub use self::pm_array_node_flags as pm_array_node_flags_t;
#[doc = " &. operator"]
pub const pm_call_node_flags_PM_CALL_NODE_FLAGS_SAFE_NAVIGATION: pm_call_node_flags = 4;
#[doc = " a call that could have been a local variable"]
pub const pm_call_node_flags_PM_CALL_NODE_FLAGS_VARIABLE_CALL: pm_call_node_flags = 8;
#[doc = " a call that is an attribute write, so the value being written should be returned"]
pub const pm_call_node_flags_PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE: pm_call_node_flags = 16;
#[doc = " a call that ignores method visibility"]
pub const pm_call_node_flags_PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY: pm_call_node_flags = 32;
#[doc = " Flags for call nodes."]
pub type pm_call_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for call nodes."]
pub use self::pm_call_node_flags as pm_call_node_flags_t;
#[doc = " internal bytes forced the encoding to UTF-8"]
pub const pm_encoding_flags_PM_ENCODING_FLAGS_FORCED_UTF8_ENCODING: pm_encoding_flags = 4;
#[doc = " internal bytes forced the encoding to binary"]
pub const pm_encoding_flags_PM_ENCODING_FLAGS_FORCED_BINARY_ENCODING: pm_encoding_flags = 8;
#[doc = " Flags for nodes that have unescaped content."]
pub type pm_encoding_flags = ::std::os::raw::c_uint;
#[doc = " Flags for nodes that have unescaped content."]
pub use self::pm_encoding_flags as pm_encoding_flags_t;
#[doc = " 0b prefix"]
pub const pm_integer_base_flags_PM_INTEGER_BASE_FLAGS_BINARY: pm_integer_base_flags = 4;
#[doc = " 0d or no prefix"]
pub const pm_integer_base_flags_PM_INTEGER_BASE_FLAGS_DECIMAL: pm_integer_base_flags = 8;
#[doc = " 0o or 0 prefix"]
pub const pm_integer_base_flags_PM_INTEGER_BASE_FLAGS_OCTAL: pm_integer_base_flags = 16;
#[doc = " 0x prefix"]
pub const pm_integer_base_flags_PM_INTEGER_BASE_FLAGS_HEXADECIMAL: pm_integer_base_flags = 32;
#[doc = " Flags for integer nodes that correspond to the base of the integer."]
pub type pm_integer_base_flags = ::std::os::raw::c_uint;
#[doc = " Flags for integer nodes that correspond to the base of the integer."]
pub use self::pm_integer_base_flags as pm_integer_base_flags_t;
#[doc = " frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`"]
pub const pm_interpolated_string_node_flags_PM_INTERPOLATED_STRING_NODE_FLAGS_FROZEN:
    pm_interpolated_string_node_flags = 4;
#[doc = " mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`"]
pub const pm_interpolated_string_node_flags_PM_INTERPOLATED_STRING_NODE_FLAGS_MUTABLE:
    pm_interpolated_string_node_flags = 8;
#[doc = " Flags for interpolated string nodes that indicated mutability if they are also marked as literals."]
pub type pm_interpolated_string_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for interpolated string nodes that indicated mutability if they are also marked as literals."]
pub use self::pm_interpolated_string_node_flags as pm_interpolated_string_node_flags_t;
#[doc = " a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments"]
pub const pm_keyword_hash_node_flags_PM_KEYWORD_HASH_NODE_FLAGS_SYMBOL_KEYS:
    pm_keyword_hash_node_flags = 4;
#[doc = " Flags for keyword hash nodes."]
pub type pm_keyword_hash_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for keyword hash nodes."]
pub use self::pm_keyword_hash_node_flags as pm_keyword_hash_node_flags_t;
#[doc = " a loop after a begin statement, so the body is executed first before the condition"]
pub const pm_loop_flags_PM_LOOP_FLAGS_BEGIN_MODIFIER: pm_loop_flags = 4;
#[doc = " Flags for while and until loop nodes."]
pub type pm_loop_flags = ::std::os::raw::c_uint;
#[doc = " Flags for while and until loop nodes."]
pub use self::pm_loop_flags as pm_loop_flags_t;
#[doc = " a parameter name that has been repeated in the method signature"]
pub const pm_parameter_flags_PM_PARAMETER_FLAGS_REPEATED_PARAMETER: pm_parameter_flags = 4;
#[doc = " Flags for parameter nodes."]
pub type pm_parameter_flags = ::std::os::raw::c_uint;
#[doc = " Flags for parameter nodes."]
pub use self::pm_parameter_flags as pm_parameter_flags_t;
#[doc = " parentheses that contain multiple potentially void statements"]
pub const pm_parentheses_node_flags_PM_PARENTHESES_NODE_FLAGS_MULTIPLE_STATEMENTS:
    pm_parentheses_node_flags = 4;
#[doc = " Flags for parentheses nodes."]
pub type pm_parentheses_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for parentheses nodes."]
pub use self::pm_parentheses_node_flags as pm_parentheses_node_flags_t;
#[doc = " ... operator"]
pub const pm_range_flags_PM_RANGE_FLAGS_EXCLUDE_END: pm_range_flags = 4;
#[doc = " Flags for range and flip-flop nodes."]
pub type pm_range_flags = ::std::os::raw::c_uint;
#[doc = " Flags for range and flip-flop nodes."]
pub use self::pm_range_flags as pm_range_flags_t;
#[doc = " i - ignores the case of characters when matching"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE:
    pm_regular_expression_flags = 4;
#[doc = " x - ignores whitespace and allows comments in regular expressions"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_EXTENDED:
    pm_regular_expression_flags = 8;
#[doc = " m - allows $ to match the end of lines within strings"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE:
    pm_regular_expression_flags = 16;
#[doc = " o - only interpolates values into the regular expression once"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_ONCE:
    pm_regular_expression_flags = 32;
#[doc = " e - forces the EUC-JP encoding"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_EUC_JP:
    pm_regular_expression_flags = 64;
#[doc = " n - forces the ASCII-8BIT encoding"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT:
    pm_regular_expression_flags = 128;
#[doc = " s - forces the Windows-31J encoding"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J:
    pm_regular_expression_flags = 256;
#[doc = " u - forces the UTF-8 encoding"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_UTF_8:
    pm_regular_expression_flags = 512;
#[doc = " internal bytes forced the encoding to UTF-8"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING:
    pm_regular_expression_flags = 1024;
#[doc = " internal bytes forced the encoding to binary"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING:
    pm_regular_expression_flags = 2048;
#[doc = " internal bytes forced the encoding to US-ASCII"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING:
    pm_regular_expression_flags = 4096;
#[doc = " Flags for regular expression and match last line nodes."]
pub type pm_regular_expression_flags = ::std::os::raw::c_uint;
#[doc = " Flags for regular expression and match last line nodes."]
pub use self::pm_regular_expression_flags as pm_regular_expression_flags_t;
#[doc = " constant writes that should be modified with shareable constant value literal"]
pub const pm_shareable_constant_node_flags_PM_SHAREABLE_CONSTANT_NODE_FLAGS_LITERAL:
    pm_shareable_constant_node_flags = 4;
#[doc = " constant writes that should be modified with shareable constant value experimental everything"]
pub const pm_shareable_constant_node_flags_PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_EVERYTHING : pm_shareable_constant_node_flags = 8 ;
#[doc = " constant writes that should be modified with shareable constant value experimental copy"]
pub const pm_shareable_constant_node_flags_PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_COPY:
    pm_shareable_constant_node_flags = 16;
#[doc = " Flags for shareable constant nodes."]
pub type pm_shareable_constant_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for shareable constant nodes."]
pub use self::pm_shareable_constant_node_flags as pm_shareable_constant_node_flags_t;
#[doc = " internal bytes forced the encoding to UTF-8"]
pub const pm_string_flags_PM_STRING_FLAGS_FORCED_UTF8_ENCODING: pm_string_flags = 4;
#[doc = " internal bytes forced the encoding to binary"]
pub const pm_string_flags_PM_STRING_FLAGS_FORCED_BINARY_ENCODING: pm_string_flags = 8;
#[doc = " frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`"]
pub const pm_string_flags_PM_STRING_FLAGS_FROZEN: pm_string_flags = 16;
#[doc = " mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`"]
pub const pm_string_flags_PM_STRING_FLAGS_MUTABLE: pm_string_flags = 32;
#[doc = " Flags for string nodes."]
pub type pm_string_flags = ::std::os::raw::c_uint;
#[doc = " Flags for string nodes."]
pub use self::pm_string_flags as pm_string_flags_t;
#[doc = " internal bytes forced the encoding to UTF-8"]
pub const pm_symbol_flags_PM_SYMBOL_FLAGS_FORCED_UTF8_ENCODING: pm_symbol_flags = 4;
#[doc = " internal bytes forced the encoding to binary"]
pub const pm_symbol_flags_PM_SYMBOL_FLAGS_FORCED_BINARY_ENCODING: pm_symbol_flags = 8;
#[doc = " internal bytes forced the encoding to US-ASCII"]
pub const pm_symbol_flags_PM_SYMBOL_FLAGS_FORCED_US_ASCII_ENCODING: pm_symbol_flags = 16;
#[doc = " Flags for symbol nodes."]
pub type pm_symbol_flags = ::std::os::raw::c_uint;
#[doc = " Flags for symbol nodes."]
pub use self::pm_symbol_flags as pm_symbol_flags_t;
#[doc = " This struct represents an abstract linked list that provides common\n functionality. It is meant to be used any time a linked list is necessary to\n store data.\n\n The linked list itself operates off a set of pointers. Because the pointers\n are not necessarily sequential, they can be of any size. We use this fact to\n allow the consumer of this linked list to extend the node struct to include\n any data they want. This is done by using the pm_list_node_t as the first\n member of the struct.\n\n For example, if we want to store a list of integers, we can do the following:\n\n ```c\n typedef struct {\n     pm_list_node_t node;\n     int value;\n } pm_int_node_t;\n\n pm_list_t list = { 0 };\n pm_int_node_t *node = xmalloc(sizeof(pm_int_node_t));\n node->value = 5;\n\n pm_list_append(&list, &node->node);\n ```\n\n The pm_list_t struct is used to represent the overall linked list. It\n contains a pointer to the head and tail of the list. This allows for easy\n iteration and appending of new nodes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_list_node {
    #[doc = " A pointer to the next node in the list."]
    pub next: *mut pm_list_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_list_node"][::std::mem::size_of::<pm_list_node>() - 8usize];
    ["Alignment of pm_list_node"][::std::mem::align_of::<pm_list_node>() - 8usize];
    ["Offset of field: pm_list_node::next"][::std::mem::offset_of!(pm_list_node, next) - 0usize];
};
#[doc = " This struct represents an abstract linked list that provides common\n functionality. It is meant to be used any time a linked list is necessary to\n store data.\n\n The linked list itself operates off a set of pointers. Because the pointers\n are not necessarily sequential, they can be of any size. We use this fact to\n allow the consumer of this linked list to extend the node struct to include\n any data they want. This is done by using the pm_list_node_t as the first\n member of the struct.\n\n For example, if we want to store a list of integers, we can do the following:\n\n ```c\n typedef struct {\n     pm_list_node_t node;\n     int value;\n } pm_int_node_t;\n\n pm_list_t list = { 0 };\n pm_int_node_t *node = xmalloc(sizeof(pm_int_node_t));\n node->value = 5;\n\n pm_list_append(&list, &node->node);\n ```\n\n The pm_list_t struct is used to represent the overall linked list. It\n contains a pointer to the head and tail of the list. This allows for easy\n iteration and appending of new nodes."]
pub type pm_list_node_t = pm_list_node;
#[doc = " This represents the overall linked list. It keeps a pointer to the head and\n tail so that iteration is easy and pushing new nodes is easy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_list_t {
    #[doc = " The size of the list."]
    pub size: usize,
    #[doc = " A pointer to the head of the list."]
    pub head: *mut pm_list_node_t,
    #[doc = " A pointer to the tail of the list."]
    pub tail: *mut pm_list_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_list_t"][::std::mem::size_of::<pm_list_t>() - 24usize];
    ["Alignment of pm_list_t"][::std::mem::align_of::<pm_list_t>() - 8usize];
    ["Offset of field: pm_list_t::size"][::std::mem::offset_of!(pm_list_t, size) - 0usize];
    ["Offset of field: pm_list_t::head"][::std::mem::offset_of!(pm_list_t, head) - 8usize];
    ["Offset of field: pm_list_t::tail"][::std::mem::offset_of!(pm_list_t, tail) - 16usize];
};
unsafe extern "C" {
    #[doc = " Returns true if the given list is empty.\n\n @param list The list to check.\n @return True if the given list is empty, otherwise false."]
    pub fn pm_list_empty_p(list: *mut pm_list_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns the size of the list.\n\n @param list The list to check.\n @return The size of the list."]
    pub fn pm_list_size(list: *mut pm_list_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Append a node to the given list.\n\n @param list The list to append to.\n @param node The node to append."]
    pub fn pm_list_append(list: *mut pm_list_t, node: *mut pm_list_node_t);
}
unsafe extern "C" {
    #[doc = " Deallocate the internal state of the given list.\n\n @param list The list to free."]
    pub fn pm_list_free(list: *mut pm_list_t);
}
pub const pm_diagnostic_id_t_PM_ERR_ALIAS_ARGUMENT: pm_diagnostic_id_t = 0;
pub const pm_diagnostic_id_t_PM_ERR_ALIAS_ARGUMENT_NUMBERED_REFERENCE: pm_diagnostic_id_t = 1;
pub const pm_diagnostic_id_t_PM_ERR_AMPAMPEQ_MULTI_ASSIGN: pm_diagnostic_id_t = 2;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_AFTER_BLOCK: pm_diagnostic_id_t = 3;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_AFTER_FORWARDING_ELLIPSES: pm_diagnostic_id_t = 4;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_BARE_HASH: pm_diagnostic_id_t = 5;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_BLOCK_FORWARDING: pm_diagnostic_id_t = 6;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_BLOCK_MULTI: pm_diagnostic_id_t = 7;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_CONFLICT_AMPERSAND: pm_diagnostic_id_t = 8;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_CONFLICT_STAR: pm_diagnostic_id_t = 9;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_CONFLICT_STAR_STAR: pm_diagnostic_id_t = 10;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORMAL_CLASS: pm_diagnostic_id_t = 11;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORMAL_CONSTANT: pm_diagnostic_id_t = 12;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORMAL_GLOBAL: pm_diagnostic_id_t = 13;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORMAL_IVAR: pm_diagnostic_id_t = 14;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORWARDING_UNBOUND: pm_diagnostic_id_t = 15;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_NO_FORWARDING_AMPERSAND: pm_diagnostic_id_t = 16;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_NO_FORWARDING_ELLIPSES: pm_diagnostic_id_t = 17;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_NO_FORWARDING_STAR: pm_diagnostic_id_t = 18;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_NO_FORWARDING_STAR_STAR: pm_diagnostic_id_t = 19;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_SPLAT_AFTER_ASSOC_SPLAT: pm_diagnostic_id_t = 20;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_SPLAT_AFTER_SPLAT: pm_diagnostic_id_t = 21;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_TERM_PAREN: pm_diagnostic_id_t = 22;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_UNEXPECTED_BLOCK: pm_diagnostic_id_t = 23;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_ELEMENT: pm_diagnostic_id_t = 24;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_EXPRESSION: pm_diagnostic_id_t = 25;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_EXPRESSION_AFTER_STAR: pm_diagnostic_id_t = 26;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_SEPARATOR: pm_diagnostic_id_t = 27;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_TERM: pm_diagnostic_id_t = 28;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_LONELY_ELSE: pm_diagnostic_id_t = 29;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_TERM: pm_diagnostic_id_t = 30;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_UPCASE_BRACE: pm_diagnostic_id_t = 31;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_UPCASE_TERM: pm_diagnostic_id_t = 32;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_UPCASE_TOPLEVEL: pm_diagnostic_id_t = 33;
pub const pm_diagnostic_id_t_PM_ERR_BLOCK_PARAM_LOCAL_VARIABLE: pm_diagnostic_id_t = 34;
pub const pm_diagnostic_id_t_PM_ERR_BLOCK_PARAM_PIPE_TERM: pm_diagnostic_id_t = 35;
pub const pm_diagnostic_id_t_PM_ERR_BLOCK_TERM_BRACE: pm_diagnostic_id_t = 36;
pub const pm_diagnostic_id_t_PM_ERR_BLOCK_TERM_END: pm_diagnostic_id_t = 37;
pub const pm_diagnostic_id_t_PM_ERR_CANNOT_PARSE_EXPRESSION: pm_diagnostic_id_t = 38;
pub const pm_diagnostic_id_t_PM_ERR_CANNOT_PARSE_STRING_PART: pm_diagnostic_id_t = 39;
pub const pm_diagnostic_id_t_PM_ERR_CASE_EXPRESSION_AFTER_CASE: pm_diagnostic_id_t = 40;
pub const pm_diagnostic_id_t_PM_ERR_CASE_EXPRESSION_AFTER_WHEN: pm_diagnostic_id_t = 41;
pub const pm_diagnostic_id_t_PM_ERR_CASE_MATCH_MISSING_PREDICATE: pm_diagnostic_id_t = 42;
pub const pm_diagnostic_id_t_PM_ERR_CASE_MISSING_CONDITIONS: pm_diagnostic_id_t = 43;
pub const pm_diagnostic_id_t_PM_ERR_CASE_TERM: pm_diagnostic_id_t = 44;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_IN_METHOD: pm_diagnostic_id_t = 45;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_NAME: pm_diagnostic_id_t = 46;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_SUPERCLASS: pm_diagnostic_id_t = 47;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_TERM: pm_diagnostic_id_t = 48;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_UNEXPECTED_END: pm_diagnostic_id_t = 49;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_VARIABLE_BARE: pm_diagnostic_id_t = 50;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_ELSIF_PREDICATE: pm_diagnostic_id_t = 51;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_IF_PREDICATE: pm_diagnostic_id_t = 52;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_PREDICATE_TERM: pm_diagnostic_id_t = 53;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_TERM: pm_diagnostic_id_t = 54;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_TERM_ELSE: pm_diagnostic_id_t = 55;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_UNLESS_PREDICATE: pm_diagnostic_id_t = 56;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_UNTIL_PREDICATE: pm_diagnostic_id_t = 57;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_WHILE_PREDICATE: pm_diagnostic_id_t = 58;
pub const pm_diagnostic_id_t_PM_ERR_CONSTANT_PATH_COLON_COLON_CONSTANT: pm_diagnostic_id_t = 59;
pub const pm_diagnostic_id_t_PM_ERR_DEF_ENDLESS: pm_diagnostic_id_t = 60;
pub const pm_diagnostic_id_t_PM_ERR_DEF_ENDLESS_SETTER: pm_diagnostic_id_t = 61;
pub const pm_diagnostic_id_t_PM_ERR_DEF_NAME: pm_diagnostic_id_t = 62;
pub const pm_diagnostic_id_t_PM_ERR_DEF_PARAMS_TERM: pm_diagnostic_id_t = 63;
pub const pm_diagnostic_id_t_PM_ERR_DEF_PARAMS_TERM_PAREN: pm_diagnostic_id_t = 64;
pub const pm_diagnostic_id_t_PM_ERR_DEF_RECEIVER: pm_diagnostic_id_t = 65;
pub const pm_diagnostic_id_t_PM_ERR_DEF_RECEIVER_TERM: pm_diagnostic_id_t = 66;
pub const pm_diagnostic_id_t_PM_ERR_DEF_TERM: pm_diagnostic_id_t = 67;
pub const pm_diagnostic_id_t_PM_ERR_DEFINED_EXPRESSION: pm_diagnostic_id_t = 68;
pub const pm_diagnostic_id_t_PM_ERR_EMBDOC_TERM: pm_diagnostic_id_t = 69;
pub const pm_diagnostic_id_t_PM_ERR_EMBEXPR_END: pm_diagnostic_id_t = 70;
pub const pm_diagnostic_id_t_PM_ERR_EMBVAR_INVALID: pm_diagnostic_id_t = 71;
pub const pm_diagnostic_id_t_PM_ERR_END_UPCASE_BRACE: pm_diagnostic_id_t = 72;
pub const pm_diagnostic_id_t_PM_ERR_END_UPCASE_TERM: pm_diagnostic_id_t = 73;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_CONTROL: pm_diagnostic_id_t = 74;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_CONTROL_REPEAT: pm_diagnostic_id_t = 75;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_HEXADECIMAL: pm_diagnostic_id_t = 76;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_META: pm_diagnostic_id_t = 77;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_META_REPEAT: pm_diagnostic_id_t = 78;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE: pm_diagnostic_id_t = 79;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_CM_FLAGS: pm_diagnostic_id_t = 80;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_LIST: pm_diagnostic_id_t = 81;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_LITERAL: pm_diagnostic_id_t = 82;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_LONG: pm_diagnostic_id_t = 83;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_SHORT: pm_diagnostic_id_t = 84;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_TERM: pm_diagnostic_id_t = 85;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_ARGUMENT: pm_diagnostic_id_t = 86;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EOL_AFTER_STATEMENT: pm_diagnostic_id_t = 87;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_AMPAMPEQ: pm_diagnostic_id_t = 88;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_COMMA: pm_diagnostic_id_t = 89;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_EQUAL: pm_diagnostic_id_t = 90;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_LESS_LESS: pm_diagnostic_id_t = 91;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_LPAREN: pm_diagnostic_id_t = 92;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_OPERATOR: pm_diagnostic_id_t = 93;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_PIPEPIPEEQ: pm_diagnostic_id_t = 94;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_QUESTION: pm_diagnostic_id_t = 95;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_SPLAT: pm_diagnostic_id_t = 96;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_SPLAT_HASH: pm_diagnostic_id_t = 97;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_STAR: pm_diagnostic_id_t = 98;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_FOR_DELIMITER: pm_diagnostic_id_t = 99;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_IDENT_REQ_PARAMETER: pm_diagnostic_id_t = 100;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_IN_DELIMITER: pm_diagnostic_id_t = 101;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_LPAREN_REQ_PARAMETER: pm_diagnostic_id_t = 102;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_MESSAGE: pm_diagnostic_id_t = 103;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_RBRACKET: pm_diagnostic_id_t = 104;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_RPAREN: pm_diagnostic_id_t = 105;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_RPAREN_AFTER_MULTI: pm_diagnostic_id_t = 106;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_RPAREN_REQ_PARAMETER: pm_diagnostic_id_t = 107;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_SINGLETON_CLASS_DELIMITER: pm_diagnostic_id_t = 108;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_STRING_CONTENT: pm_diagnostic_id_t = 109;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_WHEN_DELIMITER: pm_diagnostic_id_t = 110;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_BARE_HASH: pm_diagnostic_id_t = 111;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE: pm_diagnostic_id_t = 112;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_ENCODING: pm_diagnostic_id_t = 113;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_FALSE: pm_diagnostic_id_t = 114;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_FILE: pm_diagnostic_id_t = 115;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_LINE: pm_diagnostic_id_t = 116;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_NIL: pm_diagnostic_id_t = 117;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_NUMBERED: pm_diagnostic_id_t = 118;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_SELF: pm_diagnostic_id_t = 119;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_TRUE: pm_diagnostic_id_t = 120;
pub const pm_diagnostic_id_t_PM_ERR_FLOAT_PARSE: pm_diagnostic_id_t = 121;
pub const pm_diagnostic_id_t_PM_ERR_FOR_COLLECTION: pm_diagnostic_id_t = 122;
pub const pm_diagnostic_id_t_PM_ERR_FOR_IN: pm_diagnostic_id_t = 123;
pub const pm_diagnostic_id_t_PM_ERR_FOR_INDEX: pm_diagnostic_id_t = 124;
pub const pm_diagnostic_id_t_PM_ERR_FOR_TERM: pm_diagnostic_id_t = 125;
pub const pm_diagnostic_id_t_PM_ERR_GLOBAL_VARIABLE_BARE: pm_diagnostic_id_t = 126;
pub const pm_diagnostic_id_t_PM_ERR_HASH_EXPRESSION_AFTER_LABEL: pm_diagnostic_id_t = 127;
pub const pm_diagnostic_id_t_PM_ERR_HASH_KEY: pm_diagnostic_id_t = 128;
pub const pm_diagnostic_id_t_PM_ERR_HASH_ROCKET: pm_diagnostic_id_t = 129;
pub const pm_diagnostic_id_t_PM_ERR_HASH_TERM: pm_diagnostic_id_t = 130;
pub const pm_diagnostic_id_t_PM_ERR_HASH_VALUE: pm_diagnostic_id_t = 131;
pub const pm_diagnostic_id_t_PM_ERR_HEREDOC_IDENTIFIER: pm_diagnostic_id_t = 132;
pub const pm_diagnostic_id_t_PM_ERR_HEREDOC_TERM: pm_diagnostic_id_t = 133;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_QUESTION_MARK: pm_diagnostic_id_t = 134;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_VARIABLE_CLASS: pm_diagnostic_id_t = 135;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_VARIABLE_CLASS_3_3: pm_diagnostic_id_t = 136;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_VARIABLE_INSTANCE: pm_diagnostic_id_t = 137;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_VARIABLE_INSTANCE_3_3: pm_diagnostic_id_t = 138;
pub const pm_diagnostic_id_t_PM_ERR_INSTANCE_VARIABLE_BARE: pm_diagnostic_id_t = 139;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_BLOCK_EXIT: pm_diagnostic_id_t = 140;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_CHARACTER: pm_diagnostic_id_t = 141;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_COMMA: pm_diagnostic_id_t = 142;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_ENCODING_MAGIC_COMMENT: pm_diagnostic_id_t = 143;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_ESCAPE_CHARACTER: pm_diagnostic_id_t = 144;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_FLOAT_EXPONENT: pm_diagnostic_id_t = 145;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_LOCAL_VARIABLE_READ: pm_diagnostic_id_t = 146;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_LOCAL_VARIABLE_WRITE: pm_diagnostic_id_t = 147;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_MULTIBYTE_CHAR: pm_diagnostic_id_t = 148;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_MULTIBYTE_CHARACTER: pm_diagnostic_id_t = 149;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_MULTIBYTE_ESCAPE: pm_diagnostic_id_t = 150;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_BINARY: pm_diagnostic_id_t = 151;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_DECIMAL: pm_diagnostic_id_t = 152;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_FRACTION: pm_diagnostic_id_t = 153;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_HEXADECIMAL: pm_diagnostic_id_t = 154;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_OCTAL: pm_diagnostic_id_t = 155;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_UNDERSCORE_INNER: pm_diagnostic_id_t = 156;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_UNDERSCORE_TRAILING: pm_diagnostic_id_t = 157;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_PERCENT: pm_diagnostic_id_t = 158;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_PERCENT_EOF: pm_diagnostic_id_t = 159;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_PRINTABLE_CHARACTER: pm_diagnostic_id_t = 160;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_RETRY_AFTER_ELSE: pm_diagnostic_id_t = 161;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_RETRY_AFTER_ENSURE: pm_diagnostic_id_t = 162;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_RETRY_WITHOUT_RESCUE: pm_diagnostic_id_t = 163;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_SYMBOL: pm_diagnostic_id_t = 164;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_VARIABLE_GLOBAL: pm_diagnostic_id_t = 165;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_VARIABLE_GLOBAL_3_3: pm_diagnostic_id_t = 166;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_YIELD: pm_diagnostic_id_t = 167;
pub const pm_diagnostic_id_t_PM_ERR_IT_NOT_ALLOWED_NUMBERED: pm_diagnostic_id_t = 168;
pub const pm_diagnostic_id_t_PM_ERR_IT_NOT_ALLOWED_ORDINARY: pm_diagnostic_id_t = 169;
pub const pm_diagnostic_id_t_PM_ERR_LAMBDA_OPEN: pm_diagnostic_id_t = 170;
pub const pm_diagnostic_id_t_PM_ERR_LAMBDA_TERM_BRACE: pm_diagnostic_id_t = 171;
pub const pm_diagnostic_id_t_PM_ERR_LAMBDA_TERM_END: pm_diagnostic_id_t = 172;
pub const pm_diagnostic_id_t_PM_ERR_LIST_I_LOWER_ELEMENT: pm_diagnostic_id_t = 173;
pub const pm_diagnostic_id_t_PM_ERR_LIST_I_LOWER_TERM: pm_diagnostic_id_t = 174;
pub const pm_diagnostic_id_t_PM_ERR_LIST_I_UPPER_ELEMENT: pm_diagnostic_id_t = 175;
pub const pm_diagnostic_id_t_PM_ERR_LIST_I_UPPER_TERM: pm_diagnostic_id_t = 176;
pub const pm_diagnostic_id_t_PM_ERR_LIST_W_LOWER_ELEMENT: pm_diagnostic_id_t = 177;
pub const pm_diagnostic_id_t_PM_ERR_LIST_W_LOWER_TERM: pm_diagnostic_id_t = 178;
pub const pm_diagnostic_id_t_PM_ERR_LIST_W_UPPER_ELEMENT: pm_diagnostic_id_t = 179;
pub const pm_diagnostic_id_t_PM_ERR_LIST_W_UPPER_TERM: pm_diagnostic_id_t = 180;
pub const pm_diagnostic_id_t_PM_ERR_MALLOC_FAILED: pm_diagnostic_id_t = 181;
pub const pm_diagnostic_id_t_PM_ERR_MIXED_ENCODING: pm_diagnostic_id_t = 182;
pub const pm_diagnostic_id_t_PM_ERR_MODULE_IN_METHOD: pm_diagnostic_id_t = 183;
pub const pm_diagnostic_id_t_PM_ERR_MODULE_NAME: pm_diagnostic_id_t = 184;
pub const pm_diagnostic_id_t_PM_ERR_MODULE_TERM: pm_diagnostic_id_t = 185;
pub const pm_diagnostic_id_t_PM_ERR_MULTI_ASSIGN_MULTI_SPLATS: pm_diagnostic_id_t = 186;
pub const pm_diagnostic_id_t_PM_ERR_MULTI_ASSIGN_UNEXPECTED_REST: pm_diagnostic_id_t = 187;
pub const pm_diagnostic_id_t_PM_ERR_NESTING_TOO_DEEP: pm_diagnostic_id_t = 188;
pub const pm_diagnostic_id_t_PM_ERR_NO_LOCAL_VARIABLE: pm_diagnostic_id_t = 189;
pub const pm_diagnostic_id_t_PM_ERR_NON_ASSOCIATIVE_OPERATOR: pm_diagnostic_id_t = 190;
pub const pm_diagnostic_id_t_PM_ERR_NOT_EXPRESSION: pm_diagnostic_id_t = 191;
pub const pm_diagnostic_id_t_PM_ERR_NUMBER_LITERAL_UNDERSCORE: pm_diagnostic_id_t = 192;
pub const pm_diagnostic_id_t_PM_ERR_NUMBERED_PARAMETER_INNER_BLOCK: pm_diagnostic_id_t = 193;
pub const pm_diagnostic_id_t_PM_ERR_NUMBERED_PARAMETER_IT: pm_diagnostic_id_t = 194;
pub const pm_diagnostic_id_t_PM_ERR_NUMBERED_PARAMETER_ORDINARY: pm_diagnostic_id_t = 195;
pub const pm_diagnostic_id_t_PM_ERR_NUMBERED_PARAMETER_OUTER_BLOCK: pm_diagnostic_id_t = 196;
pub const pm_diagnostic_id_t_PM_ERR_OPERATOR_MULTI_ASSIGN: pm_diagnostic_id_t = 197;
pub const pm_diagnostic_id_t_PM_ERR_OPERATOR_WRITE_ARGUMENTS: pm_diagnostic_id_t = 198;
pub const pm_diagnostic_id_t_PM_ERR_OPERATOR_WRITE_BLOCK: pm_diagnostic_id_t = 199;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_ASSOC_SPLAT_MULTI: pm_diagnostic_id_t = 200;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_BLOCK_MULTI: pm_diagnostic_id_t = 201;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_CIRCULAR: pm_diagnostic_id_t = 202;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_FORWARDING_AFTER_REST: pm_diagnostic_id_t = 203;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_METHOD_NAME: pm_diagnostic_id_t = 204;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_NAME_DUPLICATED: pm_diagnostic_id_t = 205;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_NO_DEFAULT: pm_diagnostic_id_t = 206;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_NO_DEFAULT_KW: pm_diagnostic_id_t = 207;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_NUMBERED_RESERVED: pm_diagnostic_id_t = 208;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_ORDER: pm_diagnostic_id_t = 209;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_SPLAT_MULTI: pm_diagnostic_id_t = 210;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_STAR: pm_diagnostic_id_t = 211;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_UNEXPECTED_FWD: pm_diagnostic_id_t = 212;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_UNEXPECTED_NO_KW: pm_diagnostic_id_t = 213;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_WILD_LOOSE_COMMA: pm_diagnostic_id_t = 214;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_ARRAY_MULTIPLE_RESTS: pm_diagnostic_id_t = 215;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_CAPTURE_DUPLICATE: pm_diagnostic_id_t = 216;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_BRACKET: pm_diagnostic_id_t = 217;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_COMMA: pm_diagnostic_id_t = 218;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_HROCKET: pm_diagnostic_id_t = 219;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_IN: pm_diagnostic_id_t = 220;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_KEY: pm_diagnostic_id_t = 221;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_PAREN: pm_diagnostic_id_t = 222;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_PIN: pm_diagnostic_id_t = 223;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_PIPE: pm_diagnostic_id_t = 224;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_RANGE: pm_diagnostic_id_t = 225;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_REST: pm_diagnostic_id_t = 226;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_FIND_MISSING_INNER: pm_diagnostic_id_t = 227;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_IMPLICIT: pm_diagnostic_id_t = 228;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY: pm_diagnostic_id_t = 229;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY_DUPLICATE: pm_diagnostic_id_t = 230;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY_INTERPOLATED: pm_diagnostic_id_t = 231;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY_LABEL: pm_diagnostic_id_t = 232;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY_LOCALS: pm_diagnostic_id_t = 233;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_IDENT_AFTER_HROCKET: pm_diagnostic_id_t = 234;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_LABEL_AFTER_COMMA: pm_diagnostic_id_t = 235;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_REST: pm_diagnostic_id_t = 236;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_TERM_BRACE: pm_diagnostic_id_t = 237;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_TERM_BRACKET: pm_diagnostic_id_t = 238;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_TERM_PAREN: pm_diagnostic_id_t = 239;
pub const pm_diagnostic_id_t_PM_ERR_PIPEPIPEEQ_MULTI_ASSIGN: pm_diagnostic_id_t = 240;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_ENCODING_OPTION_MISMATCH: pm_diagnostic_id_t = 241;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_INCOMPAT_CHAR_ENCODING: pm_diagnostic_id_t = 242;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_INVALID_UNICODE_RANGE: pm_diagnostic_id_t = 243;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_NON_ESCAPED_MBC: pm_diagnostic_id_t = 244;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_PARSE_ERROR: pm_diagnostic_id_t = 245;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_TERM: pm_diagnostic_id_t = 246;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_UNKNOWN_OPTIONS: pm_diagnostic_id_t = 247;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_UTF8_CHAR_NON_UTF8_REGEXP: pm_diagnostic_id_t = 248;
pub const pm_diagnostic_id_t_PM_ERR_RESCUE_EXPRESSION: pm_diagnostic_id_t = 249;
pub const pm_diagnostic_id_t_PM_ERR_RESCUE_MODIFIER_VALUE: pm_diagnostic_id_t = 250;
pub const pm_diagnostic_id_t_PM_ERR_RESCUE_TERM: pm_diagnostic_id_t = 251;
pub const pm_diagnostic_id_t_PM_ERR_RESCUE_VARIABLE: pm_diagnostic_id_t = 252;
pub const pm_diagnostic_id_t_PM_ERR_RETURN_INVALID: pm_diagnostic_id_t = 253;
pub const pm_diagnostic_id_t_PM_ERR_SCRIPT_NOT_FOUND: pm_diagnostic_id_t = 254;
pub const pm_diagnostic_id_t_PM_ERR_SINGLETON_FOR_LITERALS: pm_diagnostic_id_t = 255;
pub const pm_diagnostic_id_t_PM_ERR_STATEMENT_ALIAS: pm_diagnostic_id_t = 256;
pub const pm_diagnostic_id_t_PM_ERR_STATEMENT_POSTEXE_END: pm_diagnostic_id_t = 257;
pub const pm_diagnostic_id_t_PM_ERR_STATEMENT_PREEXE_BEGIN: pm_diagnostic_id_t = 258;
pub const pm_diagnostic_id_t_PM_ERR_STATEMENT_UNDEF: pm_diagnostic_id_t = 259;
pub const pm_diagnostic_id_t_PM_ERR_STRING_CONCATENATION: pm_diagnostic_id_t = 260;
pub const pm_diagnostic_id_t_PM_ERR_STRING_INTERPOLATED_TERM: pm_diagnostic_id_t = 261;
pub const pm_diagnostic_id_t_PM_ERR_STRING_LITERAL_EOF: pm_diagnostic_id_t = 262;
pub const pm_diagnostic_id_t_PM_ERR_STRING_LITERAL_TERM: pm_diagnostic_id_t = 263;
pub const pm_diagnostic_id_t_PM_ERR_SYMBOL_INVALID: pm_diagnostic_id_t = 264;
pub const pm_diagnostic_id_t_PM_ERR_SYMBOL_TERM_DYNAMIC: pm_diagnostic_id_t = 265;
pub const pm_diagnostic_id_t_PM_ERR_SYMBOL_TERM_INTERPOLATED: pm_diagnostic_id_t = 266;
pub const pm_diagnostic_id_t_PM_ERR_TERNARY_COLON: pm_diagnostic_id_t = 267;
pub const pm_diagnostic_id_t_PM_ERR_TERNARY_EXPRESSION_FALSE: pm_diagnostic_id_t = 268;
pub const pm_diagnostic_id_t_PM_ERR_TERNARY_EXPRESSION_TRUE: pm_diagnostic_id_t = 269;
pub const pm_diagnostic_id_t_PM_ERR_UNARY_DISALLOWED: pm_diagnostic_id_t = 270;
pub const pm_diagnostic_id_t_PM_ERR_UNARY_RECEIVER: pm_diagnostic_id_t = 271;
pub const pm_diagnostic_id_t_PM_ERR_UNDEF_ARGUMENT: pm_diagnostic_id_t = 272;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_BLOCK_ARGUMENT: pm_diagnostic_id_t = 273;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_INDEX_BLOCK: pm_diagnostic_id_t = 274;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_INDEX_KEYWORDS: pm_diagnostic_id_t = 275;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_LABEL: pm_diagnostic_id_t = 276;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_MULTI_WRITE: pm_diagnostic_id_t = 277;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_RANGE_OPERATOR: pm_diagnostic_id_t = 278;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_SAFE_NAVIGATION: pm_diagnostic_id_t = 279;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_TOKEN_CLOSE_CONTEXT: pm_diagnostic_id_t = 280;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_TOKEN_IGNORE: pm_diagnostic_id_t = 281;
pub const pm_diagnostic_id_t_PM_ERR_UNTIL_TERM: pm_diagnostic_id_t = 282;
pub const pm_diagnostic_id_t_PM_ERR_VOID_EXPRESSION: pm_diagnostic_id_t = 283;
pub const pm_diagnostic_id_t_PM_ERR_WHILE_TERM: pm_diagnostic_id_t = 284;
pub const pm_diagnostic_id_t_PM_ERR_WRITE_TARGET_IN_METHOD: pm_diagnostic_id_t = 285;
pub const pm_diagnostic_id_t_PM_ERR_WRITE_TARGET_READONLY: pm_diagnostic_id_t = 286;
pub const pm_diagnostic_id_t_PM_ERR_WRITE_TARGET_UNEXPECTED: pm_diagnostic_id_t = 287;
pub const pm_diagnostic_id_t_PM_ERR_XSTRING_TERM: pm_diagnostic_id_t = 288;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_BINARY_OPERATOR: pm_diagnostic_id_t = 289;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_FIRST_ARGUMENT_MINUS: pm_diagnostic_id_t = 290;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_FIRST_ARGUMENT_PLUS: pm_diagnostic_id_t = 291;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_PREFIX_AMPERSAND: pm_diagnostic_id_t = 292;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_PREFIX_STAR: pm_diagnostic_id_t = 293;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_PREFIX_STAR_STAR: pm_diagnostic_id_t = 294;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_SLASH: pm_diagnostic_id_t = 295;
pub const pm_diagnostic_id_t_PM_WARN_COMPARISON_AFTER_COMPARISON: pm_diagnostic_id_t = 296;
pub const pm_diagnostic_id_t_PM_WARN_DOT_DOT_DOT_EOL: pm_diagnostic_id_t = 297;
pub const pm_diagnostic_id_t_PM_WARN_EQUAL_IN_CONDITIONAL: pm_diagnostic_id_t = 298;
pub const pm_diagnostic_id_t_PM_WARN_EQUAL_IN_CONDITIONAL_3_3: pm_diagnostic_id_t = 299;
pub const pm_diagnostic_id_t_PM_WARN_END_IN_METHOD: pm_diagnostic_id_t = 300;
pub const pm_diagnostic_id_t_PM_WARN_DUPLICATED_HASH_KEY: pm_diagnostic_id_t = 301;
pub const pm_diagnostic_id_t_PM_WARN_DUPLICATED_WHEN_CLAUSE: pm_diagnostic_id_t = 302;
pub const pm_diagnostic_id_t_PM_WARN_FLOAT_OUT_OF_RANGE: pm_diagnostic_id_t = 303;
pub const pm_diagnostic_id_t_PM_WARN_IGNORED_FROZEN_STRING_LITERAL: pm_diagnostic_id_t = 304;
pub const pm_diagnostic_id_t_PM_WARN_INDENTATION_MISMATCH: pm_diagnostic_id_t = 305;
pub const pm_diagnostic_id_t_PM_WARN_INTEGER_IN_FLIP_FLOP: pm_diagnostic_id_t = 306;
pub const pm_diagnostic_id_t_PM_WARN_INVALID_CHARACTER: pm_diagnostic_id_t = 307;
pub const pm_diagnostic_id_t_PM_WARN_INVALID_MAGIC_COMMENT_VALUE: pm_diagnostic_id_t = 308;
pub const pm_diagnostic_id_t_PM_WARN_INVALID_NUMBERED_REFERENCE: pm_diagnostic_id_t = 309;
pub const pm_diagnostic_id_t_PM_WARN_KEYWORD_EOL: pm_diagnostic_id_t = 310;
pub const pm_diagnostic_id_t_PM_WARN_LITERAL_IN_CONDITION_DEFAULT: pm_diagnostic_id_t = 311;
pub const pm_diagnostic_id_t_PM_WARN_LITERAL_IN_CONDITION_VERBOSE: pm_diagnostic_id_t = 312;
pub const pm_diagnostic_id_t_PM_WARN_SHAREABLE_CONSTANT_VALUE_LINE: pm_diagnostic_id_t = 313;
pub const pm_diagnostic_id_t_PM_WARN_SHEBANG_CARRIAGE_RETURN: pm_diagnostic_id_t = 314;
pub const pm_diagnostic_id_t_PM_WARN_UNEXPECTED_CARRIAGE_RETURN: pm_diagnostic_id_t = 315;
pub const pm_diagnostic_id_t_PM_WARN_UNREACHABLE_STATEMENT: pm_diagnostic_id_t = 316;
pub const pm_diagnostic_id_t_PM_WARN_UNUSED_LOCAL_VARIABLE: pm_diagnostic_id_t = 317;
pub const pm_diagnostic_id_t_PM_WARN_VOID_STATEMENT: pm_diagnostic_id_t = 318;
#[doc = " The diagnostic IDs of all of the diagnostics, used to communicate the types\n of errors between the parser and the user."]
pub type pm_diagnostic_id_t = ::std::os::raw::c_uint;
#[doc = " This struct represents a diagnostic generated during parsing.\n\n @extends pm_list_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_diagnostic_t {
    #[doc = " The embedded base node."]
    pub node: pm_list_node_t,
    #[doc = " The location of the diagnostic in the source."]
    pub location: pm_location_t,
    #[doc = " The ID of the diagnostic."]
    pub diag_id: pm_diagnostic_id_t,
    #[doc = " The message associated with the diagnostic."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " Whether or not the memory related to the message of this diagnostic is\n owned by this diagnostic. If it is, it needs to be freed when the\n diagnostic is freed."]
    pub owned: bool,
    #[doc = " The level of the diagnostic, see `pm_error_level_t` and\n `pm_warning_level_t` for possible values."]
    pub level: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_diagnostic_t"][::std::mem::size_of::<pm_diagnostic_t>() - 48usize];
    ["Alignment of pm_diagnostic_t"][::std::mem::align_of::<pm_diagnostic_t>() - 8usize];
    ["Offset of field: pm_diagnostic_t::node"]
        [::std::mem::offset_of!(pm_diagnostic_t, node) - 0usize];
    ["Offset of field: pm_diagnostic_t::location"]
        [::std::mem::offset_of!(pm_diagnostic_t, location) - 8usize];
    ["Offset of field: pm_diagnostic_t::diag_id"]
        [::std::mem::offset_of!(pm_diagnostic_t, diag_id) - 24usize];
    ["Offset of field: pm_diagnostic_t::message"]
        [::std::mem::offset_of!(pm_diagnostic_t, message) - 32usize];
    ["Offset of field: pm_diagnostic_t::owned"]
        [::std::mem::offset_of!(pm_diagnostic_t, owned) - 40usize];
    ["Offset of field: pm_diagnostic_t::level"]
        [::std::mem::offset_of!(pm_diagnostic_t, level) - 41usize];
};
#[doc = " For errors that should raise a syntax error."]
pub const pm_error_level_t_PM_ERROR_LEVEL_SYNTAX: pm_error_level_t = 0;
#[doc = " For errors that should raise an argument error."]
pub const pm_error_level_t_PM_ERROR_LEVEL_ARGUMENT: pm_error_level_t = 1;
#[doc = " For errors that should raise a load error."]
pub const pm_error_level_t_PM_ERROR_LEVEL_LOAD: pm_error_level_t = 2;
#[doc = " The levels of errors generated during parsing."]
pub type pm_error_level_t = ::std::os::raw::c_uint;
#[doc = " For warnings which should be emitted if $VERBOSE != nil."]
pub const pm_warning_level_t_PM_WARNING_LEVEL_DEFAULT: pm_warning_level_t = 0;
#[doc = " For warnings which should be emitted if $VERBOSE == true."]
pub const pm_warning_level_t_PM_WARNING_LEVEL_VERBOSE: pm_warning_level_t = 1;
#[doc = " The levels of warnings generated during parsing."]
pub type pm_warning_level_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Get the human-readable name of the given diagnostic ID.\n\n @param diag_id The diagnostic ID.\n @return The human-readable name of the diagnostic ID."]
    pub fn pm_diagnostic_id_human(diag_id: pm_diagnostic_id_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Append a diagnostic to the given list of diagnostics that is using shared\n memory for its message.\n\n @param list The list to append to.\n @param start The start of the diagnostic.\n @param end The end of the diagnostic.\n @param diag_id The diagnostic ID.\n @return Whether the diagnostic was successfully appended."]
    pub fn pm_diagnostic_list_append(
        list: *mut pm_list_t,
        start: *const u8,
        end: *const u8,
        diag_id: pm_diagnostic_id_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Append a diagnostic to the given list of diagnostics that is using a format\n string for its message.\n\n @param list The list to append to.\n @param start The start of the diagnostic.\n @param end The end of the diagnostic.\n @param diag_id The diagnostic ID.\n @param ... The arguments to the format string for the message.\n @return Whether the diagnostic was successfully appended."]
    pub fn pm_diagnostic_list_append_format(
        list: *mut pm_list_t,
        start: *const u8,
        end: *const u8,
        diag_id: pm_diagnostic_id_t,
        ...
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Deallocate the internal state of the given diagnostic list.\n\n @param list The list to deallocate."]
    pub fn pm_diagnostic_list_free(list: *mut pm_list_t);
}
#[doc = " A scope of locals surrounding the code that is being parsed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_options_scope {
    #[doc = " The number of locals in the scope."]
    pub locals_count: usize,
    #[doc = " The names of the locals in the scope."]
    pub locals: *mut pm_string_t,
    #[doc = " Flags for the set of forwarding parameters in this scope."]
    pub forwarding: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_options_scope"][::std::mem::size_of::<pm_options_scope>() - 24usize];
    ["Alignment of pm_options_scope"][::std::mem::align_of::<pm_options_scope>() - 8usize];
    ["Offset of field: pm_options_scope::locals_count"]
        [::std::mem::offset_of!(pm_options_scope, locals_count) - 0usize];
    ["Offset of field: pm_options_scope::locals"]
        [::std::mem::offset_of!(pm_options_scope, locals) - 8usize];
    ["Offset of field: pm_options_scope::forwarding"]
        [::std::mem::offset_of!(pm_options_scope, forwarding) - 16usize];
};
#[doc = " A scope of locals surrounding the code that is being parsed."]
pub type pm_options_scope_t = pm_options_scope;
#[doc = " The default value for parameters."]
pub const PM_OPTIONS_SCOPE_FORWARDING_NONE: u8 = 0;
#[doc = " When the scope is fowarding with the * parameter."]
pub const PM_OPTIONS_SCOPE_FORWARDING_POSITIONALS: u8 = 1;
#[doc = " When the scope is fowarding with the ** parameter."]
pub const PM_OPTIONS_SCOPE_FORWARDING_KEYWORDS: u8 = 2;
#[doc = " When the scope is fowarding with the & parameter."]
pub const PM_OPTIONS_SCOPE_FORWARDING_BLOCK: u8 = 4;
#[doc = " When the scope is fowarding with the ... parameter."]
pub const PM_OPTIONS_SCOPE_FORWARDING_ALL: u8 = 8;
#[doc = " The callback called when additional switches are found in a shebang comment\n that need to be processed by the runtime.\n\n @param options The options struct that may be updated by this callback.\n   Certain fields will be checked for changes, specifically encoding,\n   command_line, and frozen_string_literal.\n @param source The source of the shebang comment.\n @param length The length of the source.\n @param shebang_callback_data Any additional data that should be passed along\n   to the callback."]
pub type pm_options_shebang_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        options: *mut pm_options,
        source: *const u8,
        length: usize,
        shebang_callback_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " The current version of prism."]
pub const pm_options_version_t_PM_OPTIONS_VERSION_LATEST: pm_options_version_t = 0;
#[doc = " The vendored version of prism in CRuby 3.3.x."]
pub const pm_options_version_t_PM_OPTIONS_VERSION_CRUBY_3_3: pm_options_version_t = 1;
#[doc = " The vendored version of prism in CRuby 3.4.x."]
pub const pm_options_version_t_PM_OPTIONS_VERSION_CRUBY_3_4: pm_options_version_t = 2;
#[doc = " The version of Ruby syntax that we should be parsing with. This is used to\n allow consumers to specify which behavior they want in case they need to\n parse in the same way as a specific version of CRuby would have."]
pub type pm_options_version_t = ::std::os::raw::c_uint;
#[doc = " The options that can be passed to the parser."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_options {
    #[doc = " The callback to call when additional switches are found in a shebang\n comment."]
    pub shebang_callback: pm_options_shebang_callback_t,
    #[doc = " Any additional data that should be passed along to the shebang callback\n if one was set."]
    pub shebang_callback_data: *mut ::std::os::raw::c_void,
    #[doc = " The name of the file that is currently being parsed."]
    pub filepath: pm_string_t,
    #[doc = " The line within the file that the parse starts on. This value is\n 1-indexed."]
    pub line: i32,
    #[doc = " The name of the encoding that the source file is in. Note that this must\n correspond to a name that can be found with Encoding.find in Ruby."]
    pub encoding: pm_string_t,
    #[doc = " The number of scopes surrounding the code that is being parsed."]
    pub scopes_count: usize,
    #[doc = " The scopes surrounding the code that is being parsed. For most parses\n this will be NULL, but for evals it will be the locals that are in scope\n surrounding the eval. Scopes are ordered from the outermost scope to the\n innermost one."]
    pub scopes: *mut pm_options_scope_t,
    #[doc = " The version of prism that we should be parsing with. This is used to\n allow consumers to specify which behavior they want in case they need to\n parse exactly as a specific version of CRuby."]
    pub version: pm_options_version_t,
    #[doc = " A bitset of the various options that were set on the command line."]
    pub command_line: u8,
    #[doc = " Whether or not the frozen string literal option has been set.\n May be:\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_DISABLED\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_ENABLED\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_UNSET"]
    pub frozen_string_literal: i8,
    #[doc = " Whether or not the encoding magic comments should be respected. This is a\n niche use-case where you want to parse a file with a specific encoding\n but ignore any encoding magic comments at the top of the file."]
    pub encoding_locked: bool,
    #[doc = " When the file being parsed is the main script, the shebang will be\n considered for command-line flags (or for implicit -x). The caller needs\n to pass this information to the parser so that it can behave correctly."]
    pub main_script: bool,
    #[doc = " When the file being parsed is considered a \"partial\" script, jumps will\n not be marked as errors if they are not contained within loops/blocks.\n This is used in the case that you're parsing a script that you know will\n be embedded inside another script later, but you do not have that context\n yet. For example, when parsing an ERB template that will be evaluated\n inside another script."]
    pub partial_script: bool,
    #[doc = " Whether or not the parser should freeze the nodes that it creates. This\n makes it possible to have a deeply frozen AST that is safe to share\n between concurrency primitives."]
    pub freeze: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_options"][::std::mem::size_of::<pm_options>() - 104usize];
    ["Alignment of pm_options"][::std::mem::align_of::<pm_options>() - 8usize];
    ["Offset of field: pm_options::shebang_callback"]
        [::std::mem::offset_of!(pm_options, shebang_callback) - 0usize];
    ["Offset of field: pm_options::shebang_callback_data"]
        [::std::mem::offset_of!(pm_options, shebang_callback_data) - 8usize];
    ["Offset of field: pm_options::filepath"]
        [::std::mem::offset_of!(pm_options, filepath) - 16usize];
    ["Offset of field: pm_options::line"][::std::mem::offset_of!(pm_options, line) - 40usize];
    ["Offset of field: pm_options::encoding"]
        [::std::mem::offset_of!(pm_options, encoding) - 48usize];
    ["Offset of field: pm_options::scopes_count"]
        [::std::mem::offset_of!(pm_options, scopes_count) - 72usize];
    ["Offset of field: pm_options::scopes"][::std::mem::offset_of!(pm_options, scopes) - 80usize];
    ["Offset of field: pm_options::version"][::std::mem::offset_of!(pm_options, version) - 88usize];
    ["Offset of field: pm_options::command_line"]
        [::std::mem::offset_of!(pm_options, command_line) - 92usize];
    ["Offset of field: pm_options::frozen_string_literal"]
        [::std::mem::offset_of!(pm_options, frozen_string_literal) - 93usize];
    ["Offset of field: pm_options::encoding_locked"]
        [::std::mem::offset_of!(pm_options, encoding_locked) - 94usize];
    ["Offset of field: pm_options::main_script"]
        [::std::mem::offset_of!(pm_options, main_script) - 95usize];
    ["Offset of field: pm_options::partial_script"]
        [::std::mem::offset_of!(pm_options, partial_script) - 96usize];
    ["Offset of field: pm_options::freeze"][::std::mem::offset_of!(pm_options, freeze) - 97usize];
};
#[doc = " The options that can be passed to the parser."]
pub type pm_options_t = pm_options;
#[doc = " A bit representing whether or not the command line -a option was set. -a\n splits the input line $_ into $F."]
pub const PM_OPTIONS_COMMAND_LINE_A: u8 = 1;
#[doc = " A bit representing whether or not the command line -e option was set. -e\n allow the user to specify a script to be executed. This is necessary for\n prism to know because certain warnings are not generated when -e is used."]
pub const PM_OPTIONS_COMMAND_LINE_E: u8 = 2;
#[doc = " A bit representing whether or not the command line -l option was set. -l\n chomps the input line by default."]
pub const PM_OPTIONS_COMMAND_LINE_L: u8 = 4;
#[doc = " A bit representing whether or not the command line -n option was set. -n\n wraps the script in a while gets loop."]
pub const PM_OPTIONS_COMMAND_LINE_N: u8 = 8;
#[doc = " A bit representing whether or not the command line -p option was set. -p\n prints the value of $_ at the end of each loop."]
pub const PM_OPTIONS_COMMAND_LINE_P: u8 = 16;
#[doc = " A bit representing whether or not the command line -x option was set. -x\n searches the input file for a shebang that matches the current Ruby engine."]
pub const PM_OPTIONS_COMMAND_LINE_X: u8 = 32;
unsafe extern "C" {
    #[doc = " Set the shebang callback option on the given options struct.\n\n @param options The options struct to set the shebang callback on.\n @param shebang_callback The shebang callback to set.\n @param shebang_callback_data Any additional data that should be passed along\n   to the callback."]
    pub fn pm_options_shebang_callback_set(
        options: *mut pm_options_t,
        shebang_callback: pm_options_shebang_callback_t,
        shebang_callback_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set the filepath option on the given options struct.\n\n @param options The options struct to set the filepath on.\n @param filepath The filepath to set."]
    pub fn pm_options_filepath_set(
        options: *mut pm_options_t,
        filepath: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Set the line option on the given options struct.\n\n @param options The options struct to set the line on.\n @param line The line to set."]
    pub fn pm_options_line_set(options: *mut pm_options_t, line: i32);
}
unsafe extern "C" {
    #[doc = " Set the encoding option on the given options struct.\n\n @param options The options struct to set the encoding on.\n @param encoding The encoding to set."]
    pub fn pm_options_encoding_set(
        options: *mut pm_options_t,
        encoding: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Set the encoding_locked option on the given options struct.\n\n @param options The options struct to set the encoding_locked value on.\n @param encoding_locked The encoding_locked value to set."]
    pub fn pm_options_encoding_locked_set(options: *mut pm_options_t, encoding_locked: bool);
}
unsafe extern "C" {
    #[doc = " Set the frozen string literal option on the given options struct.\n\n @param options The options struct to set the frozen string literal value on.\n @param frozen_string_literal The frozen string literal value to set."]
    pub fn pm_options_frozen_string_literal_set(
        options: *mut pm_options_t,
        frozen_string_literal: bool,
    );
}
unsafe extern "C" {
    #[doc = " Sets the command line option on the given options struct.\n\n @param options The options struct to set the command line option on.\n @param command_line The command_line value to set."]
    pub fn pm_options_command_line_set(options: *mut pm_options_t, command_line: u8);
}
unsafe extern "C" {
    #[doc = " Set the version option on the given options struct by parsing the given\n string. If the string contains an invalid option, this returns false.\n Otherwise, it returns true.\n\n @param options The options struct to set the version on.\n @param version The version to set.\n @param length The length of the version string.\n @return Whether or not the version was parsed successfully."]
    pub fn pm_options_version_set(
        options: *mut pm_options_t,
        version: *const ::std::os::raw::c_char,
        length: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the main script option on the given options struct.\n\n @param options The options struct to set the main script value on.\n @param main_script The main script value to set."]
    pub fn pm_options_main_script_set(options: *mut pm_options_t, main_script: bool);
}
unsafe extern "C" {
    #[doc = " Set the partial script option on the given options struct.\n\n @param options The options struct to set the partial script value on.\n @param partial_script The partial script value to set."]
    pub fn pm_options_partial_script_set(options: *mut pm_options_t, partial_script: bool);
}
unsafe extern "C" {
    #[doc = " Set the freeze option on the given options struct.\n\n @param options The options struct to set the freeze value on.\n @param freeze The freeze value to set."]
    pub fn pm_options_freeze_set(options: *mut pm_options_t, freeze: bool);
}
unsafe extern "C" {
    #[doc = " Allocate and zero out the scopes array on the given options struct.\n\n @param options The options struct to initialize the scopes array on.\n @param scopes_count The number of scopes to allocate.\n @return Whether or not the scopes array was initialized successfully."]
    pub fn pm_options_scopes_init(options: *mut pm_options_t, scopes_count: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Return a pointer to the scope at the given index within the given options.\n\n @param options The options struct to get the scope from.\n @param index The index of the scope to get.\n @return A pointer to the scope at the given index."]
    pub fn pm_options_scope_get(
        options: *const pm_options_t,
        index: usize,
    ) -> *const pm_options_scope_t;
}
unsafe extern "C" {
    #[doc = " Create a new options scope struct. This will hold a set of locals that are in\n scope surrounding the code that is being parsed.\n\n @param scope The scope struct to initialize.\n @param locals_count The number of locals to allocate.\n @return Whether or not the scope was initialized successfully."]
    pub fn pm_options_scope_init(scope: *mut pm_options_scope_t, locals_count: usize) -> bool;
}
unsafe extern "C" {
    #[doc = " Return a pointer to the local at the given index within the given scope.\n\n @param scope The scope struct to get the local from.\n @param index The index of the local to get.\n @return A pointer to the local at the given index."]
    pub fn pm_options_scope_local_get(
        scope: *const pm_options_scope_t,
        index: usize,
    ) -> *const pm_string_t;
}
unsafe extern "C" {
    #[doc = " Set the forwarding option on the given scope struct.\n\n @param scope The scope struct to set the forwarding on.\n @param forwarding The forwarding value to set."]
    pub fn pm_options_scope_forwarding_set(scope: *mut pm_options_scope_t, forwarding: u8);
}
unsafe extern "C" {
    #[doc = " Free the internal memory associated with the options.\n\n @param options The options struct whose internal memory should be freed."]
    pub fn pm_options_free(options: *mut pm_options_t);
}
unsafe extern "C" {
    #[doc = " Deserialize an options struct from the given binary string. This is used to\n pass options to the parser from an FFI call so that consumers of the library\n from an FFI perspective don't have to worry about the structure of our\n options structs. Since the source of these calls will be from Ruby\n implementation internals we assume it is from a trusted source.\n\n `data` is assumed to be a valid pointer pointing to well-formed data. The\n layout of this data should be the same every time, and is described below:\n\n | # bytes | field                      |\n | ------- | -------------------------- |\n | `4`     | the length of the filepath |\n | ...     | the filepath bytes         |\n | `4`     | the line number            |\n | `4`     | the length the encoding    |\n | ...     | the encoding bytes         |\n | `1`     | frozen string literal      |\n | `1`     | -p command line option     |\n | `1`     | -n command line option     |\n | `1`     | -l command line option     |\n | `1`     | -a command line option     |\n | `1`     | the version                |\n | `1`     | encoding locked            |\n | `1`     | main script                |\n | `1`     | partial script             |\n | `1`     | freeze                     |\n | `4`     | the number of scopes       |\n | ...     | the scopes                 |\n\n The version field is an enum, so it should be one of the following values:\n\n | value | version                   |\n | ----- | ------------------------- |\n | `0`   | use the latest version of prism |\n | `1`   | use the version of prism that is vendored in CRuby 3.3.0 |\n\n Each scope is laid out as follows:\n\n | # bytes | field                      |\n | ------- | -------------------------- |\n | `4`     | the number of locals       |\n | `1`     | the forwarding flags       |\n | ...     | the locals                 |\n\n Each local is laid out as follows:\n\n | # bytes | field                      |\n | ------- | -------------------------- |\n | `4`     | the length of the local    |\n | ...     | the local bytes            |\n\n Some additional things to note about this layout:\n\n * The filepath can have a length of 0, in which case we'll consider it an\n   empty string.\n * The line number should be 0-indexed.\n * The encoding can have a length of 0, in which case we'll use the default\n   encoding (UTF-8). If it's not 0, it should correspond to a name of an\n   encoding that can be passed to `Encoding.find` in Ruby.\n * The frozen string literal, encoding locked, main script, and partial script\n   fields are booleans, so their values should be either 0 or 1.\n * The number of scopes can be 0.\n\n @param options The options struct to deserialize into.\n @param data The binary string to deserialize from."]
    pub fn pm_options_read(options: *mut pm_options_t, data: *const ::std::os::raw::c_char);
}
#[doc = " An internal hash table for a set of nodes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_node_hash_t {
    #[doc = " The array of nodes in the hash table."]
    pub nodes: *mut *mut pm_node_t,
    #[doc = " The size of the hash table."]
    pub size: u32,
    #[doc = " The space that has been allocated in the hash table."]
    pub capacity: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_node_hash_t"][::std::mem::size_of::<pm_node_hash_t>() - 16usize];
    ["Alignment of pm_node_hash_t"][::std::mem::align_of::<pm_node_hash_t>() - 8usize];
    ["Offset of field: pm_node_hash_t::nodes"]
        [::std::mem::offset_of!(pm_node_hash_t, nodes) - 0usize];
    ["Offset of field: pm_node_hash_t::size"]
        [::std::mem::offset_of!(pm_node_hash_t, size) - 8usize];
    ["Offset of field: pm_node_hash_t::capacity"]
        [::std::mem::offset_of!(pm_node_hash_t, capacity) - 12usize];
};
#[doc = " Certain sets of nodes (hash keys and when clauses) check for duplicate nodes\n to alert the user of potential issues. To do this, we keep a set of the nodes\n that have been seen so far, and compare whenever we find a new node.\n\n We bucket the nodes based on their type to minimize the number of comparisons\n that need to be performed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_static_literals_t {
    #[doc = " This is the set of IntegerNode and SourceLineNode instances."]
    pub integer_nodes: pm_node_hash_t,
    #[doc = " This is the set of FloatNode instances."]
    pub float_nodes: pm_node_hash_t,
    #[doc = " This is the set of RationalNode and ImaginaryNode instances."]
    pub number_nodes: pm_node_hash_t,
    #[doc = " This is the set of StringNode and SourceFileNode instances."]
    pub string_nodes: pm_node_hash_t,
    #[doc = " This is the set of RegularExpressionNode instances."]
    pub regexp_nodes: pm_node_hash_t,
    #[doc = " This is the set of SymbolNode instances."]
    pub symbol_nodes: pm_node_hash_t,
    #[doc = " A pointer to the last TrueNode instance that was inserted, or NULL."]
    pub true_node: *mut pm_node_t,
    #[doc = " A pointer to the last FalseNode instance that was inserted, or NULL."]
    pub false_node: *mut pm_node_t,
    #[doc = " A pointer to the last NilNode instance that was inserted, or NULL."]
    pub nil_node: *mut pm_node_t,
    #[doc = " A pointer to the last SourceEncodingNode instance that was inserted, or\n NULL."]
    pub source_encoding_node: *mut pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_static_literals_t"][::std::mem::size_of::<pm_static_literals_t>() - 128usize];
    ["Alignment of pm_static_literals_t"][::std::mem::align_of::<pm_static_literals_t>() - 8usize];
    ["Offset of field: pm_static_literals_t::integer_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, integer_nodes) - 0usize];
    ["Offset of field: pm_static_literals_t::float_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, float_nodes) - 16usize];
    ["Offset of field: pm_static_literals_t::number_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, number_nodes) - 32usize];
    ["Offset of field: pm_static_literals_t::string_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, string_nodes) - 48usize];
    ["Offset of field: pm_static_literals_t::regexp_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, regexp_nodes) - 64usize];
    ["Offset of field: pm_static_literals_t::symbol_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, symbol_nodes) - 80usize];
    ["Offset of field: pm_static_literals_t::true_node"]
        [::std::mem::offset_of!(pm_static_literals_t, true_node) - 96usize];
    ["Offset of field: pm_static_literals_t::false_node"]
        [::std::mem::offset_of!(pm_static_literals_t, false_node) - 104usize];
    ["Offset of field: pm_static_literals_t::nil_node"]
        [::std::mem::offset_of!(pm_static_literals_t, nil_node) - 112usize];
    ["Offset of field: pm_static_literals_t::source_encoding_node"]
        [::std::mem::offset_of!(pm_static_literals_t, source_encoding_node) - 120usize];
};
unsafe extern "C" {
    #[doc = " Add a node to the set of static literals.\n\n @param newline_list The list of newline offsets to use to calculate lines.\n @param start_line The line number that the parser starts on.\n @param literals The set of static literals to add the node to.\n @param node The node to add to the set.\n @param replace Whether to replace the previous node if one already exists.\n @return A pointer to the node that is being overwritten, if there is one."]
    pub fn pm_static_literals_add(
        newline_list: *const pm_newline_list_t,
        start_line: i32,
        literals: *mut pm_static_literals_t,
        node: *mut pm_node_t,
        replace: bool,
    ) -> *mut pm_node_t;
}
unsafe extern "C" {
    #[doc = " Free the internal memory associated with the given static literals set.\n\n @param literals The set of static literals to free."]
    pub fn pm_static_literals_free(literals: *mut pm_static_literals_t);
}
unsafe extern "C" {
    #[doc = " Create a string-based representation of the given static literal.\n\n @param buffer The buffer to write the string to.\n @param newline_list The list of newline offsets to use to calculate lines.\n @param start_line The line number that the parser starts on.\n @param encoding_name The name of the encoding of the source being parsed.\n @param node The node to create a string representation of."]
    pub fn pm_static_literal_inspect(
        buffer: *mut pm_buffer_t,
        newline_list: *const pm_newline_list_t,
        start_line: i32,
        encoding_name: *const ::std::os::raw::c_char,
        node: *const pm_node_t,
    );
}
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_BEG: pm_lex_state_bit_t = 0;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_END: pm_lex_state_bit_t = 1;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_ENDARG: pm_lex_state_bit_t = 2;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_ENDFN: pm_lex_state_bit_t = 3;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_ARG: pm_lex_state_bit_t = 4;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_CMDARG: pm_lex_state_bit_t = 5;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_MID: pm_lex_state_bit_t = 6;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_FNAME: pm_lex_state_bit_t = 7;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_DOT: pm_lex_state_bit_t = 8;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_CLASS: pm_lex_state_bit_t = 9;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_LABEL: pm_lex_state_bit_t = 10;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_LABELED: pm_lex_state_bit_t = 11;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_FITEM: pm_lex_state_bit_t = 12;
#[doc = " This enum provides various bits that represent different kinds of states that\n the lexer can track. This is used to determine which kind of token to return\n based on the context of the parser."]
pub type pm_lex_state_bit_t = ::std::os::raw::c_uint;
pub const pm_lex_state_t_PM_LEX_STATE_NONE: pm_lex_state_t = 0;
pub const pm_lex_state_t_PM_LEX_STATE_BEG: pm_lex_state_t = 1;
pub const pm_lex_state_t_PM_LEX_STATE_END: pm_lex_state_t = 2;
pub const pm_lex_state_t_PM_LEX_STATE_ENDARG: pm_lex_state_t = 4;
pub const pm_lex_state_t_PM_LEX_STATE_ENDFN: pm_lex_state_t = 8;
pub const pm_lex_state_t_PM_LEX_STATE_ARG: pm_lex_state_t = 16;
pub const pm_lex_state_t_PM_LEX_STATE_CMDARG: pm_lex_state_t = 32;
pub const pm_lex_state_t_PM_LEX_STATE_MID: pm_lex_state_t = 64;
pub const pm_lex_state_t_PM_LEX_STATE_FNAME: pm_lex_state_t = 128;
pub const pm_lex_state_t_PM_LEX_STATE_DOT: pm_lex_state_t = 256;
pub const pm_lex_state_t_PM_LEX_STATE_CLASS: pm_lex_state_t = 512;
pub const pm_lex_state_t_PM_LEX_STATE_LABEL: pm_lex_state_t = 1024;
pub const pm_lex_state_t_PM_LEX_STATE_LABELED: pm_lex_state_t = 2048;
pub const pm_lex_state_t_PM_LEX_STATE_FITEM: pm_lex_state_t = 4096;
pub const pm_lex_state_t_PM_LEX_STATE_BEG_ANY: pm_lex_state_t = 577;
pub const pm_lex_state_t_PM_LEX_STATE_ARG_ANY: pm_lex_state_t = 48;
pub const pm_lex_state_t_PM_LEX_STATE_END_ANY: pm_lex_state_t = 14;
#[doc = " This enum combines the various bits from the above enum into individual\n values that represent the various states of the lexer."]
pub type pm_lex_state_t = ::std::os::raw::c_uint;
pub const pm_heredoc_quote_t_PM_HEREDOC_QUOTE_NONE: pm_heredoc_quote_t = 0;
pub const pm_heredoc_quote_t_PM_HEREDOC_QUOTE_SINGLE: pm_heredoc_quote_t = 39;
pub const pm_heredoc_quote_t_PM_HEREDOC_QUOTE_DOUBLE: pm_heredoc_quote_t = 34;
pub const pm_heredoc_quote_t_PM_HEREDOC_QUOTE_BACKTICK: pm_heredoc_quote_t = 96;
#[doc = " The type of quote that a heredoc uses."]
pub type pm_heredoc_quote_t = ::std::os::raw::c_uint;
pub const pm_heredoc_indent_t_PM_HEREDOC_INDENT_NONE: pm_heredoc_indent_t = 0;
pub const pm_heredoc_indent_t_PM_HEREDOC_INDENT_DASH: pm_heredoc_indent_t = 1;
pub const pm_heredoc_indent_t_PM_HEREDOC_INDENT_TILDE: pm_heredoc_indent_t = 2;
#[doc = " The type of indentation that a heredoc uses."]
pub type pm_heredoc_indent_t = ::std::os::raw::c_uint;
#[doc = " All of the information necessary to store to lexing a heredoc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_heredoc_lex_mode_t {
    #[doc = " A pointer to the start of the heredoc identifier."]
    pub ident_start: *const u8,
    #[doc = " The length of the heredoc identifier."]
    pub ident_length: usize,
    #[doc = " The type of quote that the heredoc uses."]
    pub quote: pm_heredoc_quote_t,
    #[doc = " The type of indentation that the heredoc uses."]
    pub indent: pm_heredoc_indent_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_heredoc_lex_mode_t"][::std::mem::size_of::<pm_heredoc_lex_mode_t>() - 24usize];
    ["Alignment of pm_heredoc_lex_mode_t"]
        [::std::mem::align_of::<pm_heredoc_lex_mode_t>() - 8usize];
    ["Offset of field: pm_heredoc_lex_mode_t::ident_start"]
        [::std::mem::offset_of!(pm_heredoc_lex_mode_t, ident_start) - 0usize];
    ["Offset of field: pm_heredoc_lex_mode_t::ident_length"]
        [::std::mem::offset_of!(pm_heredoc_lex_mode_t, ident_length) - 8usize];
    ["Offset of field: pm_heredoc_lex_mode_t::quote"]
        [::std::mem::offset_of!(pm_heredoc_lex_mode_t, quote) - 16usize];
    ["Offset of field: pm_heredoc_lex_mode_t::indent"]
        [::std::mem::offset_of!(pm_heredoc_lex_mode_t, indent) - 20usize];
};
#[doc = " When lexing Ruby source, the lexer has a small amount of state to tell which\n kind of token it is currently lexing. For example, when we find the start of\n a string, the first token that we return is a TOKEN_STRING_BEGIN token. After\n that the lexer is now in the PM_LEX_STRING mode, and will return tokens that\n are found as part of a string."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_lex_mode {
    pub mode: pm_lex_mode__bindgen_ty_1,
    pub as_: pm_lex_mode__bindgen_ty_2,
    #[doc = " The previous lex state so that it knows how to pop."]
    pub prev: *mut pm_lex_mode,
}
#[doc = " This state is used when any given token is being lexed."]
pub const pm_lex_mode_PM_LEX_DEFAULT: pm_lex_mode__bindgen_ty_1 = 0;
#[doc = " This state is used when we're lexing as normal but inside an embedded\n expression of a string."]
pub const pm_lex_mode_PM_LEX_EMBEXPR: pm_lex_mode__bindgen_ty_1 = 1;
#[doc = " This state is used when we're lexing a variable that is embedded\n directly inside of a string with the # shorthand."]
pub const pm_lex_mode_PM_LEX_EMBVAR: pm_lex_mode__bindgen_ty_1 = 2;
#[doc = " This state is used when you are inside the content of a heredoc."]
pub const pm_lex_mode_PM_LEX_HEREDOC: pm_lex_mode__bindgen_ty_1 = 3;
#[doc = " This state is used when we are lexing a list of tokens, as in a %w\n word list literal or a %i symbol list literal."]
pub const pm_lex_mode_PM_LEX_LIST: pm_lex_mode__bindgen_ty_1 = 4;
#[doc = " This state is used when a regular expression has been begun and we\n are looking for the terminator."]
pub const pm_lex_mode_PM_LEX_REGEXP: pm_lex_mode__bindgen_ty_1 = 5;
#[doc = " This state is used when we are lexing a string or a string-like\n token, as in string content with either quote or an xstring."]
pub const pm_lex_mode_PM_LEX_STRING: pm_lex_mode__bindgen_ty_1 = 6;
#[doc = " The type of this lex mode."]
pub type pm_lex_mode__bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " The data associated with this type of lex mode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pm_lex_mode__bindgen_ty_2 {
    pub list: pm_lex_mode__bindgen_ty_2__bindgen_ty_1,
    pub regexp: pm_lex_mode__bindgen_ty_2__bindgen_ty_2,
    pub string: pm_lex_mode__bindgen_ty_2__bindgen_ty_3,
    pub heredoc: pm_lex_mode__bindgen_ty_2__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_mode__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " This keeps track of the nesting level of the list."]
    pub nesting: usize,
    #[doc = " Whether or not interpolation is allowed in this list."]
    pub interpolation: bool,
    #[doc = " When lexing a list, it takes into account balancing the\n terminator if the terminator is one of (), [], {}, or <>."]
    pub incrementor: u8,
    #[doc = " This is the terminator of the list literal."]
    pub terminator: u8,
    #[doc = " This is the character set that should be used to delimit the\n tokens within the list."]
    pub breakpoints: [u8; 11usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_1>() - 24usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::nesting"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, nesting) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::interpolation"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, interpolation) - 8usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::incrementor"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, incrementor) - 9usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::terminator"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, terminator) - 10usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::breakpoints"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, breakpoints) - 11usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_mode__bindgen_ty_2__bindgen_ty_2 {
    #[doc = " This keeps track of the nesting level of the regular expression."]
    pub nesting: usize,
    #[doc = " When lexing a regular expression, it takes into account balancing\n the terminator if the terminator is one of (), [], {}, or <>."]
    pub incrementor: u8,
    #[doc = " This is the terminator of the regular expression."]
    pub terminator: u8,
    #[doc = " This is the character set that should be used to delimit the\n tokens within the regular expression."]
    pub breakpoints: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2__bindgen_ty_2"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_2>() - 24usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2__bindgen_ty_2"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_2>() - 8usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_2::nesting"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_2, nesting) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_2::incrementor"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_2, incrementor) - 8usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_2::terminator"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_2, terminator) - 9usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_2::breakpoints"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_2, breakpoints) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_mode__bindgen_ty_2__bindgen_ty_3 {
    #[doc = " This keeps track of the nesting level of the string."]
    pub nesting: usize,
    #[doc = " Whether or not interpolation is allowed in this string."]
    pub interpolation: bool,
    #[doc = " Whether or not at the end of the string we should allow a :,\n which would indicate this was a dynamic symbol instead of a\n string."]
    pub label_allowed: bool,
    #[doc = " When lexing a string, it takes into account balancing the\n terminator if the terminator is one of (), [], {}, or <>."]
    pub incrementor: u8,
    #[doc = " This is the terminator of the string. It is typically either a\n single or double quote."]
    pub terminator: u8,
    #[doc = " This is the character set that should be used to delimit the\n tokens within the string."]
    pub breakpoints: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2__bindgen_ty_3"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_3>() - 24usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2__bindgen_ty_3"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_3>() - 8usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::nesting"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, nesting) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::interpolation"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, interpolation) - 8usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::label_allowed"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, label_allowed) - 9usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::incrementor"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, incrementor) - 10usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::terminator"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, terminator) - 11usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::breakpoints"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, breakpoints) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_mode__bindgen_ty_2__bindgen_ty_4 {
    #[doc = " All of the data necessary to lex a heredoc."]
    pub base: pm_heredoc_lex_mode_t,
    #[doc = " This is the pointer to the character where lexing should resume\n once the heredoc has been completely processed."]
    pub next_start: *const u8,
    #[doc = " This is used to track the amount of common whitespace on each\n line so that we know how much to dedent each line in the case of\n a tilde heredoc."]
    pub common_whitespace: *mut usize,
    #[doc = " True if the previous token ended with a line continuation."]
    pub line_continuation: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2__bindgen_ty_4"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_4>() - 48usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2__bindgen_ty_4"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_4>() - 8usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_4::base"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_4, base) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_4::next_start"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_4, next_start) - 24usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_4::common_whitespace"][::std::mem::offset_of!(
        pm_lex_mode__bindgen_ty_2__bindgen_ty_4,
        common_whitespace
    ) - 32usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_4::line_continuation"][::std::mem::offset_of!(
        pm_lex_mode__bindgen_ty_2__bindgen_ty_4,
        line_continuation
    ) - 40usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2>() - 48usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2>() - 8usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2::list"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2, list) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2::regexp"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2, regexp) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2::string"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2, string) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2::heredoc"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2, heredoc) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode"][::std::mem::size_of::<pm_lex_mode>() - 64usize];
    ["Alignment of pm_lex_mode"][::std::mem::align_of::<pm_lex_mode>() - 8usize];
    ["Offset of field: pm_lex_mode::mode"][::std::mem::offset_of!(pm_lex_mode, mode) - 0usize];
    ["Offset of field: pm_lex_mode::as_"][::std::mem::offset_of!(pm_lex_mode, as_) - 8usize];
    ["Offset of field: pm_lex_mode::prev"][::std::mem::offset_of!(pm_lex_mode, prev) - 56usize];
};
#[doc = " When lexing Ruby source, the lexer has a small amount of state to tell which\n kind of token it is currently lexing. For example, when we find the start of\n a string, the first token that we return is a TOKEN_STRING_BEGIN token. After\n that the lexer is now in the PM_LEX_STRING mode, and will return tokens that\n are found as part of a string."]
pub type pm_lex_mode_t = pm_lex_mode;
#[doc = " The parser used to parse Ruby source."]
pub type pm_parser_t = pm_parser;
#[doc = " a null context, used for returning a value from a function"]
pub const pm_context_t_PM_CONTEXT_NONE: pm_context_t = 0;
#[doc = " a begin statement"]
pub const pm_context_t_PM_CONTEXT_BEGIN: pm_context_t = 1;
#[doc = " an ensure statement with an explicit begin"]
pub const pm_context_t_PM_CONTEXT_BEGIN_ENSURE: pm_context_t = 2;
#[doc = " a rescue else statement with an explicit begin"]
pub const pm_context_t_PM_CONTEXT_BEGIN_ELSE: pm_context_t = 3;
#[doc = " a rescue statement with an explicit begin"]
pub const pm_context_t_PM_CONTEXT_BEGIN_RESCUE: pm_context_t = 4;
#[doc = " expressions in block arguments using braces"]
pub const pm_context_t_PM_CONTEXT_BLOCK_BRACES: pm_context_t = 5;
#[doc = " expressions in block arguments using do..end"]
pub const pm_context_t_PM_CONTEXT_BLOCK_KEYWORDS: pm_context_t = 6;
#[doc = " an ensure statement within a do..end block"]
pub const pm_context_t_PM_CONTEXT_BLOCK_ENSURE: pm_context_t = 7;
#[doc = " a rescue else statement within a do..end block"]
pub const pm_context_t_PM_CONTEXT_BLOCK_ELSE: pm_context_t = 8;
#[doc = " a rescue statement within a do..end block"]
pub const pm_context_t_PM_CONTEXT_BLOCK_RESCUE: pm_context_t = 9;
#[doc = " a case when statements"]
pub const pm_context_t_PM_CONTEXT_CASE_WHEN: pm_context_t = 10;
#[doc = " a case in statements"]
pub const pm_context_t_PM_CONTEXT_CASE_IN: pm_context_t = 11;
#[doc = " a class declaration"]
pub const pm_context_t_PM_CONTEXT_CLASS: pm_context_t = 12;
#[doc = " an ensure statement within a class statement"]
pub const pm_context_t_PM_CONTEXT_CLASS_ENSURE: pm_context_t = 13;
#[doc = " a rescue else statement within a class statement"]
pub const pm_context_t_PM_CONTEXT_CLASS_ELSE: pm_context_t = 14;
#[doc = " a rescue statement within a class statement"]
pub const pm_context_t_PM_CONTEXT_CLASS_RESCUE: pm_context_t = 15;
#[doc = " a method definition"]
pub const pm_context_t_PM_CONTEXT_DEF: pm_context_t = 16;
#[doc = " an ensure statement within a method definition"]
pub const pm_context_t_PM_CONTEXT_DEF_ENSURE: pm_context_t = 17;
#[doc = " a rescue else statement within a method definition"]
pub const pm_context_t_PM_CONTEXT_DEF_ELSE: pm_context_t = 18;
#[doc = " a rescue statement within a method definition"]
pub const pm_context_t_PM_CONTEXT_DEF_RESCUE: pm_context_t = 19;
#[doc = " a method definition's parameters"]
pub const pm_context_t_PM_CONTEXT_DEF_PARAMS: pm_context_t = 20;
#[doc = " a defined? expression"]
pub const pm_context_t_PM_CONTEXT_DEFINED: pm_context_t = 21;
#[doc = " a method definition's default parameter"]
pub const pm_context_t_PM_CONTEXT_DEFAULT_PARAMS: pm_context_t = 22;
#[doc = " an else clause"]
pub const pm_context_t_PM_CONTEXT_ELSE: pm_context_t = 23;
#[doc = " an elsif clause"]
pub const pm_context_t_PM_CONTEXT_ELSIF: pm_context_t = 24;
#[doc = " an interpolated expression"]
pub const pm_context_t_PM_CONTEXT_EMBEXPR: pm_context_t = 25;
#[doc = " a for loop"]
pub const pm_context_t_PM_CONTEXT_FOR: pm_context_t = 26;
#[doc = " a for loop's index"]
pub const pm_context_t_PM_CONTEXT_FOR_INDEX: pm_context_t = 27;
#[doc = " an if statement"]
pub const pm_context_t_PM_CONTEXT_IF: pm_context_t = 28;
#[doc = " a lambda expression with braces"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_BRACES: pm_context_t = 29;
#[doc = " a lambda expression with do..end"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_DO_END: pm_context_t = 30;
#[doc = " an ensure statement within a lambda expression"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_ENSURE: pm_context_t = 31;
#[doc = " a rescue else statement within a lambda expression"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_ELSE: pm_context_t = 32;
#[doc = " a rescue statement within a lambda expression"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_RESCUE: pm_context_t = 33;
#[doc = " the predicate clause of a loop statement"]
pub const pm_context_t_PM_CONTEXT_LOOP_PREDICATE: pm_context_t = 34;
#[doc = " the top level context"]
pub const pm_context_t_PM_CONTEXT_MAIN: pm_context_t = 35;
#[doc = " a module declaration"]
pub const pm_context_t_PM_CONTEXT_MODULE: pm_context_t = 36;
#[doc = " an ensure statement within a module statement"]
pub const pm_context_t_PM_CONTEXT_MODULE_ENSURE: pm_context_t = 37;
#[doc = " a rescue else statement within a module statement"]
pub const pm_context_t_PM_CONTEXT_MODULE_ELSE: pm_context_t = 38;
#[doc = " a rescue statement within a module statement"]
pub const pm_context_t_PM_CONTEXT_MODULE_RESCUE: pm_context_t = 39;
#[doc = " a multiple target expression"]
pub const pm_context_t_PM_CONTEXT_MULTI_TARGET: pm_context_t = 40;
#[doc = " a parenthesized expression"]
pub const pm_context_t_PM_CONTEXT_PARENS: pm_context_t = 41;
#[doc = " an END block"]
pub const pm_context_t_PM_CONTEXT_POSTEXE: pm_context_t = 42;
#[doc = " a predicate inside an if/elsif/unless statement"]
pub const pm_context_t_PM_CONTEXT_PREDICATE: pm_context_t = 43;
#[doc = " a BEGIN block"]
pub const pm_context_t_PM_CONTEXT_PREEXE: pm_context_t = 44;
#[doc = " a modifier rescue clause"]
pub const pm_context_t_PM_CONTEXT_RESCUE_MODIFIER: pm_context_t = 45;
#[doc = " a singleton class definition"]
pub const pm_context_t_PM_CONTEXT_SCLASS: pm_context_t = 46;
#[doc = " an ensure statement with a singleton class"]
pub const pm_context_t_PM_CONTEXT_SCLASS_ENSURE: pm_context_t = 47;
#[doc = " a rescue else statement with a singleton class"]
pub const pm_context_t_PM_CONTEXT_SCLASS_ELSE: pm_context_t = 48;
#[doc = " a rescue statement with a singleton class"]
pub const pm_context_t_PM_CONTEXT_SCLASS_RESCUE: pm_context_t = 49;
#[doc = " a ternary expression"]
pub const pm_context_t_PM_CONTEXT_TERNARY: pm_context_t = 50;
#[doc = " an unless statement"]
pub const pm_context_t_PM_CONTEXT_UNLESS: pm_context_t = 51;
#[doc = " an until statement"]
pub const pm_context_t_PM_CONTEXT_UNTIL: pm_context_t = 52;
#[doc = " a while statement"]
pub const pm_context_t_PM_CONTEXT_WHILE: pm_context_t = 53;
#[doc = " While parsing, we keep track of a stack of contexts. This is helpful for\n error recovery so that we can pop back to a previous context when we hit a\n token that is understood by a parent context but not by the current context."]
pub type pm_context_t = ::std::os::raw::c_uint;
#[doc = " This is a node in a linked list of contexts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_context_node {
    #[doc = " The context that this node represents."]
    pub context: pm_context_t,
    #[doc = " A pointer to the previous context in the linked list."]
    pub prev: *mut pm_context_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_context_node"][::std::mem::size_of::<pm_context_node>() - 16usize];
    ["Alignment of pm_context_node"][::std::mem::align_of::<pm_context_node>() - 8usize];
    ["Offset of field: pm_context_node::context"]
        [::std::mem::offset_of!(pm_context_node, context) - 0usize];
    ["Offset of field: pm_context_node::prev"]
        [::std::mem::offset_of!(pm_context_node, prev) - 8usize];
};
#[doc = " This is a node in a linked list of contexts."]
pub type pm_context_node_t = pm_context_node;
pub const pm_comment_type_t_PM_COMMENT_INLINE: pm_comment_type_t = 0;
pub const pm_comment_type_t_PM_COMMENT_EMBDOC: pm_comment_type_t = 1;
#[doc = " This is the type of a comment that we've found while parsing."]
pub type pm_comment_type_t = ::std::os::raw::c_uint;
#[doc = " This is a node in the linked list of comments that we've found while parsing.\n\n @extends pm_list_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_comment {
    #[doc = " The embedded base node."]
    pub node: pm_list_node_t,
    #[doc = " The location of the comment in the source."]
    pub location: pm_location_t,
    #[doc = " The type of comment that we've found."]
    pub type_: pm_comment_type_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_comment"][::std::mem::size_of::<pm_comment>() - 32usize];
    ["Alignment of pm_comment"][::std::mem::align_of::<pm_comment>() - 8usize];
    ["Offset of field: pm_comment::node"][::std::mem::offset_of!(pm_comment, node) - 0usize];
    ["Offset of field: pm_comment::location"]
        [::std::mem::offset_of!(pm_comment, location) - 8usize];
    ["Offset of field: pm_comment::type_"][::std::mem::offset_of!(pm_comment, type_) - 24usize];
};
#[doc = " This is a node in the linked list of comments that we've found while parsing.\n\n @extends pm_list_node_t"]
pub type pm_comment_t = pm_comment;
#[doc = " This is a node in the linked list of magic comments that we've found while\n parsing.\n\n @extends pm_list_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_magic_comment_t {
    #[doc = " The embedded base node."]
    pub node: pm_list_node_t,
    #[doc = " A pointer to the start of the key in the source."]
    pub key_start: *const u8,
    #[doc = " A pointer to the start of the value in the source."]
    pub value_start: *const u8,
    #[doc = " The length of the key in the source."]
    pub key_length: u32,
    #[doc = " The length of the value in the source."]
    pub value_length: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_magic_comment_t"][::std::mem::size_of::<pm_magic_comment_t>() - 32usize];
    ["Alignment of pm_magic_comment_t"][::std::mem::align_of::<pm_magic_comment_t>() - 8usize];
    ["Offset of field: pm_magic_comment_t::node"]
        [::std::mem::offset_of!(pm_magic_comment_t, node) - 0usize];
    ["Offset of field: pm_magic_comment_t::key_start"]
        [::std::mem::offset_of!(pm_magic_comment_t, key_start) - 8usize];
    ["Offset of field: pm_magic_comment_t::value_start"]
        [::std::mem::offset_of!(pm_magic_comment_t, value_start) - 16usize];
    ["Offset of field: pm_magic_comment_t::key_length"]
        [::std::mem::offset_of!(pm_magic_comment_t, key_length) - 24usize];
    ["Offset of field: pm_magic_comment_t::value_length"]
        [::std::mem::offset_of!(pm_magic_comment_t, value_length) - 28usize];
};
#[doc = " When the encoding that is being used to parse the source is changed by prism,\n we provide the ability here to call out to a user-defined function."]
pub type pm_encoding_changed_callback_t =
    ::std::option::Option<unsafe extern "C" fn(parser: *mut pm_parser_t)>;
#[doc = " When you are lexing through a file, the lexer needs all of the information\n that the parser additionally provides (for example, the local table). So if\n you want to properly lex Ruby, you need to actually lex it in the context of\n the parser. In order to provide this functionality, we optionally allow a\n struct to be attached to the parser that calls back out to a user-provided\n callback when each token is lexed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_callback_t {
    #[doc = " This opaque pointer is used to provide whatever information the user\n deemed necessary to the callback. In our case we use it to pass the array\n that the tokens get appended into."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " This is the callback that is called when a token is lexed. It is passed\n the opaque data pointer, the parser, and the token that was lexed."]
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            parser: *mut pm_parser_t,
            token: *mut pm_token_t,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_callback_t"][::std::mem::size_of::<pm_lex_callback_t>() - 16usize];
    ["Alignment of pm_lex_callback_t"][::std::mem::align_of::<pm_lex_callback_t>() - 8usize];
    ["Offset of field: pm_lex_callback_t::data"]
        [::std::mem::offset_of!(pm_lex_callback_t, data) - 0usize];
    ["Offset of field: pm_lex_callback_t::callback"]
        [::std::mem::offset_of!(pm_lex_callback_t, callback) - 8usize];
};
#[doc = " The type of shareable constant value that can be set."]
pub type pm_shareable_constant_value_t = u8;
pub const PM_SCOPE_SHAREABLE_CONSTANT_NONE: pm_shareable_constant_value_t = 0;
pub const PM_SCOPE_SHAREABLE_CONSTANT_LITERAL: pm_shareable_constant_value_t = 4;
pub const PM_SCOPE_SHAREABLE_CONSTANT_EXPERIMENTAL_EVERYTHING: pm_shareable_constant_value_t = 8;
pub const PM_SCOPE_SHAREABLE_CONSTANT_EXPERIMENTAL_COPY: pm_shareable_constant_value_t = 16;
#[doc = " This tracks an individual local variable in a certain lexical context, as\n well as the number of times is it read."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_t {
    #[doc = " The name of the local variable."]
    pub name: pm_constant_id_t,
    #[doc = " The location of the local variable in the source."]
    pub location: pm_location_t,
    #[doc = " The index of the local variable in the local table."]
    pub index: u32,
    #[doc = " The number of times the local variable is read."]
    pub reads: u32,
    #[doc = " The hash of the local variable."]
    pub hash: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_t"][::std::mem::size_of::<pm_local_t>() - 40usize];
    ["Alignment of pm_local_t"][::std::mem::align_of::<pm_local_t>() - 8usize];
    ["Offset of field: pm_local_t::name"][::std::mem::offset_of!(pm_local_t, name) - 0usize];
    ["Offset of field: pm_local_t::location"]
        [::std::mem::offset_of!(pm_local_t, location) - 8usize];
    ["Offset of field: pm_local_t::index"][::std::mem::offset_of!(pm_local_t, index) - 24usize];
    ["Offset of field: pm_local_t::reads"][::std::mem::offset_of!(pm_local_t, reads) - 28usize];
    ["Offset of field: pm_local_t::hash"][::std::mem::offset_of!(pm_local_t, hash) - 32usize];
};
#[doc = " This is a set of local variables in a certain lexical context (method, class,\n module, etc.). We need to track how many times these variables are read in\n order to warn if they only get written."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_locals {
    #[doc = " The number of local variables in the set."]
    pub size: u32,
    #[doc = " The capacity of the local variables set."]
    pub capacity: u32,
    #[doc = " The nullable allocated memory for the local variables in the set."]
    pub locals: *mut pm_local_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_locals"][::std::mem::size_of::<pm_locals>() - 16usize];
    ["Alignment of pm_locals"][::std::mem::align_of::<pm_locals>() - 8usize];
    ["Offset of field: pm_locals::size"][::std::mem::offset_of!(pm_locals, size) - 0usize];
    ["Offset of field: pm_locals::capacity"][::std::mem::offset_of!(pm_locals, capacity) - 4usize];
    ["Offset of field: pm_locals::locals"][::std::mem::offset_of!(pm_locals, locals) - 8usize];
};
#[doc = " This is a set of local variables in a certain lexical context (method, class,\n module, etc.). We need to track how many times these variables are read in\n order to warn if they only get written."]
pub type pm_locals_t = pm_locals;
#[doc = " The flags about scope parameters that can be set."]
pub type pm_scope_parameters_t = u8;
pub const PM_SCOPE_PARAMETERS_NONE: pm_scope_parameters_t = 0;
pub const PM_SCOPE_PARAMETERS_FORWARDING_POSITIONALS: pm_scope_parameters_t = 1;
pub const PM_SCOPE_PARAMETERS_FORWARDING_KEYWORDS: pm_scope_parameters_t = 2;
pub const PM_SCOPE_PARAMETERS_FORWARDING_BLOCK: pm_scope_parameters_t = 4;
pub const PM_SCOPE_PARAMETERS_FORWARDING_ALL: pm_scope_parameters_t = 8;
pub const PM_SCOPE_PARAMETERS_IMPLICIT_DISALLOWED: pm_scope_parameters_t = 16;
pub const PM_SCOPE_PARAMETERS_NUMBERED_INNER: pm_scope_parameters_t = 32;
pub const PM_SCOPE_PARAMETERS_NUMBERED_FOUND: pm_scope_parameters_t = 64;
#[doc = " This struct represents a node in a linked list of scopes. Some scopes can see\n into their parent scopes, while others cannot."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_scope {
    #[doc = " A pointer to the previous scope in the linked list."]
    pub previous: *mut pm_scope,
    #[doc = " The IDs of the locals in the given scope."]
    pub locals: pm_locals_t,
    #[doc = " This is a list of the implicit parameters contained within the block.\n These will be processed after the block is parsed to determine the kind\n of parameters node that should be used and to check if any errors need to\n be added."]
    pub implicit_parameters: pm_node_list_t,
    #[doc = " This is a bitfield that indicates the parameters that are being used in\n this scope. It is a combination of the PM_SCOPE_PARAMETERS_* constants.\n There are three different kinds of parameters that can be used in a\n scope:\n\n - Ordinary parameters (e.g., def foo(bar); end)\n - Numbered parameters (e.g., def foo; _1; end)\n - The it parameter (e.g., def foo; it; end)\n\n If ordinary parameters are being used, then certain parameters can be\n forwarded to another method/structure. Those are indicated by four\n additional bits in the params field. For example, some combinations of:\n\n - def foo(*); end\n - def foo(**); end\n - def foo(&); end\n - def foo(...); end"]
    pub parameters: pm_scope_parameters_t,
    #[doc = " The current state of constant shareability for this scope. This is\n changed by magic shareable_constant_value comments."]
    pub shareable_constant: pm_shareable_constant_value_t,
    #[doc = " A boolean indicating whether or not this scope can see into its parent.\n If closed is true, then the scope cannot see into its parent."]
    pub closed: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_scope"][::std::mem::size_of::<pm_scope>() - 56usize];
    ["Alignment of pm_scope"][::std::mem::align_of::<pm_scope>() - 8usize];
    ["Offset of field: pm_scope::previous"][::std::mem::offset_of!(pm_scope, previous) - 0usize];
    ["Offset of field: pm_scope::locals"][::std::mem::offset_of!(pm_scope, locals) - 8usize];
    ["Offset of field: pm_scope::implicit_parameters"]
        [::std::mem::offset_of!(pm_scope, implicit_parameters) - 24usize];
    ["Offset of field: pm_scope::parameters"]
        [::std::mem::offset_of!(pm_scope, parameters) - 48usize];
    ["Offset of field: pm_scope::shareable_constant"]
        [::std::mem::offset_of!(pm_scope, shareable_constant) - 49usize];
    ["Offset of field: pm_scope::closed"][::std::mem::offset_of!(pm_scope, closed) - 50usize];
};
#[doc = " This struct represents a node in a linked list of scopes. Some scopes can see\n into their parent scopes, while others cannot."]
pub type pm_scope_t = pm_scope;
#[doc = " A struct that represents a stack of boolean values."]
pub type pm_state_stack_t = u32;
#[doc = " This struct represents the overall parser. It contains a reference to the\n source file, as well as pointers that indicate where in the source it's\n currently parsing. It also contains the most recent and current token that\n it's considering."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_parser {
    #[doc = " The next node identifier that will be assigned. This is a unique\n identifier used to track nodes such that the syntax tree can be dropped\n but the node can be found through another parse."]
    pub node_id: u32,
    #[doc = " The current state of the lexer."]
    pub lex_state: pm_lex_state_t,
    #[doc = " Tracks the current nesting of (), [], and {}."]
    pub enclosure_nesting: ::std::os::raw::c_int,
    #[doc = " Used to temporarily track the nesting of enclosures to determine if a {\n is the beginning of a lambda following the parameters of a lambda."]
    pub lambda_enclosure_nesting: ::std::os::raw::c_int,
    #[doc = " Used to track the nesting of braces to ensure we get the correct value\n when we are interpolating blocks with braces."]
    pub brace_nesting: ::std::os::raw::c_int,
    #[doc = " The stack used to determine if a do keyword belongs to the predicate of a\n while, until, or for loop."]
    pub do_loop_stack: pm_state_stack_t,
    #[doc = " The stack used to determine if a do keyword belongs to the beginning of a\n block."]
    pub accepts_block_stack: pm_state_stack_t,
    pub lex_modes: pm_parser__bindgen_ty_1,
    #[doc = " The pointer to the start of the source."]
    pub start: *const u8,
    #[doc = " The pointer to the end of the source."]
    pub end: *const u8,
    #[doc = " The previous token we were considering."]
    pub previous: pm_token_t,
    #[doc = " The current token we're considering."]
    pub current: pm_token_t,
    #[doc = " This is a special field set on the parser when we need the parser to jump\n to a specific location when lexing the next token, as opposed to just\n using the end of the previous token. Normally this is NULL."]
    pub next_start: *const u8,
    #[doc = " This field indicates the end of a heredoc whose identifier was found on\n the current line. If another heredoc is found on the same line, then this\n will be moved forward to the end of that heredoc. If no heredocs are\n found on a line then this is NULL."]
    pub heredoc_end: *const u8,
    #[doc = " The list of comments that have been found while parsing."]
    pub comment_list: pm_list_t,
    #[doc = " The list of magic comments that have been found while parsing."]
    pub magic_comment_list: pm_list_t,
    #[doc = " An optional location that represents the location of the __END__ marker\n and the rest of the content of the file. This content is loaded into the\n DATA constant when the file being parsed is the main file being executed."]
    pub data_loc: pm_location_t,
    #[doc = " The list of warnings that have been found while parsing."]
    pub warning_list: pm_list_t,
    #[doc = " The list of errors that have been found while parsing."]
    pub error_list: pm_list_t,
    #[doc = " The current local scope."]
    pub current_scope: *mut pm_scope_t,
    #[doc = " The current parsing context."]
    pub current_context: *mut pm_context_node_t,
    #[doc = " The hash keys for the hash that is currently being parsed. This is not\n usually necessary because it can pass it down the various call chains,\n but in the event that you're parsing a hash that is being directly\n pushed into another hash with **, we need to share the hash keys so that\n we can warn for the nested hash as well."]
    pub current_hash_keys: *mut pm_static_literals_t,
    #[doc = " The encoding functions for the current file is attached to the parser as\n it's parsing so that it can change with a magic comment."]
    pub encoding: *const pm_encoding_t,
    #[doc = " When the encoding that is being used to parse the source is changed by\n prism, we provide the ability here to call out to a user-defined\n function."]
    pub encoding_changed_callback: pm_encoding_changed_callback_t,
    #[doc = " This pointer indicates where a comment must start if it is to be\n considered an encoding comment."]
    pub encoding_comment_start: *const u8,
    #[doc = " This is an optional callback that can be attached to the parser that will\n be called whenever a new token is lexed by the parser."]
    pub lex_callback: *mut pm_lex_callback_t,
    #[doc = " This is the path of the file being parsed. We use the filepath when\n constructing SourceFileNodes."]
    pub filepath: pm_string_t,
    #[doc = " This constant pool keeps all of the constants defined throughout the file\n so that we can reference them later."]
    pub constant_pool: pm_constant_pool_t,
    #[doc = " This is the list of newline offsets in the source file."]
    pub newline_list: pm_newline_list_t,
    #[doc = " We want to add a flag to integer nodes that indicates their base. We only\n want to parse these once, but we don't have space on the token itself to\n communicate this information. So we store it here and pass it through\n when we find tokens that we need it for."]
    pub integer_base: pm_node_flags_t,
    #[doc = " This string is used to pass information from the lexer to the parser. It\n is particularly necessary because of escape sequences."]
    pub current_string: pm_string_t,
    #[doc = " The line number at the start of the parse. This will be used to offset\n the line numbers of all of the locations."]
    pub start_line: i32,
    #[doc = " When a string-like expression is being lexed, any byte or escape sequence\n that resolves to a value whose top bit is set (i.e., >= 0x80) will\n explicitly set the encoding to the same encoding as the source.\n Alternatively, if a unicode escape sequence is used (e.g., \\\\u{80}) that\n resolves to a value whose top bit is set, then the encoding will be\n explicitly set to UTF-8.\n\n The _next_ time this happens, if the encoding that is about to become the\n explicitly set encoding does not match the previously set explicit\n encoding, a mixed encoding error will be emitted.\n\n When the expression is finished being lexed, the explicit encoding\n controls the encoding of the expression. For the most part this means\n that the expression will either be encoded in the source encoding or\n UTF-8. This holds for all encodings except US-ASCII. If the source is\n US-ASCII and an explicit encoding was set that was _not_ UTF-8, then the\n expression will be encoded as ASCII-8BIT.\n\n Note that if the expression is a list, different elements within the same\n list can have different encodings, so this will get reset between each\n element. Furthermore all of this only applies to lists that support\n interpolation, because otherwise escapes that could change the encoding\n are ignored.\n\n At first glance, it may make more sense for this to live on the lexer\n mode, but we need it here to communicate back to the parser for character\n literals that do not push a new lexer mode."]
    pub explicit_encoding: *const pm_encoding_t,
    #[doc = " When parsing block exits (e.g., break, next, redo), we need to validate\n that they are in correct contexts. For the most part we can do this by\n looking at our parent contexts. However, modifier while and until\n expressions can change that context to make block exits valid. In these\n cases, we need to keep track of the block exits and then validate them\n after the expression has been parsed.\n\n We use a pointer here because we don't want to keep a whole list attached\n since this will only be used in the context of begin/end expressions."]
    pub current_block_exits: *mut pm_node_list_t,
    #[doc = " The version of prism that we should use to parse."]
    pub version: pm_options_version_t,
    #[doc = " The command line flags given from the options."]
    pub command_line: u8,
    #[doc = " Whether or not we have found a frozen_string_literal magic comment with\n a true or false value.\n May be:\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_DISABLED\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_ENABLED\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_UNSET"]
    pub frozen_string_literal: i8,
    #[doc = " Whether or not we are parsing an eval string. This impacts whether or not\n we should evaluate if block exits/yields are valid."]
    pub parsing_eval: bool,
    #[doc = " Whether or not we are parsing a \"partial\" script, which is a script that\n will be evaluated in the context of another script, so we should not\n check jumps (next/break/etc.) for validity."]
    pub partial_script: bool,
    #[doc = " Whether or not we're at the beginning of a command."]
    pub command_start: bool,
    #[doc = " Whether or not we're currently recovering from a syntax error."]
    pub recovering: bool,
    #[doc = " This is very specialized behavior for when you want to parse in a context\n that does not respect encoding comments. Its main use case is translating\n into the whitequark/parser AST which re-encodes source files in UTF-8\n before they are parsed and ignores encoding comments."]
    pub encoding_locked: bool,
    #[doc = " Whether or not the encoding has been changed by a magic comment. We use\n this to provide a fast path for the lexer instead of going through the\n function pointer."]
    pub encoding_changed: bool,
    #[doc = " This flag indicates that we are currently parsing a pattern matching\n expression and impacts that calculation of newlines."]
    pub pattern_matching_newlines: bool,
    #[doc = " This flag indicates that we are currently parsing a keyword argument."]
    pub in_keyword_arg: bool,
    #[doc = " Whether or not the parser has seen a token that has semantic meaning\n (i.e., a token that is not a comment or whitespace)."]
    pub semantic_token_seen: bool,
    #[doc = " True if the current regular expression being lexed contains only ASCII\n characters."]
    pub current_regular_expression_ascii_only: bool,
    #[doc = " By default, Ruby always warns about mismatched indentation. This can be\n toggled with a magic comment."]
    pub warn_mismatched_indentation: bool,
}
#[doc = " A stack of lex modes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_parser__bindgen_ty_1 {
    #[doc = " The current mode of the lexer."]
    pub current: *mut pm_lex_mode_t,
    #[doc = " The stack of lexer modes."]
    pub stack: [pm_lex_mode_t; 4usize],
    #[doc = " The current index into the lexer mode stack."]
    pub index: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parser__bindgen_ty_1"]
        [::std::mem::size_of::<pm_parser__bindgen_ty_1>() - 272usize];
    ["Alignment of pm_parser__bindgen_ty_1"]
        [::std::mem::align_of::<pm_parser__bindgen_ty_1>() - 8usize];
    ["Offset of field: pm_parser__bindgen_ty_1::current"]
        [::std::mem::offset_of!(pm_parser__bindgen_ty_1, current) - 0usize];
    ["Offset of field: pm_parser__bindgen_ty_1::stack"]
        [::std::mem::offset_of!(pm_parser__bindgen_ty_1, stack) - 8usize];
    ["Offset of field: pm_parser__bindgen_ty_1::index"]
        [::std::mem::offset_of!(pm_parser__bindgen_ty_1, index) - 264usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parser"][::std::mem::size_of::<pm_parser>() - 712usize];
    ["Alignment of pm_parser"][::std::mem::align_of::<pm_parser>() - 8usize];
    ["Offset of field: pm_parser::node_id"][::std::mem::offset_of!(pm_parser, node_id) - 0usize];
    ["Offset of field: pm_parser::lex_state"]
        [::std::mem::offset_of!(pm_parser, lex_state) - 4usize];
    ["Offset of field: pm_parser::enclosure_nesting"]
        [::std::mem::offset_of!(pm_parser, enclosure_nesting) - 8usize];
    ["Offset of field: pm_parser::lambda_enclosure_nesting"]
        [::std::mem::offset_of!(pm_parser, lambda_enclosure_nesting) - 12usize];
    ["Offset of field: pm_parser::brace_nesting"]
        [::std::mem::offset_of!(pm_parser, brace_nesting) - 16usize];
    ["Offset of field: pm_parser::do_loop_stack"]
        [::std::mem::offset_of!(pm_parser, do_loop_stack) - 20usize];
    ["Offset of field: pm_parser::accepts_block_stack"]
        [::std::mem::offset_of!(pm_parser, accepts_block_stack) - 24usize];
    ["Offset of field: pm_parser::lex_modes"]
        [::std::mem::offset_of!(pm_parser, lex_modes) - 32usize];
    ["Offset of field: pm_parser::start"][::std::mem::offset_of!(pm_parser, start) - 304usize];
    ["Offset of field: pm_parser::end"][::std::mem::offset_of!(pm_parser, end) - 312usize];
    ["Offset of field: pm_parser::previous"]
        [::std::mem::offset_of!(pm_parser, previous) - 320usize];
    ["Offset of field: pm_parser::current"][::std::mem::offset_of!(pm_parser, current) - 344usize];
    ["Offset of field: pm_parser::next_start"]
        [::std::mem::offset_of!(pm_parser, next_start) - 368usize];
    ["Offset of field: pm_parser::heredoc_end"]
        [::std::mem::offset_of!(pm_parser, heredoc_end) - 376usize];
    ["Offset of field: pm_parser::comment_list"]
        [::std::mem::offset_of!(pm_parser, comment_list) - 384usize];
    ["Offset of field: pm_parser::magic_comment_list"]
        [::std::mem::offset_of!(pm_parser, magic_comment_list) - 408usize];
    ["Offset of field: pm_parser::data_loc"]
        [::std::mem::offset_of!(pm_parser, data_loc) - 432usize];
    ["Offset of field: pm_parser::warning_list"]
        [::std::mem::offset_of!(pm_parser, warning_list) - 448usize];
    ["Offset of field: pm_parser::error_list"]
        [::std::mem::offset_of!(pm_parser, error_list) - 472usize];
    ["Offset of field: pm_parser::current_scope"]
        [::std::mem::offset_of!(pm_parser, current_scope) - 496usize];
    ["Offset of field: pm_parser::current_context"]
        [::std::mem::offset_of!(pm_parser, current_context) - 504usize];
    ["Offset of field: pm_parser::current_hash_keys"]
        [::std::mem::offset_of!(pm_parser, current_hash_keys) - 512usize];
    ["Offset of field: pm_parser::encoding"]
        [::std::mem::offset_of!(pm_parser, encoding) - 520usize];
    ["Offset of field: pm_parser::encoding_changed_callback"]
        [::std::mem::offset_of!(pm_parser, encoding_changed_callback) - 528usize];
    ["Offset of field: pm_parser::encoding_comment_start"]
        [::std::mem::offset_of!(pm_parser, encoding_comment_start) - 536usize];
    ["Offset of field: pm_parser::lex_callback"]
        [::std::mem::offset_of!(pm_parser, lex_callback) - 544usize];
    ["Offset of field: pm_parser::filepath"]
        [::std::mem::offset_of!(pm_parser, filepath) - 552usize];
    ["Offset of field: pm_parser::constant_pool"]
        [::std::mem::offset_of!(pm_parser, constant_pool) - 576usize];
    ["Offset of field: pm_parser::newline_list"]
        [::std::mem::offset_of!(pm_parser, newline_list) - 600usize];
    ["Offset of field: pm_parser::integer_base"]
        [::std::mem::offset_of!(pm_parser, integer_base) - 632usize];
    ["Offset of field: pm_parser::current_string"]
        [::std::mem::offset_of!(pm_parser, current_string) - 640usize];
    ["Offset of field: pm_parser::start_line"]
        [::std::mem::offset_of!(pm_parser, start_line) - 664usize];
    ["Offset of field: pm_parser::explicit_encoding"]
        [::std::mem::offset_of!(pm_parser, explicit_encoding) - 672usize];
    ["Offset of field: pm_parser::current_block_exits"]
        [::std::mem::offset_of!(pm_parser, current_block_exits) - 680usize];
    ["Offset of field: pm_parser::version"][::std::mem::offset_of!(pm_parser, version) - 688usize];
    ["Offset of field: pm_parser::command_line"]
        [::std::mem::offset_of!(pm_parser, command_line) - 692usize];
    ["Offset of field: pm_parser::frozen_string_literal"]
        [::std::mem::offset_of!(pm_parser, frozen_string_literal) - 693usize];
    ["Offset of field: pm_parser::parsing_eval"]
        [::std::mem::offset_of!(pm_parser, parsing_eval) - 694usize];
    ["Offset of field: pm_parser::partial_script"]
        [::std::mem::offset_of!(pm_parser, partial_script) - 695usize];
    ["Offset of field: pm_parser::command_start"]
        [::std::mem::offset_of!(pm_parser, command_start) - 696usize];
    ["Offset of field: pm_parser::recovering"]
        [::std::mem::offset_of!(pm_parser, recovering) - 697usize];
    ["Offset of field: pm_parser::encoding_locked"]
        [::std::mem::offset_of!(pm_parser, encoding_locked) - 698usize];
    ["Offset of field: pm_parser::encoding_changed"]
        [::std::mem::offset_of!(pm_parser, encoding_changed) - 699usize];
    ["Offset of field: pm_parser::pattern_matching_newlines"]
        [::std::mem::offset_of!(pm_parser, pattern_matching_newlines) - 700usize];
    ["Offset of field: pm_parser::in_keyword_arg"]
        [::std::mem::offset_of!(pm_parser, in_keyword_arg) - 701usize];
    ["Offset of field: pm_parser::semantic_token_seen"]
        [::std::mem::offset_of!(pm_parser, semantic_token_seen) - 702usize];
    ["Offset of field: pm_parser::current_regular_expression_ascii_only"]
        [::std::mem::offset_of!(pm_parser, current_regular_expression_ascii_only) - 703usize];
    ["Offset of field: pm_parser::warn_mismatched_indentation"]
        [::std::mem::offset_of!(pm_parser, warn_mismatched_indentation) - 704usize];
};
unsafe extern "C" {
    #[doc = " Here we have rolled our own version of strpbrk. The standard library strpbrk\n has undefined behavior when the source string is not null-terminated. We want\n to support strings that are not null-terminated because pm_parse does not\n have the contract that the string is null-terminated. (This is desirable\n because it means the extension can call pm_parse with the result of a call to\n mmap).\n\n The standard library strpbrk also does not support passing a maximum length\n to search. We want to support this for the reason mentioned above, but we\n also don't want it to stop on null bytes. Ruby actually allows null bytes\n within strings, comments, regular expressions, etc. So we need to be able to\n skip past them.\n\n Finally, we want to support encodings wherein the charset could contain\n characters that are trailing bytes of multi-byte characters. For example, in\n Shift-JIS, the backslash character can be a trailing byte. In that case we\n need to take a slower path and iterate one multi-byte character at a time.\n\n @param parser The parser.\n @param source The source to search.\n @param charset The charset to search for.\n @param length The maximum number of bytes to search.\n @param validate Whether to validate that the source string is valid in the\n     current encoding of the parser.\n @return A pointer to the first character in the source string that is in the\n     charset, or NULL if no such character exists."]
    pub fn pm_strpbrk(
        parser: *mut pm_parser_t,
        source: *const u8,
        charset: *const u8,
        length: isize,
        validate: bool,
    ) -> *const u8;
}
unsafe extern "C" {
    #[doc = " Append a new node onto the end of the node list.\n\n @param list The list to append to.\n @param node The node to append."]
    pub fn pm_node_list_append(list: *mut pm_node_list_t, node: *mut pm_node_t);
}
unsafe extern "C" {
    #[doc = " Prepend a new node onto the beginning of the node list.\n\n @param list The list to prepend to.\n @param node The node to prepend."]
    pub fn pm_node_list_prepend(list: *mut pm_node_list_t, node: *mut pm_node_t);
}
unsafe extern "C" {
    #[doc = " Concatenate the given node list onto the end of the other node list.\n\n @param list The list to concatenate onto.\n @param other The list to concatenate."]
    pub fn pm_node_list_concat(list: *mut pm_node_list_t, other: *mut pm_node_list_t);
}
unsafe extern "C" {
    #[doc = " Free the internal memory associated with the given node list.\n\n @param list The list to free."]
    pub fn pm_node_list_free(list: *mut pm_node_list_t);
}
unsafe extern "C" {
    #[doc = " Deallocate a node and all of its children.\n\n @param parser The parser that owns the node.\n @param node The node to deallocate."]
    pub fn pm_node_destroy(parser: *mut pm_parser_t, node: *mut pm_node);
}
unsafe extern "C" {
    #[doc = " Returns a string representation of the given node type.\n\n @param node_type The node type to convert to a string.\n @return A string representation of the given node type."]
    pub fn pm_node_type_to_str(node_type: pm_node_type_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Visit each of the nodes in this subtree using the given visitor callback. The\n callback function will be called for each node in the subtree. If it returns\n false, then that node's children will not be visited. If it returns true,\n then the children will be visited. The data parameter is treated as an opaque\n pointer and is passed to the visitor callback for consumers to use as they\n see fit.\n\n As an example:\n\n ```c\n #include \"prism.h\"\n\n bool visit(const pm_node_t *node, void *data) {\n     size_t *indent = (size_t *) data;\n     for (size_t i = 0; i < *indent * 2; i++) putc(' ', stdout);\n     printf(\"%s\\n\", pm_node_type_to_str(node->type));\n\n     size_t next_indent = *indent + 1;\n     size_t *next_data = &next_indent;\n     pm_visit_child_nodes(node, visit, next_data);\n\n     return false;\n }\n\n int main(void) {\n     const char *source = \"1 + 2; 3 + 4\";\n     size_t size = strlen(source);\n\n     pm_parser_t parser;\n     pm_options_t options = { 0 };\n     pm_parser_init(&parser, (const uint8_t *) source, size, &options);\n\n     size_t indent = 0;\n     pm_node_t *node = pm_parse(&parser);\n\n     size_t *data = &indent;\n     pm_visit_node(node, visit, data);\n\n     pm_node_destroy(&parser, node);\n     pm_parser_free(&parser);\n     return EXIT_SUCCESS;\n }\n ```\n\n @param node The root node to start visiting from.\n @param visitor The callback to call for each node in the subtree.\n @param data An opaque pointer that is passed to the visitor callback."]
    pub fn pm_visit_node(
        node: *const pm_node_t,
        visitor: ::std::option::Option<
            unsafe extern "C" fn(node: *const pm_node_t, data: *mut ::std::os::raw::c_void) -> bool,
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Visit the children of the given node with the given callback. This is the\n default behavior for walking the tree that is called from pm_visit_node if\n the callback returns true.\n\n @param node The node to visit the children of.\n @param visitor The callback to call for each child node.\n @param data An opaque pointer that is passed to the visitor callback."]
    pub fn pm_visit_child_nodes(
        node: *const pm_node_t,
        visitor: ::std::option::Option<
            unsafe extern "C" fn(node: *const pm_node_t, data: *mut ::std::os::raw::c_void) -> bool,
        >,
        data: *mut ::std::os::raw::c_void,
    );
}
pub const pm_pack_version_PM_PACK_VERSION_3_2_0: pm_pack_version = 0;
#[doc = " The version of the pack template language that we are parsing."]
pub type pm_pack_version = ::std::os::raw::c_uint;
pub const pm_pack_variant_PM_PACK_VARIANT_PACK: pm_pack_variant = 0;
pub const pm_pack_variant_PM_PACK_VARIANT_UNPACK: pm_pack_variant = 1;
#[doc = " The type of pack template we are parsing."]
pub type pm_pack_variant = ::std::os::raw::c_uint;
pub const pm_pack_type_PM_PACK_SPACE: pm_pack_type = 0;
pub const pm_pack_type_PM_PACK_COMMENT: pm_pack_type = 1;
pub const pm_pack_type_PM_PACK_INTEGER: pm_pack_type = 2;
pub const pm_pack_type_PM_PACK_UTF8: pm_pack_type = 3;
pub const pm_pack_type_PM_PACK_BER: pm_pack_type = 4;
pub const pm_pack_type_PM_PACK_FLOAT: pm_pack_type = 5;
pub const pm_pack_type_PM_PACK_STRING_SPACE_PADDED: pm_pack_type = 6;
pub const pm_pack_type_PM_PACK_STRING_NULL_PADDED: pm_pack_type = 7;
pub const pm_pack_type_PM_PACK_STRING_NULL_TERMINATED: pm_pack_type = 8;
pub const pm_pack_type_PM_PACK_STRING_MSB: pm_pack_type = 9;
pub const pm_pack_type_PM_PACK_STRING_LSB: pm_pack_type = 10;
pub const pm_pack_type_PM_PACK_STRING_HEX_HIGH: pm_pack_type = 11;
pub const pm_pack_type_PM_PACK_STRING_HEX_LOW: pm_pack_type = 12;
pub const pm_pack_type_PM_PACK_STRING_UU: pm_pack_type = 13;
pub const pm_pack_type_PM_PACK_STRING_MIME: pm_pack_type = 14;
pub const pm_pack_type_PM_PACK_STRING_BASE64: pm_pack_type = 15;
pub const pm_pack_type_PM_PACK_STRING_FIXED: pm_pack_type = 16;
pub const pm_pack_type_PM_PACK_STRING_POINTER: pm_pack_type = 17;
pub const pm_pack_type_PM_PACK_MOVE: pm_pack_type = 18;
pub const pm_pack_type_PM_PACK_BACK: pm_pack_type = 19;
pub const pm_pack_type_PM_PACK_NULL: pm_pack_type = 20;
pub const pm_pack_type_PM_PACK_END: pm_pack_type = 21;
#[doc = " A directive within the pack template."]
pub type pm_pack_type = ::std::os::raw::c_uint;
pub const pm_pack_signed_PM_PACK_UNSIGNED: pm_pack_signed = 0;
pub const pm_pack_signed_PM_PACK_SIGNED: pm_pack_signed = 1;
pub const pm_pack_signed_PM_PACK_SIGNED_NA: pm_pack_signed = 2;
#[doc = " The signness of a pack directive."]
pub type pm_pack_signed = ::std::os::raw::c_uint;
pub const pm_pack_endian_PM_PACK_AGNOSTIC_ENDIAN: pm_pack_endian = 0;
pub const pm_pack_endian_PM_PACK_LITTLE_ENDIAN: pm_pack_endian = 1;
pub const pm_pack_endian_PM_PACK_BIG_ENDIAN: pm_pack_endian = 2;
pub const pm_pack_endian_PM_PACK_NATIVE_ENDIAN: pm_pack_endian = 3;
pub const pm_pack_endian_PM_PACK_ENDIAN_NA: pm_pack_endian = 4;
#[doc = " The endianness of a pack directive."]
pub type pm_pack_endian = ::std::os::raw::c_uint;
pub const pm_pack_size_PM_PACK_SIZE_SHORT: pm_pack_size = 0;
pub const pm_pack_size_PM_PACK_SIZE_INT: pm_pack_size = 1;
pub const pm_pack_size_PM_PACK_SIZE_LONG: pm_pack_size = 2;
pub const pm_pack_size_PM_PACK_SIZE_LONG_LONG: pm_pack_size = 3;
pub const pm_pack_size_PM_PACK_SIZE_8: pm_pack_size = 4;
pub const pm_pack_size_PM_PACK_SIZE_16: pm_pack_size = 5;
pub const pm_pack_size_PM_PACK_SIZE_32: pm_pack_size = 6;
pub const pm_pack_size_PM_PACK_SIZE_64: pm_pack_size = 7;
pub const pm_pack_size_PM_PACK_SIZE_P: pm_pack_size = 8;
pub const pm_pack_size_PM_PACK_SIZE_NA: pm_pack_size = 9;
#[doc = " The size of an integer pack directive."]
pub type pm_pack_size = ::std::os::raw::c_uint;
pub const pm_pack_length_type_PM_PACK_LENGTH_FIXED: pm_pack_length_type = 0;
pub const pm_pack_length_type_PM_PACK_LENGTH_MAX: pm_pack_length_type = 1;
pub const pm_pack_length_type_PM_PACK_LENGTH_RELATIVE: pm_pack_length_type = 2;
pub const pm_pack_length_type_PM_PACK_LENGTH_NA: pm_pack_length_type = 3;
#[doc = " The type of length of a pack directive."]
pub type pm_pack_length_type = ::std::os::raw::c_uint;
pub const pm_pack_encoding_PM_PACK_ENCODING_START: pm_pack_encoding = 0;
pub const pm_pack_encoding_PM_PACK_ENCODING_ASCII_8BIT: pm_pack_encoding = 1;
pub const pm_pack_encoding_PM_PACK_ENCODING_US_ASCII: pm_pack_encoding = 2;
pub const pm_pack_encoding_PM_PACK_ENCODING_UTF_8: pm_pack_encoding = 3;
#[doc = " The type of encoding for a pack template string."]
pub type pm_pack_encoding = ::std::os::raw::c_uint;
pub const pm_pack_result_PM_PACK_OK: pm_pack_result = 0;
pub const pm_pack_result_PM_PACK_ERROR_UNSUPPORTED_DIRECTIVE: pm_pack_result = 1;
pub const pm_pack_result_PM_PACK_ERROR_UNKNOWN_DIRECTIVE: pm_pack_result = 2;
pub const pm_pack_result_PM_PACK_ERROR_LENGTH_TOO_BIG: pm_pack_result = 3;
pub const pm_pack_result_PM_PACK_ERROR_BANG_NOT_ALLOWED: pm_pack_result = 4;
pub const pm_pack_result_PM_PACK_ERROR_DOUBLE_ENDIAN: pm_pack_result = 5;
#[doc = " The result of parsing a pack template."]
pub type pm_pack_result = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Parse a single directive from a pack or unpack format string.\n\n @param variant (in) pack or unpack\n @param format (in, out) the start of the next directive to parse on calling,\n     and advanced beyond the parsed directive on return, or as much of it as\n     was consumed until an error was encountered\n @param format_end (in) the end of the format string\n @param type (out) the type of the directive\n @param signed_type (out) whether the value is signed\n @param endian (out) the endianness of the value\n @param size (out) the size of the value\n @param length_type (out) what kind of length is specified\n @param length (out) the length of the directive\n @param encoding (in, out) takes the current encoding of the string which\n     would result from parsing the whole format string, and returns a possibly\n     changed directive - the encoding should be `PM_PACK_ENCODING_START` when\n     pm_pack_parse is called for the first directive in a format string\n\n @return `PM_PACK_OK` on success or `PM_PACK_ERROR_*` on error\n @note Consult Ruby documentation for the meaning of directives."]
    pub fn pm_pack_parse(
        variant: pm_pack_variant,
        format: *mut *const ::std::os::raw::c_char,
        format_end: *const ::std::os::raw::c_char,
        type_: *mut pm_pack_type,
        signed_type: *mut pm_pack_signed,
        endian: *mut pm_pack_endian,
        size: *mut pm_pack_size,
        length_type: *mut pm_pack_length_type,
        length: *mut u64,
        encoding: *mut pm_pack_encoding,
    ) -> pm_pack_result;
}
unsafe extern "C" {
    #[doc = " Prism abstracts sizes away from the native system - this converts an abstract\n size to a native size.\n\n @param size The abstract size to convert.\n @return The native size."]
    pub fn pm_size_to_native(size: pm_pack_size) -> usize;
}
unsafe extern "C" {
    #[doc = " Pretty-prints the AST represented by the given node to the given buffer.\n\n @param output_buffer The buffer to write the pretty-printed AST to.\n @param parser The parser that parsed the AST.\n @param node The root node of the AST to pretty-print."]
    pub fn pm_prettyprint(
        output_buffer: *mut pm_buffer_t,
        parser: *const pm_parser_t,
        node: *const pm_node_t,
    );
}
#[doc = " This callback is called when a named capture group is found."]
pub type pm_regexp_name_callback_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const pm_string_t, data: *mut ::std::os::raw::c_void),
>;
#[doc = " This callback is called when a parse error is found."]
pub type pm_regexp_error_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const u8,
        end: *const u8,
        message: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " Parse a regular expression.\n\n @param parser The parser that is currently being used.\n @param source The source code to parse.\n @param size The size of the source code.\n @param extended_mode Whether to parse the regular expression in extended mode.\n @param name_callback The optional callback to call when a named capture group is found.\n @param name_data The optional data to pass to the name callback.\n @param error_callback The callback to call when a parse error is found.\n @param error_data The data to pass to the error callback."]
    pub fn pm_regexp_parse(
        parser: *mut pm_parser_t,
        source: *const u8,
        size: usize,
        extended_mode: bool,
        name_callback: pm_regexp_name_callback_t,
        name_data: *mut ::std::os::raw::c_void,
        error_callback: pm_regexp_error_callback_t,
        error_data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xlocale {
    _unused: [u8; 0],
}
pub type locale_t = *mut _xlocale;
unsafe extern "C" {
    pub fn duplocale(arg1: locale_t) -> locale_t;
}
unsafe extern "C" {
    pub fn freelocale(arg1: locale_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn newlocale(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> locale_t;
}
unsafe extern "C" {
    pub fn uselocale(arg1: locale_t) -> locale_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lconv"][::std::mem::size_of::<lconv>() - 96usize];
    ["Alignment of lconv"][::std::mem::align_of::<lconv>() - 8usize];
    ["Offset of field: lconv::decimal_point"]
        [::std::mem::offset_of!(lconv, decimal_point) - 0usize];
    ["Offset of field: lconv::thousands_sep"]
        [::std::mem::offset_of!(lconv, thousands_sep) - 8usize];
    ["Offset of field: lconv::grouping"][::std::mem::offset_of!(lconv, grouping) - 16usize];
    ["Offset of field: lconv::int_curr_symbol"]
        [::std::mem::offset_of!(lconv, int_curr_symbol) - 24usize];
    ["Offset of field: lconv::currency_symbol"]
        [::std::mem::offset_of!(lconv, currency_symbol) - 32usize];
    ["Offset of field: lconv::mon_decimal_point"]
        [::std::mem::offset_of!(lconv, mon_decimal_point) - 40usize];
    ["Offset of field: lconv::mon_thousands_sep"]
        [::std::mem::offset_of!(lconv, mon_thousands_sep) - 48usize];
    ["Offset of field: lconv::mon_grouping"][::std::mem::offset_of!(lconv, mon_grouping) - 56usize];
    ["Offset of field: lconv::positive_sign"]
        [::std::mem::offset_of!(lconv, positive_sign) - 64usize];
    ["Offset of field: lconv::negative_sign"]
        [::std::mem::offset_of!(lconv, negative_sign) - 72usize];
    ["Offset of field: lconv::int_frac_digits"]
        [::std::mem::offset_of!(lconv, int_frac_digits) - 80usize];
    ["Offset of field: lconv::frac_digits"][::std::mem::offset_of!(lconv, frac_digits) - 81usize];
    ["Offset of field: lconv::p_cs_precedes"]
        [::std::mem::offset_of!(lconv, p_cs_precedes) - 82usize];
    ["Offset of field: lconv::p_sep_by_space"]
        [::std::mem::offset_of!(lconv, p_sep_by_space) - 83usize];
    ["Offset of field: lconv::n_cs_precedes"]
        [::std::mem::offset_of!(lconv, n_cs_precedes) - 84usize];
    ["Offset of field: lconv::n_sep_by_space"]
        [::std::mem::offset_of!(lconv, n_sep_by_space) - 85usize];
    ["Offset of field: lconv::p_sign_posn"][::std::mem::offset_of!(lconv, p_sign_posn) - 86usize];
    ["Offset of field: lconv::n_sign_posn"][::std::mem::offset_of!(lconv, n_sign_posn) - 87usize];
    ["Offset of field: lconv::int_p_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_p_cs_precedes) - 88usize];
    ["Offset of field: lconv::int_n_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_n_cs_precedes) - 89usize];
    ["Offset of field: lconv::int_p_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_p_sep_by_space) - 90usize];
    ["Offset of field: lconv::int_n_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_n_sep_by_space) - 91usize];
    ["Offset of field: lconv::int_p_sign_posn"]
        [::std::mem::offset_of!(lconv, int_p_sign_posn) - 92usize];
    ["Offset of field: lconv::int_n_sign_posn"]
        [::std::mem::offset_of!(lconv, int_n_sign_posn) - 93usize];
};
unsafe extern "C" {
    pub fn localeconv() -> *mut lconv;
}
unsafe extern "C" {
    pub fn setlocale(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " The prism version and the serialization format.\n\n @returns The prism version as a constant string."]
    pub fn pm_version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Initialize a parser with the given start and end pointers.\n\n @param parser The parser to initialize.\n @param source The source to parse.\n @param size The size of the source.\n @param options The optional options to use when parsing."]
    pub fn pm_parser_init(
        parser: *mut pm_parser_t,
        source: *const u8,
        size: usize,
        options: *const pm_options_t,
    );
}
unsafe extern "C" {
    #[doc = " Register a callback that will be called whenever prism changes the encoding\n it is using to parse based on the magic comment.\n\n @param parser The parser to register the callback with.\n @param callback The callback to register."]
    pub fn pm_parser_register_encoding_changed_callback(
        parser: *mut pm_parser_t,
        callback: pm_encoding_changed_callback_t,
    );
}
unsafe extern "C" {
    #[doc = " Free any memory associated with the given parser.\n\n @param parser The parser to free."]
    pub fn pm_parser_free(parser: *mut pm_parser_t);
}
unsafe extern "C" {
    #[doc = " Initiate the parser with the given parser.\n\n @param parser The parser to use.\n @return The AST representing the source."]
    pub fn pm_parse(parser: *mut pm_parser_t) -> *mut pm_node_t;
}
#[doc = " This function is used in pm_parse_stream to retrieve a line of input from a\n stream. It closely mirrors that of fgets so that fgets can be used as the\n default implementation."]
pub type pm_parse_stream_fgets_t = ::std::option::Option<
    unsafe extern "C" fn(
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        stream: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char,
>;
unsafe extern "C" {
    #[doc = " Parse a stream of Ruby source and return the tree.\n\n @param parser The parser to use.\n @param buffer The buffer to use.\n @param stream The stream to parse.\n @param stream_fgets The function to use to read from the stream.\n @param options The optional options to use when parsing.\n @return The AST representing the source."]
    pub fn pm_parse_stream(
        parser: *mut pm_parser_t,
        buffer: *mut pm_buffer_t,
        stream: *mut ::std::os::raw::c_void,
        stream_fgets: pm_parse_stream_fgets_t,
        options: *const pm_options_t,
    ) -> *mut pm_node_t;
}
unsafe extern "C" {
    #[doc = " Parse and serialize the AST represented by the source that is read out of the\n given stream into to the given buffer.\n\n @param buffer The buffer to serialize to.\n @param stream The stream to parse.\n @param stream_fgets The function to use to read from the stream.\n @param data The optional data to pass to the parser."]
    pub fn pm_serialize_parse_stream(
        buffer: *mut pm_buffer_t,
        stream: *mut ::std::os::raw::c_void,
        stream_fgets: pm_parse_stream_fgets_t,
        data: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Serialize the given list of comments to the given buffer.\n\n @param parser The parser to serialize.\n @param list The list of comments to serialize.\n @param buffer The buffer to serialize to."]
    pub fn pm_serialize_comment_list(
        parser: *mut pm_parser_t,
        list: *mut pm_list_t,
        buffer: *mut pm_buffer_t,
    );
}
unsafe extern "C" {
    #[doc = " Serialize the name of the encoding to the buffer.\n\n @param encoding The encoding to serialize.\n @param buffer The buffer to serialize to."]
    pub fn pm_serialize_encoding(encoding: *const pm_encoding_t, buffer: *mut pm_buffer_t);
}
unsafe extern "C" {
    #[doc = " Serialize the encoding, metadata, nodes, and constant pool.\n\n @param parser The parser to serialize.\n @param node The node to serialize.\n @param buffer The buffer to serialize to."]
    pub fn pm_serialize_content(
        parser: *mut pm_parser_t,
        node: *mut pm_node_t,
        buffer: *mut pm_buffer_t,
    );
}
unsafe extern "C" {
    #[doc = " Serialize the AST represented by the given node to the given buffer.\n\n @param parser The parser to serialize.\n @param node The node to serialize.\n @param buffer The buffer to serialize to."]
    pub fn pm_serialize(parser: *mut pm_parser_t, node: *mut pm_node_t, buffer: *mut pm_buffer_t);
}
unsafe extern "C" {
    #[doc = " Parse the given source to the AST and dump the AST to the given buffer.\n\n @param buffer The buffer to serialize to.\n @param source The source to parse.\n @param size The size of the source.\n @param data The optional data to pass to the parser."]
    pub fn pm_serialize_parse(
        buffer: *mut pm_buffer_t,
        source: *const u8,
        size: usize,
        data: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Parse and serialize the comments in the given source to the given buffer.\n\n @param buffer The buffer to serialize to.\n @param source The source to parse.\n @param size The size of the source.\n @param data The optional data to pass to the parser."]
    pub fn pm_serialize_parse_comments(
        buffer: *mut pm_buffer_t,
        source: *const u8,
        size: usize,
        data: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Lex the given source and serialize to the given buffer.\n\n @param source The source to lex.\n @param size The size of the source.\n @param buffer The buffer to serialize to.\n @param data The optional data to pass to the lexer."]
    pub fn pm_serialize_lex(
        buffer: *mut pm_buffer_t,
        source: *const u8,
        size: usize,
        data: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Parse and serialize both the AST and the tokens represented by the given\n source to the given buffer.\n\n @param buffer The buffer to serialize to.\n @param source The source to parse.\n @param size The size of the source.\n @param data The optional data to pass to the parser."]
    pub fn pm_serialize_parse_lex(
        buffer: *mut pm_buffer_t,
        source: *const u8,
        size: usize,
        data: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Parse the source and return true if it parses without errors or warnings.\n\n @param source The source to parse.\n @param size The size of the source.\n @param data The optional data to pass to the parser.\n @return True if the source parses without errors or warnings."]
    pub fn pm_parse_success_p(
        source: *const u8,
        size: usize,
        data: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns a string representation of the given token type.\n\n @param token_type The token type to convert to a string.\n @return A string representation of the given token type."]
    pub fn pm_token_type_name(token_type: pm_token_type_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the human name of the given token type.\n\n @param token_type The token type to convert to a human name.\n @return The human name of the given token type."]
    pub fn pm_token_type_human(token_type: pm_token_type_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Dump JSON to the given buffer.\n\n @param buffer The buffer to serialize to.\n @param parser The parser that parsed the node.\n @param node The node to serialize."]
    pub fn pm_dump_json(
        buffer: *mut pm_buffer_t,
        parser: *const pm_parser_t,
        node: *const pm_node_t,
    );
}
#[doc = " Returned if the encoding given to a slice query was invalid."]
pub const pm_string_query_t_PM_STRING_QUERY_ERROR: pm_string_query_t = -1;
#[doc = " Returned if the result of the slice query is false."]
pub const pm_string_query_t_PM_STRING_QUERY_FALSE: pm_string_query_t = 0;
#[doc = " Returned if the result of the slice query is true."]
pub const pm_string_query_t_PM_STRING_QUERY_TRUE: pm_string_query_t = 1;
#[doc = " Represents the results of a slice query."]
pub type pm_string_query_t = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Check that the slice is a valid local variable name.\n\n @param source The source to check.\n @param length The length of the source.\n @param encoding_name The name of the encoding of the source.\n @return PM_STRING_QUERY_TRUE if the query is true, PM_STRING_QUERY_FALSE if\n   the query is false, and PM_STRING_QUERY_ERROR if the encoding was invalid."]
    pub fn pm_string_query_local(
        source: *const u8,
        length: usize,
        encoding_name: *const ::std::os::raw::c_char,
    ) -> pm_string_query_t;
}
unsafe extern "C" {
    #[doc = " Check that the slice is a valid constant name.\n\n @param source The source to check.\n @param length The length of the source.\n @param encoding_name The name of the encoding of the source.\n @return PM_STRING_QUERY_TRUE if the query is true, PM_STRING_QUERY_FALSE if\n   the query is false, and PM_STRING_QUERY_ERROR if the encoding was invalid."]
    pub fn pm_string_query_constant(
        source: *const u8,
        length: usize,
        encoding_name: *const ::std::os::raw::c_char,
    ) -> pm_string_query_t;
}
unsafe extern "C" {
    #[doc = " Check that the slice is a valid method name.\n\n @param source The source to check.\n @param length The length of the source.\n @param encoding_name The name of the encoding of the source.\n @return PM_STRING_QUERY_TRUE if the query is true, PM_STRING_QUERY_FALSE if\n   the query is false, and PM_STRING_QUERY_ERROR if the encoding was invalid."]
    pub fn pm_string_query_method_name(
        source: *const u8,
        length: usize,
        encoding_name: *const ::std::os::raw::c_char,
    ) -> pm_string_query_t;
}
pub type mrc_bool = bool;
pub type mrc_int = i64;
pub type mrc_uint = u64;
pub type mrc_float = f64;
pub type mrc_sym = u32;
pub type mrc_code = u8;
#[doc = " \\class mrb_aspec\n\n Specifies the number of arguments a function takes\n\n Example: `MRB_ARGS_REQ(2) | MRB_ARGS_OPT(1)` for a method that expects 2..3 arguments"]
pub type mrc_aspec = u32;
pub const mrc_diagnostic_code_MRC_PARSER_WARNING: mrc_diagnostic_code = 0;
pub const mrc_diagnostic_code_MRC_PARSER_ERROR: mrc_diagnostic_code = 1;
pub const mrc_diagnostic_code_MRC_GENERATOR_WARNING: mrc_diagnostic_code = 2;
pub const mrc_diagnostic_code_MRC_GENERATOR_ERROR: mrc_diagnostic_code = 3;
pub type mrc_diagnostic_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_diagnostic_list {
    pub code: mrc_diagnostic_code,
    pub message: *mut ::std::os::raw::c_char,
    pub line: u32,
    pub column: u32,
    pub next: *mut mrc_diagnostic_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_diagnostic_list"][::std::mem::size_of::<mrc_diagnostic_list>() - 32usize];
    ["Alignment of mrc_diagnostic_list"][::std::mem::align_of::<mrc_diagnostic_list>() - 8usize];
    ["Offset of field: mrc_diagnostic_list::code"]
        [::std::mem::offset_of!(mrc_diagnostic_list, code) - 0usize];
    ["Offset of field: mrc_diagnostic_list::message"]
        [::std::mem::offset_of!(mrc_diagnostic_list, message) - 8usize];
    ["Offset of field: mrc_diagnostic_list::line"]
        [::std::mem::offset_of!(mrc_diagnostic_list, line) - 16usize];
    ["Offset of field: mrc_diagnostic_list::column"]
        [::std::mem::offset_of!(mrc_diagnostic_list, column) - 20usize];
    ["Offset of field: mrc_diagnostic_list::next"]
        [::std::mem::offset_of!(mrc_diagnostic_list, next) - 24usize];
};
unsafe extern "C" {
    pub fn mrc_diagnostic_list_append(
        c: *mut mrc_ccontext,
        location_start: *const u8,
        message: *const ::std::os::raw::c_char,
        code: mrc_diagnostic_code,
    );
}
unsafe extern "C" {
    pub fn mrc_diagnostic_list_free(c: *mut mrc_ccontext);
}
pub type jmp_buf = [::std::os::raw::c_int; 48usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 49usize];
unsafe extern "C" {
    pub fn setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn longjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _longjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn sigsetjmp(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn siglongjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn longjmperror();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_jmpbuf {
    pub impl_: jmp_buf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_jmpbuf"][::std::mem::size_of::<mrc_jmpbuf>() - 192usize];
    ["Alignment of mrc_jmpbuf"][::std::mem::align_of::<mrc_jmpbuf>() - 4usize];
    ["Offset of field: mrc_jmpbuf::impl_"][::std::mem::offset_of!(mrc_jmpbuf, impl_) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_pool {
    pub c: *mut mrc_ccontext,
    pub pages: *mut mrc_pool_page,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_pool"][::std::mem::size_of::<mrc_pool>() - 16usize];
    ["Alignment of mrc_pool"][::std::mem::align_of::<mrc_pool>() - 8usize];
    ["Offset of field: mrc_pool::c"][::std::mem::offset_of!(mrc_pool, c) - 0usize];
    ["Offset of field: mrc_pool::pages"][::std::mem::offset_of!(mrc_pool, pages) - 8usize];
};
unsafe extern "C" {
    pub fn mrc_pool_open(c: *mut mrc_ccontext) -> *mut mrc_pool;
}
unsafe extern "C" {
    pub fn mrc_pool_close(pool: *mut mrc_pool);
}
unsafe extern "C" {
    pub fn mrc_pool_alloc(pool: *mut mrc_pool, len: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mrc_pool_realloc(
        pool: *mut mrc_pool,
        p: *mut ::std::os::raw::c_void,
        oldlen: usize,
        newlen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " This is the base structure that represents a node in the syntax tree. It is\n embedded into every node type."]
pub type mrc_node = pm_node_t;
#[doc = " This struct represents the overall parser. It contains a reference to the\n source file, as well as pointers that indicate where in the source it's\n currently parsing. It also contains the most recent and current token that\n it's considering."]
pub type mrc_parser_state = pm_parser_t;
#[doc = " A list of constant IDs. Usually used to represent a set of locals."]
pub type mrc_constant_id_list = pm_constant_id_list_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_parse_result_t {
    pub parser: pm_parser_t,
    pub options: pm_options_t,
    pub input: pm_string_t,
    pub parsed: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parse_result_t"][::std::mem::size_of::<pm_parse_result_t>() - 848usize];
    ["Alignment of pm_parse_result_t"][::std::mem::align_of::<pm_parse_result_t>() - 8usize];
    ["Offset of field: pm_parse_result_t::parser"]
        [::std::mem::offset_of!(pm_parse_result_t, parser) - 0usize];
    ["Offset of field: pm_parse_result_t::options"]
        [::std::mem::offset_of!(pm_parse_result_t, options) - 712usize];
    ["Offset of field: pm_parse_result_t::input"]
        [::std::mem::offset_of!(pm_parse_result_t, input) - 816usize];
    ["Offset of field: pm_parse_result_t::parsed"]
        [::std::mem::offset_of!(pm_parse_result_t, parsed) - 840usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_filename_table {
    pub filename: *const ::std::os::raw::c_char,
    pub start: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_filename_table"][::std::mem::size_of::<mrc_filename_table>() - 16usize];
    ["Alignment of mrc_filename_table"][::std::mem::align_of::<mrc_filename_table>() - 8usize];
    ["Offset of field: mrc_filename_table::filename"]
        [::std::mem::offset_of!(mrc_filename_table, filename) - 0usize];
    ["Offset of field: mrc_filename_table::start"]
        [::std::mem::offset_of!(mrc_filename_table, start) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_ccontext {
    pub mrb: *mut ::std::os::raw::c_void,
    pub jmp: *mut mrc_jmpbuf,
    pub p: *mut mrc_parser_state,
    pub options: *mut pm_options_t,
    pub slen: ::std::os::raw::c_int,
    pub filename: *mut ::std::os::raw::c_char,
    pub lineno: u16,
    pub target_class: *mut RClass,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub diagnostic_list: *mut mrc_diagnostic_list,
    pub scope_sp: u16,
    pub pool: *mut mrc_pool,
    pub filename_table: *mut mrc_filename_table,
    pub filename_table_length: u16,
    pub current_filename_index: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_ccontext"][::std::mem::size_of::<mrc_ccontext>() - 112usize];
    ["Alignment of mrc_ccontext"][::std::mem::align_of::<mrc_ccontext>() - 8usize];
    ["Offset of field: mrc_ccontext::mrb"][::std::mem::offset_of!(mrc_ccontext, mrb) - 0usize];
    ["Offset of field: mrc_ccontext::jmp"][::std::mem::offset_of!(mrc_ccontext, jmp) - 8usize];
    ["Offset of field: mrc_ccontext::p"][::std::mem::offset_of!(mrc_ccontext, p) - 16usize];
    ["Offset of field: mrc_ccontext::options"]
        [::std::mem::offset_of!(mrc_ccontext, options) - 24usize];
    ["Offset of field: mrc_ccontext::slen"][::std::mem::offset_of!(mrc_ccontext, slen) - 32usize];
    ["Offset of field: mrc_ccontext::filename"]
        [::std::mem::offset_of!(mrc_ccontext, filename) - 40usize];
    ["Offset of field: mrc_ccontext::lineno"]
        [::std::mem::offset_of!(mrc_ccontext, lineno) - 48usize];
    ["Offset of field: mrc_ccontext::target_class"]
        [::std::mem::offset_of!(mrc_ccontext, target_class) - 56usize];
    ["Offset of field: mrc_ccontext::diagnostic_list"]
        [::std::mem::offset_of!(mrc_ccontext, diagnostic_list) - 72usize];
    ["Offset of field: mrc_ccontext::scope_sp"]
        [::std::mem::offset_of!(mrc_ccontext, scope_sp) - 80usize];
    ["Offset of field: mrc_ccontext::pool"][::std::mem::offset_of!(mrc_ccontext, pool) - 88usize];
    ["Offset of field: mrc_ccontext::filename_table"]
        [::std::mem::offset_of!(mrc_ccontext, filename_table) - 96usize];
    ["Offset of field: mrc_ccontext::filename_table_length"]
        [::std::mem::offset_of!(mrc_ccontext, filename_table_length) - 104usize];
    ["Offset of field: mrc_ccontext::current_filename_index"]
        [::std::mem::offset_of!(mrc_ccontext, current_filename_index) - 106usize];
};
impl mrc_ccontext {
    #[inline]
    pub fn capture_errors(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_capture_errors(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn capture_errors_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_capture_errors_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dump_result(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dump_result(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dump_result_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dump_result_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_exec(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_exec(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_exec_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_exec_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn keep_lv(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keep_lv(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn keep_lv_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_keep_lv_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_optimize(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_optimize(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_optimize_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_optimize_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_ext_ops(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_ext_ops(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_ext_ops_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_ext_ops_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        capture_errors: mrc_bool,
        dump_result: mrc_bool,
        no_exec: mrc_bool,
        keep_lv: mrc_bool,
        no_optimize: mrc_bool,
        no_ext_ops: mrc_bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let capture_errors: u8 = unsafe { ::std::mem::transmute(capture_errors) };
            capture_errors as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dump_result: u8 = unsafe { ::std::mem::transmute(dump_result) };
            dump_result as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_exec: u8 = unsafe { ::std::mem::transmute(no_exec) };
            no_exec as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let keep_lv: u8 = unsafe { ::std::mem::transmute(keep_lv) };
            keep_lv as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let no_optimize: u8 = unsafe { ::std::mem::transmute(no_optimize) };
            no_optimize as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let no_ext_ops: u8 = unsafe { ::std::mem::transmute(no_ext_ops) };
            no_ext_ops as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn mrc_ccontext_new(mrb: *mut ::std::os::raw::c_void) -> *mut mrc_ccontext;
}
unsafe extern "C" {
    pub fn mrc_ccontext_cleanup_local_variables(c: *mut mrc_ccontext);
}
unsafe extern "C" {
    pub fn mrc_ccontext_filename(
        c: *mut mrc_ccontext,
        s: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mrc_ccontext_free(c: *mut mrc_ccontext);
}
pub const irep_pool_type_IREP_TT_STR: irep_pool_type = 0;
pub const irep_pool_type_IREP_TT_SSTR: irep_pool_type = 2;
pub const irep_pool_type_IREP_TT_INT32: irep_pool_type = 1;
pub const irep_pool_type_IREP_TT_INT64: irep_pool_type = 3;
pub const irep_pool_type_IREP_TT_BIGINT: irep_pool_type = 7;
pub const irep_pool_type_IREP_TT_FLOAT: irep_pool_type = 5;
#[doc = " Compiled mruby scripts."]
pub type irep_pool_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mrc_pool_value {
    pub tt: u32,
    pub u: mrc_pool_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mrc_pool_value__bindgen_ty_1 {
    pub str_: *const ::std::os::raw::c_char,
    pub i32_: i32,
    pub i64_: i64,
    pub f: mrc_float,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_pool_value__bindgen_ty_1"]
        [::std::mem::size_of::<mrc_pool_value__bindgen_ty_1>() - 8usize];
    ["Alignment of mrc_pool_value__bindgen_ty_1"]
        [::std::mem::align_of::<mrc_pool_value__bindgen_ty_1>() - 8usize];
    ["Offset of field: mrc_pool_value__bindgen_ty_1::str_"]
        [::std::mem::offset_of!(mrc_pool_value__bindgen_ty_1, str_) - 0usize];
    ["Offset of field: mrc_pool_value__bindgen_ty_1::i32_"]
        [::std::mem::offset_of!(mrc_pool_value__bindgen_ty_1, i32_) - 0usize];
    ["Offset of field: mrc_pool_value__bindgen_ty_1::i64_"]
        [::std::mem::offset_of!(mrc_pool_value__bindgen_ty_1, i64_) - 0usize];
    ["Offset of field: mrc_pool_value__bindgen_ty_1::f"]
        [::std::mem::offset_of!(mrc_pool_value__bindgen_ty_1, f) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_pool_value"][::std::mem::size_of::<mrc_pool_value>() - 16usize];
    ["Alignment of mrc_pool_value"][::std::mem::align_of::<mrc_pool_value>() - 8usize];
    ["Offset of field: mrc_pool_value::tt"][::std::mem::offset_of!(mrc_pool_value, tt) - 0usize];
    ["Offset of field: mrc_pool_value::u"][::std::mem::offset_of!(mrc_pool_value, u) - 8usize];
};
pub const mrc_catch_type_MRC_CATCH_RESCUE: mrc_catch_type = 0;
pub const mrc_catch_type_MRC_CATCH_ENSURE: mrc_catch_type = 1;
pub type mrc_catch_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_irep_catch_handler {
    pub type_: u8,
    pub begin: [u8; 4usize],
    pub end: [u8; 4usize],
    pub target: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_irep_catch_handler"][::std::mem::size_of::<mrc_irep_catch_handler>() - 13usize];
    ["Alignment of mrc_irep_catch_handler"]
        [::std::mem::align_of::<mrc_irep_catch_handler>() - 1usize];
    ["Offset of field: mrc_irep_catch_handler::type_"]
        [::std::mem::offset_of!(mrc_irep_catch_handler, type_) - 0usize];
    ["Offset of field: mrc_irep_catch_handler::begin"]
        [::std::mem::offset_of!(mrc_irep_catch_handler, begin) - 1usize];
    ["Offset of field: mrc_irep_catch_handler::end"]
        [::std::mem::offset_of!(mrc_irep_catch_handler, end) - 5usize];
    ["Offset of field: mrc_irep_catch_handler::target"]
        [::std::mem::offset_of!(mrc_irep_catch_handler, target) - 9usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_irep {
    pub nlocals: u16,
    pub nregs: u16,
    pub clen: u16,
    pub flags: u8,
    pub iseq: *const mrc_code,
    pub pool: *const mrc_pool_value,
    pub syms: *const mrc_sym,
    pub reps: *const *const mrc_irep,
    pub lv: *mut mrc_sym,
    pub debug_info: *mut mrc_irep_debug_info,
    pub ilen: u32,
    pub plen: u16,
    pub slen: u16,
    pub rlen: u16,
    pub refcnt: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_irep"][::std::mem::size_of::<mrc_irep>() - 72usize];
    ["Alignment of mrc_irep"][::std::mem::align_of::<mrc_irep>() - 8usize];
    ["Offset of field: mrc_irep::nlocals"][::std::mem::offset_of!(mrc_irep, nlocals) - 0usize];
    ["Offset of field: mrc_irep::nregs"][::std::mem::offset_of!(mrc_irep, nregs) - 2usize];
    ["Offset of field: mrc_irep::clen"][::std::mem::offset_of!(mrc_irep, clen) - 4usize];
    ["Offset of field: mrc_irep::flags"][::std::mem::offset_of!(mrc_irep, flags) - 6usize];
    ["Offset of field: mrc_irep::iseq"][::std::mem::offset_of!(mrc_irep, iseq) - 8usize];
    ["Offset of field: mrc_irep::pool"][::std::mem::offset_of!(mrc_irep, pool) - 16usize];
    ["Offset of field: mrc_irep::syms"][::std::mem::offset_of!(mrc_irep, syms) - 24usize];
    ["Offset of field: mrc_irep::reps"][::std::mem::offset_of!(mrc_irep, reps) - 32usize];
    ["Offset of field: mrc_irep::lv"][::std::mem::offset_of!(mrc_irep, lv) - 40usize];
    ["Offset of field: mrc_irep::debug_info"]
        [::std::mem::offset_of!(mrc_irep, debug_info) - 48usize];
    ["Offset of field: mrc_irep::ilen"][::std::mem::offset_of!(mrc_irep, ilen) - 56usize];
    ["Offset of field: mrc_irep::plen"][::std::mem::offset_of!(mrc_irep, plen) - 60usize];
    ["Offset of field: mrc_irep::slen"][::std::mem::offset_of!(mrc_irep, slen) - 62usize];
    ["Offset of field: mrc_irep::rlen"][::std::mem::offset_of!(mrc_irep, rlen) - 64usize];
    ["Offset of field: mrc_irep::refcnt"][::std::mem::offset_of!(mrc_irep, refcnt) - 66usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_insn_data {
    pub insn: u8,
    pub a: u32,
    pub b: u16,
    pub cc: u16,
    pub addr: *const mrc_code,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_insn_data"][::std::mem::size_of::<mrc_insn_data>() - 24usize];
    ["Alignment of mrc_insn_data"][::std::mem::align_of::<mrc_insn_data>() - 8usize];
    ["Offset of field: mrc_insn_data::insn"][::std::mem::offset_of!(mrc_insn_data, insn) - 0usize];
    ["Offset of field: mrc_insn_data::a"][::std::mem::offset_of!(mrc_insn_data, a) - 4usize];
    ["Offset of field: mrc_insn_data::b"][::std::mem::offset_of!(mrc_insn_data, b) - 8usize];
    ["Offset of field: mrc_insn_data::cc"][::std::mem::offset_of!(mrc_insn_data, cc) - 10usize];
    ["Offset of field: mrc_insn_data::addr"][::std::mem::offset_of!(mrc_insn_data, addr) - 16usize];
};
unsafe extern "C" {
    pub fn mrc_irep_remove_lv(c: *mut mrc_ccontext, irep: *mut mrc_irep);
}
unsafe extern "C" {
    pub fn mrc_irep_free(c: *mut mrc_ccontext, irep: *mut mrc_irep);
}
unsafe extern "C" {
    pub fn mrc_load_file_cxt(
        c: *mut mrc_ccontext,
        filenames: *mut *const ::std::os::raw::c_char,
        source: *mut *mut u8,
    ) -> *mut mrc_irep;
}
unsafe extern "C" {
    pub fn mrc_load_string_cxt(
        c: *mut mrc_ccontext,
        source: *mut *const u8,
        length: usize,
    ) -> *mut mrc_irep;
}
unsafe extern "C" {
    pub fn mrc_dump_irep_cfunc(
        c: *mut mrc_ccontext,
        irep: *const mrc_irep,
        flags: u8,
        fp: *mut FILE,
        initname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrc_dump_irep_binary(
        c: *mut mrc_ccontext,
        irep: *const mrc_irep,
        flags: u8,
        fp: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrc_dump_irep(
        c: *mut mrc_ccontext,
        irep: *const mrc_irep,
        flags: u8,
        bin: *mut *mut u8,
        bin_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_binary_header {
    pub binary_ident: [u8; 4usize],
    pub major_version: [u8; 2usize],
    pub minor_version: [u8; 2usize],
    pub binary_size: [u8; 4usize],
    pub compiler_name: [u8; 4usize],
    pub compiler_version: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_binary_header"][::std::mem::size_of::<rite_binary_header>() - 20usize];
    ["Alignment of rite_binary_header"][::std::mem::align_of::<rite_binary_header>() - 1usize];
    ["Offset of field: rite_binary_header::binary_ident"]
        [::std::mem::offset_of!(rite_binary_header, binary_ident) - 0usize];
    ["Offset of field: rite_binary_header::major_version"]
        [::std::mem::offset_of!(rite_binary_header, major_version) - 4usize];
    ["Offset of field: rite_binary_header::minor_version"]
        [::std::mem::offset_of!(rite_binary_header, minor_version) - 6usize];
    ["Offset of field: rite_binary_header::binary_size"]
        [::std::mem::offset_of!(rite_binary_header, binary_size) - 8usize];
    ["Offset of field: rite_binary_header::compiler_name"]
        [::std::mem::offset_of!(rite_binary_header, compiler_name) - 12usize];
    ["Offset of field: rite_binary_header::compiler_version"]
        [::std::mem::offset_of!(rite_binary_header, compiler_version) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_section_header {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_section_header"][::std::mem::size_of::<rite_section_header>() - 8usize];
    ["Alignment of rite_section_header"][::std::mem::align_of::<rite_section_header>() - 1usize];
    ["Offset of field: rite_section_header::section_ident"]
        [::std::mem::offset_of!(rite_section_header, section_ident) - 0usize];
    ["Offset of field: rite_section_header::section_size"]
        [::std::mem::offset_of!(rite_section_header, section_size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_section_irep_header {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
    pub rite_version: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_section_irep_header"]
        [::std::mem::size_of::<rite_section_irep_header>() - 12usize];
    ["Alignment of rite_section_irep_header"]
        [::std::mem::align_of::<rite_section_irep_header>() - 1usize];
    ["Offset of field: rite_section_irep_header::section_ident"]
        [::std::mem::offset_of!(rite_section_irep_header, section_ident) - 0usize];
    ["Offset of field: rite_section_irep_header::section_size"]
        [::std::mem::offset_of!(rite_section_irep_header, section_size) - 4usize];
    ["Offset of field: rite_section_irep_header::rite_version"]
        [::std::mem::offset_of!(rite_section_irep_header, rite_version) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_section_debug_header {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_section_debug_header"]
        [::std::mem::size_of::<rite_section_debug_header>() - 8usize];
    ["Alignment of rite_section_debug_header"]
        [::std::mem::align_of::<rite_section_debug_header>() - 1usize];
    ["Offset of field: rite_section_debug_header::section_ident"]
        [::std::mem::offset_of!(rite_section_debug_header, section_ident) - 0usize];
    ["Offset of field: rite_section_debug_header::section_size"]
        [::std::mem::offset_of!(rite_section_debug_header, section_size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_section_lv_header {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_section_lv_header"][::std::mem::size_of::<rite_section_lv_header>() - 8usize];
    ["Alignment of rite_section_lv_header"]
        [::std::mem::align_of::<rite_section_lv_header>() - 1usize];
    ["Offset of field: rite_section_lv_header::section_ident"]
        [::std::mem::offset_of!(rite_section_lv_header, section_ident) - 0usize];
    ["Offset of field: rite_section_lv_header::section_size"]
        [::std::mem::offset_of!(rite_section_lv_header, section_size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_binary_footer {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_binary_footer"][::std::mem::size_of::<rite_binary_footer>() - 8usize];
    ["Alignment of rite_binary_footer"][::std::mem::align_of::<rite_binary_footer>() - 1usize];
    ["Offset of field: rite_binary_footer::section_ident"]
        [::std::mem::offset_of!(rite_binary_footer, section_ident) - 0usize];
    ["Offset of field: rite_binary_footer::section_size"]
        [::std::mem::offset_of!(rite_binary_footer, section_size) - 4usize];
};
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_pool_page {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RClass {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_irep_debug_info {
    pub _address: u8,
}
