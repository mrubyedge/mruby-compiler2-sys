/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __USE_TIME_BITS64: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const _BSD_SOURCE: u32 = 1;
pub const _XOPEN_SOURCE: u32 = 700;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const MB_LEN_MAX: u32 = 4;
pub const PAGESIZE: u32 = 65536;
pub const FILESIZEBITS: u32 = 64;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const NGROUPS_MAX: u32 = 32;
pub const ARG_MAX: u32 = 131072;
pub const IOV_MAX: u32 = 1024;
pub const SYMLOOP_MAX: u32 = 40;
pub const WORD_BIT: u32 = 32;
pub const TZNAME_MAX: u32 = 6;
pub const TTY_NAME_MAX: u32 = 32;
pub const HOST_NAME_MAX: u32 = 255;
pub const LONG_BIT: u32 = 32;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const RE_DUP_MAX: u32 = 255;
pub const NL_ARGMAX: u32 = 9;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const PAGE_SIZE: u32 = 65536;
pub const NZERO: u32 = 20;
pub const NL_LANGMAX: u32 = 32;
pub const NL_NMAX: u32 = 16;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 2;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 1000;
pub const L_ctermid: u32 = 20;
pub const L_cuserid: u32 = 20;
pub const __PDP_ENDIAN: u32 = 3412;
pub const BIG_ENDIAN: u32 = 4321;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const PDP_ENDIAN: u32 = 3412;
pub const FD_SETSIZE: u32 = 1024;
pub const PRISM_DEPTH_MAXIMUM: u32 = 10000;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const POSIX_CLOSE_RESTART: u32 = 0;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 1;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_VDISABLE: u32 = 0;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 200809;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX_V6_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFFBIG: u32 = 1;
pub const _PC_LINK_MAX: u32 = 0;
pub const _PC_MAX_CANON: u32 = 1;
pub const _PC_MAX_INPUT: u32 = 2;
pub const _PC_NAME_MAX: u32 = 3;
pub const _PC_PATH_MAX: u32 = 4;
pub const _PC_PIPE_BUF: u32 = 5;
pub const _PC_CHOWN_RESTRICTED: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_SYNC_IO: u32 = 9;
pub const _PC_ASYNC_IO: u32 = 10;
pub const _PC_PRIO_IO: u32 = 11;
pub const _PC_SOCK_MAXBUF: u32 = 12;
pub const _PC_FILESIZEBITS: u32 = 13;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 14;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 15;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 16;
pub const _PC_REC_XFER_ALIGN: u32 = 17;
pub const _PC_ALLOC_SIZE_MIN: u32 = 18;
pub const _PC_SYMLINK_MAX: u32 = 19;
pub const _PC_2_SYMLINKS: u32 = 20;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_CHILD_MAX: u32 = 1;
pub const _SC_CLK_TCK: u32 = 2;
pub const _SC_NGROUPS_MAX: u32 = 3;
pub const _SC_OPEN_MAX: u32 = 4;
pub const _SC_STREAM_MAX: u32 = 5;
pub const _SC_TZNAME_MAX: u32 = 6;
pub const _SC_JOB_CONTROL: u32 = 7;
pub const _SC_SAVED_IDS: u32 = 8;
pub const _SC_REALTIME_SIGNALS: u32 = 9;
pub const _SC_PRIORITY_SCHEDULING: u32 = 10;
pub const _SC_TIMERS: u32 = 11;
pub const _SC_ASYNCHRONOUS_IO: u32 = 12;
pub const _SC_PRIORITIZED_IO: u32 = 13;
pub const _SC_SYNCHRONIZED_IO: u32 = 14;
pub const _SC_FSYNC: u32 = 15;
pub const _SC_MAPPED_FILES: u32 = 16;
pub const _SC_MEMLOCK: u32 = 17;
pub const _SC_MEMLOCK_RANGE: u32 = 18;
pub const _SC_MEMORY_PROTECTION: u32 = 19;
pub const _SC_MESSAGE_PASSING: u32 = 20;
pub const _SC_SEMAPHORES: u32 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 22;
pub const _SC_AIO_LISTIO_MAX: u32 = 23;
pub const _SC_AIO_MAX: u32 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 25;
pub const _SC_DELAYTIMER_MAX: u32 = 26;
pub const _SC_MQ_OPEN_MAX: u32 = 27;
pub const _SC_MQ_PRIO_MAX: u32 = 28;
pub const _SC_VERSION: u32 = 29;
pub const _SC_PAGE_SIZE: u32 = 30;
pub const _SC_PAGESIZE: u32 = 30;
pub const _SC_RTSIG_MAX: u32 = 31;
pub const _SC_SEM_NSEMS_MAX: u32 = 32;
pub const _SC_SEM_VALUE_MAX: u32 = 33;
pub const _SC_SIGQUEUE_MAX: u32 = 34;
pub const _SC_TIMER_MAX: u32 = 35;
pub const _SC_BC_BASE_MAX: u32 = 36;
pub const _SC_BC_DIM_MAX: u32 = 37;
pub const _SC_BC_SCALE_MAX: u32 = 38;
pub const _SC_BC_STRING_MAX: u32 = 39;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 40;
pub const _SC_EXPR_NEST_MAX: u32 = 42;
pub const _SC_LINE_MAX: u32 = 43;
pub const _SC_RE_DUP_MAX: u32 = 44;
pub const _SC_2_VERSION: u32 = 46;
pub const _SC_2_C_BIND: u32 = 47;
pub const _SC_2_C_DEV: u32 = 48;
pub const _SC_2_FORT_DEV: u32 = 49;
pub const _SC_2_FORT_RUN: u32 = 50;
pub const _SC_2_SW_DEV: u32 = 51;
pub const _SC_2_LOCALEDEF: u32 = 52;
pub const _SC_UIO_MAXIOV: u32 = 60;
pub const _SC_IOV_MAX: u32 = 60;
pub const _SC_THREADS: u32 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 68;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 69;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 70;
pub const _SC_LOGIN_NAME_MAX: u32 = 71;
pub const _SC_TTY_NAME_MAX: u32 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 73;
pub const _SC_THREAD_KEYS_MAX: u32 = 74;
pub const _SC_THREAD_STACK_MIN: u32 = 75;
pub const _SC_THREAD_THREADS_MAX: u32 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 79;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 80;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 81;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 82;
pub const _SC_NPROCESSORS_CONF: u32 = 83;
pub const _SC_NPROCESSORS_ONLN: u32 = 84;
pub const _SC_PHYS_PAGES: u32 = 85;
pub const _SC_AVPHYS_PAGES: u32 = 86;
pub const _SC_ATEXIT_MAX: u32 = 87;
pub const _SC_PASS_MAX: u32 = 88;
pub const _SC_XOPEN_VERSION: u32 = 89;
pub const _SC_XOPEN_XCU_VERSION: u32 = 90;
pub const _SC_XOPEN_UNIX: u32 = 91;
pub const _SC_XOPEN_CRYPT: u32 = 92;
pub const _SC_XOPEN_ENH_I18N: u32 = 93;
pub const _SC_XOPEN_SHM: u32 = 94;
pub const _SC_2_CHAR_TERM: u32 = 95;
pub const _SC_2_UPE: u32 = 97;
pub const _SC_XOPEN_XPG2: u32 = 98;
pub const _SC_XOPEN_XPG3: u32 = 99;
pub const _SC_XOPEN_XPG4: u32 = 100;
pub const _SC_NZERO: u32 = 109;
pub const _SC_XBS5_ILP32_OFF32: u32 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 126;
pub const _SC_XBS5_LP64_OFF64: u32 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 128;
pub const _SC_XOPEN_LEGACY: u32 = 129;
pub const _SC_XOPEN_REALTIME: u32 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 131;
pub const _SC_ADVISORY_INFO: u32 = 132;
pub const _SC_BARRIERS: u32 = 133;
pub const _SC_CLOCK_SELECTION: u32 = 137;
pub const _SC_CPUTIME: u32 = 138;
pub const _SC_THREAD_CPUTIME: u32 = 139;
pub const _SC_MONOTONIC_CLOCK: u32 = 149;
pub const _SC_READER_WRITER_LOCKS: u32 = 153;
pub const _SC_SPIN_LOCKS: u32 = 154;
pub const _SC_REGEXP: u32 = 155;
pub const _SC_SHELL: u32 = 157;
pub const _SC_SPAWN: u32 = 159;
pub const _SC_SPORADIC_SERVER: u32 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 161;
pub const _SC_TIMEOUTS: u32 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 165;
pub const _SC_2_PBS: u32 = 168;
pub const _SC_2_PBS_ACCOUNTING: u32 = 169;
pub const _SC_2_PBS_LOCATE: u32 = 170;
pub const _SC_2_PBS_MESSAGE: u32 = 171;
pub const _SC_2_PBS_TRACK: u32 = 172;
pub const _SC_SYMLOOP_MAX: u32 = 173;
pub const _SC_STREAMS: u32 = 174;
pub const _SC_2_PBS_CHECKPOINT: u32 = 175;
pub const _SC_V6_ILP32_OFF32: u32 = 176;
pub const _SC_V6_ILP32_OFFBIG: u32 = 177;
pub const _SC_V6_LP64_OFF64: u32 = 178;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 179;
pub const _SC_HOST_NAME_MAX: u32 = 180;
pub const _SC_TRACE: u32 = 181;
pub const _SC_TRACE_EVENT_FILTER: u32 = 182;
pub const _SC_TRACE_INHERIT: u32 = 183;
pub const _SC_TRACE_LOG: u32 = 184;
pub const _SC_IPV6: u32 = 235;
pub const _SC_RAW_SOCKETS: u32 = 236;
pub const _SC_V7_ILP32_OFF32: u32 = 237;
pub const _SC_V7_ILP32_OFFBIG: u32 = 238;
pub const _SC_V7_LP64_OFF64: u32 = 239;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 240;
pub const _SC_SS_REPL_MAX: u32 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 242;
pub const _SC_TRACE_NAME_MAX: u32 = 243;
pub const _SC_TRACE_SYS_MAX: u32 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 245;
pub const _SC_XOPEN_STREAMS: u32 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 248;
pub const _CS_PATH: u32 = 0;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 1;
pub const _CS_GNU_LIBC_VERSION: u32 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: u32 = 3;
pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS: u32 = 4;
pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: u32 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: u32 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: u32 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: u32 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: u32 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: u32 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: u32 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: u32 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: u32 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: u32 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: u32 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: u32 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: u32 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: u32 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: u32 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: u32 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: u32 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: u32 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: u32 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: u32 = 1147;
pub const _CS_V6_ENV: u32 = 1148;
pub const _CS_V7_ENV: u32 = 1149;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const PRISM_ENCODING_ALPHABETIC_BIT: u32 = 1;
pub const PRISM_ENCODING_ALPHANUMERIC_BIT: u32 = 2;
pub const PRISM_ENCODING_UPPERCASE_BIT: u32 = 4;
pub const PM_CONSTANT_ID_UNSET: u32 = 0;
pub const S_IFBLK: u32 = 24576;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFLNK: u32 = 40960;
pub const S_IFREG: u32 = 32768;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFIFO: u32 = 4096;
pub const S_IXOTH: u32 = 1;
pub const S_IWOTH: u32 = 2;
pub const S_IROTH: u32 = 4;
pub const S_IRWXO: u32 = 7;
pub const S_IXGRP: u32 = 8;
pub const S_IWGRP: u32 = 16;
pub const S_IRGRP: u32 = 32;
pub const S_IRWXG: u32 = 56;
pub const S_IXUSR: u32 = 64;
pub const S_IWUSR: u32 = 128;
pub const S_IRUSR: u32 = 256;
pub const S_IRWXU: u32 = 448;
pub const S_ISVTX: u32 = 512;
pub const S_ISGID: u32 = 1024;
pub const S_ISUID: u32 = 2048;
pub const O_NOFOLLOW: u32 = 16777216;
pub const O_EXEC: u32 = 33554432;
pub const O_RDONLY: u32 = 67108864;
pub const O_SEARCH: u32 = 134217728;
pub const O_WRONLY: u32 = 268435456;
pub const O_CLOEXEC: u32 = 0;
pub const O_TTY_INIT: u32 = 0;
pub const O_NOCTTY: u32 = 0;
pub const O_RDWR: u32 = 335544320;
pub const O_ACCMODE: u32 = 503316480;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const FD_CLOEXEC: u32 = 1;
pub const AT_EACCESS: u32 = 0;
pub const AT_SYMLINK_NOFOLLOW: u32 = 1;
pub const AT_SYMLINK_FOLLOW: u32 = 2;
pub const AT_REMOVEDIR: u32 = 4;
pub const AT_FDCWD: i32 = -2;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const PRISM_SERIALIZE_ONLY_SEMANTICS_FIELDS: u32 = 0;
pub const PM_LEX_STACK_SIZE: u32 = 4;
pub const PRISM_VERSION_MAJOR: u32 = 1;
pub const PRISM_VERSION_MINOR: u32 = 4;
pub const PRISM_VERSION_PATCH: u32 = 0;
pub const PRISM_VERSION: &[u8; 6] = b"1.4.0\0";
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_ALL_MASK: u32 = 2147483647;
pub const MRC_RELEASE_YEAR: u32 = 2024;
pub const MRC_RELEASE_MONTH: u32 = 9;
pub const MRC_RELEASE_DAY: u32 = 9;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const MRC_INT64: u32 = 1;
pub const MRC_64BIT: u32 = 1;
pub const MRC_INT_BIT: u32 = 64;
pub const MRC_INT_MIN: i64 = -9223372036854775808;
pub const MRC_INT_MAX: u64 = 9223372036854775807;
pub const IREP_TT_NFLAG: u32 = 1;
pub const IREP_TT_SFLAG: u32 = 2;
pub const MRC_ISEQ_NO_FREE: u32 = 1;
pub const MRC_IREP_NO_FREE: u32 = 2;
pub const MRC_DUMP_DEBUG_INFO: u32 = 1;
pub const MRC_DUMP_STATIC: u32 = 2;
pub const MRC_DUMP_OK: u32 = 0;
pub const MRC_DUMP_GENERAL_FAILURE: i32 = -1;
pub const MRC_DUMP_WRITE_FAULT: i32 = -2;
pub const MRC_DUMP_READ_FAULT: i32 = -3;
pub const MRC_DUMP_INVALID_FILE_HEADER: i32 = -4;
pub const MRC_DUMP_INVALID_IREP: i32 = -5;
pub const MRC_DUMP_INVALID_ARGUMENT: i32 = -6;
pub const MRC_DUMP_NULL_SYM_LEN: u32 = 65535;
pub const RITE_BINARY_IDENT: &[u8; 5] = b"RITE\0";
pub const RITE_BINARY_MAJOR_VER: &[u8; 3] = b"03\0";
pub const RITE_BINARY_MINOR_VER: &[u8; 3] = b"00\0";
pub const RITE_BINARY_FORMAT_VER: &[u8; 5] = b"0300\0";
pub const RITE_COMPILER_NAME: &[u8; 5] = b"HSMK\0";
pub const RITE_PARSER_NAME: &[u8; 6] = b"Prism\0";
pub const RITE_COMPILER_VERSION: &[u8; 5] = b"0000\0";
pub const RITE_VM_VER: &[u8; 5] = b"0300\0";
pub const RITE_BINARY_EOF: &[u8; 5] = b"END\0\0";
pub const RITE_SECTION_IREP_IDENT: &[u8; 5] = b"IREP\0";
pub const RITE_SECTION_DEBUG_IDENT: &[u8; 5] = b"DBG\0\0";
pub const RITE_SECTION_LV_IDENT: &[u8; 5] = b"LVAR\0";
pub const MRC_DUMP_DEFAULT_STR_LEN: u32 = 128;
pub const RITE_LV_NULL_MARK: u32 = 65535;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type time_t = ::std::os::raw::c_longlong;
pub type suseconds_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iovec"][::std::mem::size_of::<iovec>() - 8usize];
    ["Alignment of iovec"][::std::mem::align_of::<iovec>() - 4usize];
    ["Offset of field: iovec::iov_base"][::std::mem::offset_of!(iovec, iov_base) - 0usize];
    ["Offset of field: iovec::iov_len"][::std::mem::offset_of!(iovec, iov_len) - 4usize];
};
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_struct;
pub type float_t = f32;
pub type double_t = f64;
unsafe extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type off_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
pub type __isoc_va_list = __builtin_va_list;
pub type __wasi_size_t = ::std::os::raw::c_ulong;
#[doc = " Non-negative file size or length of a region within a file."]
pub type __wasi_filesize_t = u64;
#[doc = " Timestamp in nanoseconds."]
pub type __wasi_timestamp_t = u64;
#[doc = " Identifiers for clocks."]
pub type __wasi_clockid_t = u32;
#[doc = " Error codes returned by functions.\n Not all of these error codes are returned by the functions provided by this\n API; some are used in higher-level library layers, and others are provided\n merely for alignment with POSIX."]
pub type __wasi_errno_t = u16;
#[doc = " File descriptor rights, determining which actions may be performed."]
pub type __wasi_rights_t = u64;
#[doc = " A file descriptor handle."]
pub type __wasi_fd_t = ::std::os::raw::c_int;
#[doc = " A region of memory for scatter/gather reads."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_iovec_t {
    #[doc = " The address of the buffer to be filled."]
    pub buf: *mut u8,
    #[doc = " The length of the buffer to be filled."]
    pub buf_len: __wasi_size_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_iovec_t"][::std::mem::size_of::<__wasi_iovec_t>() - 8usize];
    ["Alignment of __wasi_iovec_t"][::std::mem::align_of::<__wasi_iovec_t>() - 4usize];
    ["Offset of field: __wasi_iovec_t::buf"][::std::mem::offset_of!(__wasi_iovec_t, buf) - 0usize];
    ["Offset of field: __wasi_iovec_t::buf_len"]
        [::std::mem::offset_of!(__wasi_iovec_t, buf_len) - 4usize];
};
#[doc = " A region of memory for scatter/gather writes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_ciovec_t {
    #[doc = " The address of the buffer to be written."]
    pub buf: *const u8,
    #[doc = " The length of the buffer to be written."]
    pub buf_len: __wasi_size_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_ciovec_t"][::std::mem::size_of::<__wasi_ciovec_t>() - 8usize];
    ["Alignment of __wasi_ciovec_t"][::std::mem::align_of::<__wasi_ciovec_t>() - 4usize];
    ["Offset of field: __wasi_ciovec_t::buf"]
        [::std::mem::offset_of!(__wasi_ciovec_t, buf) - 0usize];
    ["Offset of field: __wasi_ciovec_t::buf_len"]
        [::std::mem::offset_of!(__wasi_ciovec_t, buf_len) - 4usize];
};
#[doc = " Relative offset within a file."]
pub type __wasi_filedelta_t = i64;
#[doc = " The position relative to which to set the offset of the file descriptor."]
pub type __wasi_whence_t = u8;
#[doc = " A reference to the offset of a directory entry.\n\n The value 0 signifies the start of the directory."]
pub type __wasi_dircookie_t = u64;
#[doc = " The type for the `dirent::d_namlen` field of `dirent` struct."]
pub type __wasi_dirnamlen_t = u32;
#[doc = " File serial number that is unique within its file system."]
pub type __wasi_inode_t = u64;
#[doc = " The type of a file descriptor or file."]
pub type __wasi_filetype_t = u8;
#[doc = " A directory entry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_dirent_t {
    #[doc = " The offset of the next directory entry stored in this directory."]
    pub d_next: __wasi_dircookie_t,
    #[doc = " The serial number of the file referred to by this directory entry."]
    pub d_ino: __wasi_inode_t,
    #[doc = " The length of the name of the directory entry."]
    pub d_namlen: __wasi_dirnamlen_t,
    #[doc = " The type of the file referred to by this directory entry."]
    pub d_type: __wasi_filetype_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_dirent_t"][::std::mem::size_of::<__wasi_dirent_t>() - 24usize];
    ["Alignment of __wasi_dirent_t"][::std::mem::align_of::<__wasi_dirent_t>() - 8usize];
    ["Offset of field: __wasi_dirent_t::d_next"]
        [::std::mem::offset_of!(__wasi_dirent_t, d_next) - 0usize];
    ["Offset of field: __wasi_dirent_t::d_ino"]
        [::std::mem::offset_of!(__wasi_dirent_t, d_ino) - 8usize];
    ["Offset of field: __wasi_dirent_t::d_namlen"]
        [::std::mem::offset_of!(__wasi_dirent_t, d_namlen) - 16usize];
    ["Offset of field: __wasi_dirent_t::d_type"]
        [::std::mem::offset_of!(__wasi_dirent_t, d_type) - 20usize];
};
#[doc = " File or memory access pattern advisory information."]
pub type __wasi_advice_t = u8;
#[doc = " File descriptor flags."]
pub type __wasi_fdflags_t = u16;
#[doc = " File descriptor attributes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_fdstat_t {
    #[doc = " File type."]
    pub fs_filetype: __wasi_filetype_t,
    #[doc = " File descriptor flags."]
    pub fs_flags: __wasi_fdflags_t,
    #[doc = " Rights that apply to this file descriptor."]
    pub fs_rights_base: __wasi_rights_t,
    #[doc = " Maximum set of rights that may be installed on new file descriptors that\n are created through this file descriptor, e.g., through `path_open`."]
    pub fs_rights_inheriting: __wasi_rights_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_fdstat_t"][::std::mem::size_of::<__wasi_fdstat_t>() - 24usize];
    ["Alignment of __wasi_fdstat_t"][::std::mem::align_of::<__wasi_fdstat_t>() - 8usize];
    ["Offset of field: __wasi_fdstat_t::fs_filetype"]
        [::std::mem::offset_of!(__wasi_fdstat_t, fs_filetype) - 0usize];
    ["Offset of field: __wasi_fdstat_t::fs_flags"]
        [::std::mem::offset_of!(__wasi_fdstat_t, fs_flags) - 2usize];
    ["Offset of field: __wasi_fdstat_t::fs_rights_base"]
        [::std::mem::offset_of!(__wasi_fdstat_t, fs_rights_base) - 8usize];
    ["Offset of field: __wasi_fdstat_t::fs_rights_inheriting"]
        [::std::mem::offset_of!(__wasi_fdstat_t, fs_rights_inheriting) - 16usize];
};
#[doc = " Identifier for a device containing a file system. Can be used in combination\n with `inode` to uniquely identify a file or directory in the filesystem."]
pub type __wasi_device_t = u64;
#[doc = " Which file time attributes to adjust."]
pub type __wasi_fstflags_t = u16;
#[doc = " Flags determining the method of how paths are resolved."]
pub type __wasi_lookupflags_t = u32;
#[doc = " Open flags used by `path_open`."]
pub type __wasi_oflags_t = u16;
#[doc = " Number of hard links to an inode."]
pub type __wasi_linkcount_t = u64;
#[doc = " File attributes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_filestat_t {
    #[doc = " Device ID of device containing the file."]
    pub dev: __wasi_device_t,
    #[doc = " File serial number."]
    pub ino: __wasi_inode_t,
    #[doc = " File type."]
    pub filetype: __wasi_filetype_t,
    #[doc = " Number of hard links to the file."]
    pub nlink: __wasi_linkcount_t,
    #[doc = " For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link."]
    pub size: __wasi_filesize_t,
    #[doc = " Last data access timestamp."]
    pub atim: __wasi_timestamp_t,
    #[doc = " Last data modification timestamp."]
    pub mtim: __wasi_timestamp_t,
    #[doc = " Last file status change timestamp."]
    pub ctim: __wasi_timestamp_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_filestat_t"][::std::mem::size_of::<__wasi_filestat_t>() - 64usize];
    ["Alignment of __wasi_filestat_t"][::std::mem::align_of::<__wasi_filestat_t>() - 8usize];
    ["Offset of field: __wasi_filestat_t::dev"]
        [::std::mem::offset_of!(__wasi_filestat_t, dev) - 0usize];
    ["Offset of field: __wasi_filestat_t::ino"]
        [::std::mem::offset_of!(__wasi_filestat_t, ino) - 8usize];
    ["Offset of field: __wasi_filestat_t::filetype"]
        [::std::mem::offset_of!(__wasi_filestat_t, filetype) - 16usize];
    ["Offset of field: __wasi_filestat_t::nlink"]
        [::std::mem::offset_of!(__wasi_filestat_t, nlink) - 24usize];
    ["Offset of field: __wasi_filestat_t::size"]
        [::std::mem::offset_of!(__wasi_filestat_t, size) - 32usize];
    ["Offset of field: __wasi_filestat_t::atim"]
        [::std::mem::offset_of!(__wasi_filestat_t, atim) - 40usize];
    ["Offset of field: __wasi_filestat_t::mtim"]
        [::std::mem::offset_of!(__wasi_filestat_t, mtim) - 48usize];
    ["Offset of field: __wasi_filestat_t::ctim"]
        [::std::mem::offset_of!(__wasi_filestat_t, ctim) - 56usize];
};
#[doc = " User-provided value that may be attached to objects that is retained when\n extracted from the implementation."]
pub type __wasi_userdata_t = u64;
#[doc = " Type of a subscription to an event or its occurrence."]
pub type __wasi_eventtype_t = u8;
#[doc = " The state of the file descriptor subscribed to with\n `eventtype::fd_read` or `eventtype::fd_write`."]
pub type __wasi_eventrwflags_t = u16;
#[doc = " The contents of an `event` when type is `eventtype::fd_read` or\n `eventtype::fd_write`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_event_fd_readwrite_t {
    #[doc = " The number of bytes available for reading or writing."]
    pub nbytes: __wasi_filesize_t,
    #[doc = " The state of the file descriptor."]
    pub flags: __wasi_eventrwflags_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_event_fd_readwrite_t"]
        [::std::mem::size_of::<__wasi_event_fd_readwrite_t>() - 16usize];
    ["Alignment of __wasi_event_fd_readwrite_t"]
        [::std::mem::align_of::<__wasi_event_fd_readwrite_t>() - 8usize];
    ["Offset of field: __wasi_event_fd_readwrite_t::nbytes"]
        [::std::mem::offset_of!(__wasi_event_fd_readwrite_t, nbytes) - 0usize];
    ["Offset of field: __wasi_event_fd_readwrite_t::flags"]
        [::std::mem::offset_of!(__wasi_event_fd_readwrite_t, flags) - 8usize];
};
#[doc = " An event that occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_event_t {
    #[doc = " User-provided value that got attached to `subscription::userdata`."]
    pub userdata: __wasi_userdata_t,
    #[doc = " If non-zero, an error that occurred while processing the subscription request."]
    pub error: __wasi_errno_t,
    #[doc = " The type of event that occured"]
    pub type_: __wasi_eventtype_t,
    #[doc = " The contents of the event, if it is an `eventtype::fd_read` or\n `eventtype::fd_write`. `eventtype::clock` events ignore this field."]
    pub fd_readwrite: __wasi_event_fd_readwrite_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_event_t"][::std::mem::size_of::<__wasi_event_t>() - 32usize];
    ["Alignment of __wasi_event_t"][::std::mem::align_of::<__wasi_event_t>() - 8usize];
    ["Offset of field: __wasi_event_t::userdata"]
        [::std::mem::offset_of!(__wasi_event_t, userdata) - 0usize];
    ["Offset of field: __wasi_event_t::error"]
        [::std::mem::offset_of!(__wasi_event_t, error) - 8usize];
    ["Offset of field: __wasi_event_t::type_"]
        [::std::mem::offset_of!(__wasi_event_t, type_) - 10usize];
    ["Offset of field: __wasi_event_t::fd_readwrite"]
        [::std::mem::offset_of!(__wasi_event_t, fd_readwrite) - 16usize];
};
#[doc = " Flags determining how to interpret the timestamp provided in\n `subscription_clock::timeout`."]
pub type __wasi_subclockflags_t = u16;
#[doc = " The contents of a `subscription` when type is `eventtype::clock`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_subscription_clock_t {
    #[doc = " The clock against which to compare the timestamp."]
    pub id: __wasi_clockid_t,
    #[doc = " The absolute or relative timestamp."]
    pub timeout: __wasi_timestamp_t,
    #[doc = " The amount of time that the implementation may wait additionally\n to coalesce with other events."]
    pub precision: __wasi_timestamp_t,
    #[doc = " Flags specifying whether the timeout is absolute or relative"]
    pub flags: __wasi_subclockflags_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_subscription_clock_t"]
        [::std::mem::size_of::<__wasi_subscription_clock_t>() - 32usize];
    ["Alignment of __wasi_subscription_clock_t"]
        [::std::mem::align_of::<__wasi_subscription_clock_t>() - 8usize];
    ["Offset of field: __wasi_subscription_clock_t::id"]
        [::std::mem::offset_of!(__wasi_subscription_clock_t, id) - 0usize];
    ["Offset of field: __wasi_subscription_clock_t::timeout"]
        [::std::mem::offset_of!(__wasi_subscription_clock_t, timeout) - 8usize];
    ["Offset of field: __wasi_subscription_clock_t::precision"]
        [::std::mem::offset_of!(__wasi_subscription_clock_t, precision) - 16usize];
    ["Offset of field: __wasi_subscription_clock_t::flags"]
        [::std::mem::offset_of!(__wasi_subscription_clock_t, flags) - 24usize];
};
#[doc = " The contents of a `subscription` when type is type is\n `eventtype::fd_read` or `eventtype::fd_write`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_subscription_fd_readwrite_t {
    #[doc = " The file descriptor on which to wait for it to become ready for reading or writing."]
    pub file_descriptor: __wasi_fd_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_subscription_fd_readwrite_t"]
        [::std::mem::size_of::<__wasi_subscription_fd_readwrite_t>() - 4usize];
    ["Alignment of __wasi_subscription_fd_readwrite_t"]
        [::std::mem::align_of::<__wasi_subscription_fd_readwrite_t>() - 4usize];
    ["Offset of field: __wasi_subscription_fd_readwrite_t::file_descriptor"]
        [::std::mem::offset_of!(__wasi_subscription_fd_readwrite_t, file_descriptor) - 0usize];
};
#[doc = " The contents of a `subscription`."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_subscription_u_u_t {
    pub clock: __wasi_subscription_clock_t,
    pub fd_read: __wasi_subscription_fd_readwrite_t,
    pub fd_write: __wasi_subscription_fd_readwrite_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_subscription_u_u_t"]
        [::std::mem::size_of::<__wasi_subscription_u_u_t>() - 32usize];
    ["Alignment of __wasi_subscription_u_u_t"]
        [::std::mem::align_of::<__wasi_subscription_u_u_t>() - 8usize];
    ["Offset of field: __wasi_subscription_u_u_t::clock"]
        [::std::mem::offset_of!(__wasi_subscription_u_u_t, clock) - 0usize];
    ["Offset of field: __wasi_subscription_u_u_t::fd_read"]
        [::std::mem::offset_of!(__wasi_subscription_u_u_t, fd_read) - 0usize];
    ["Offset of field: __wasi_subscription_u_u_t::fd_write"]
        [::std::mem::offset_of!(__wasi_subscription_u_u_t, fd_write) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_u_t {
    pub tag: u8,
    pub u: __wasi_subscription_u_u_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_subscription_u_t"][::std::mem::size_of::<__wasi_subscription_u_t>() - 40usize];
    ["Alignment of __wasi_subscription_u_t"]
        [::std::mem::align_of::<__wasi_subscription_u_t>() - 8usize];
    ["Offset of field: __wasi_subscription_u_t::tag"]
        [::std::mem::offset_of!(__wasi_subscription_u_t, tag) - 0usize];
    ["Offset of field: __wasi_subscription_u_t::u"]
        [::std::mem::offset_of!(__wasi_subscription_u_t, u) - 8usize];
};
#[doc = " Subscription to an event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_t {
    #[doc = " User-provided value that is attached to the subscription in the\n implementation and returned through `event::userdata`."]
    pub userdata: __wasi_userdata_t,
    #[doc = " The type of the event to which to subscribe, and its contents"]
    pub u: __wasi_subscription_u_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_subscription_t"][::std::mem::size_of::<__wasi_subscription_t>() - 48usize];
    ["Alignment of __wasi_subscription_t"]
        [::std::mem::align_of::<__wasi_subscription_t>() - 8usize];
    ["Offset of field: __wasi_subscription_t::userdata"]
        [::std::mem::offset_of!(__wasi_subscription_t, userdata) - 0usize];
    ["Offset of field: __wasi_subscription_t::u"]
        [::std::mem::offset_of!(__wasi_subscription_t, u) - 8usize];
};
#[doc = " Exit code generated by a process when exiting."]
pub type __wasi_exitcode_t = u32;
#[doc = " Flags provided to `sock_recv`."]
pub type __wasi_riflags_t = u16;
#[doc = " Flags returned by `sock_recv`."]
pub type __wasi_roflags_t = u16;
#[doc = " Flags provided to `sock_send`. As there are currently no flags\n defined, it must be set to zero."]
pub type __wasi_siflags_t = u16;
#[doc = " Which channels on a socket to shut down."]
pub type __wasi_sdflags_t = u8;
#[doc = " Identifiers for preopened capabilities."]
pub type __wasi_preopentype_t = u8;
#[doc = " The contents of a $prestat when type is `preopentype::dir`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wasi_prestat_dir_t {
    #[doc = " The length of the directory name for use with `fd_prestat_dir_name`."]
    pub pr_name_len: __wasi_size_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_prestat_dir_t"][::std::mem::size_of::<__wasi_prestat_dir_t>() - 4usize];
    ["Alignment of __wasi_prestat_dir_t"][::std::mem::align_of::<__wasi_prestat_dir_t>() - 4usize];
    ["Offset of field: __wasi_prestat_dir_t::pr_name_len"]
        [::std::mem::offset_of!(__wasi_prestat_dir_t, pr_name_len) - 0usize];
};
#[doc = " Information about a pre-opened capability."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_prestat_u_t {
    pub dir: __wasi_prestat_dir_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_prestat_u_t"][::std::mem::size_of::<__wasi_prestat_u_t>() - 4usize];
    ["Alignment of __wasi_prestat_u_t"][::std::mem::align_of::<__wasi_prestat_u_t>() - 4usize];
    ["Offset of field: __wasi_prestat_u_t::dir"]
        [::std::mem::offset_of!(__wasi_prestat_u_t, dir) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_prestat_t {
    pub tag: u8,
    pub u: __wasi_prestat_u_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __wasi_prestat_t"][::std::mem::size_of::<__wasi_prestat_t>() - 8usize];
    ["Alignment of __wasi_prestat_t"][::std::mem::align_of::<__wasi_prestat_t>() - 4usize];
    ["Offset of field: __wasi_prestat_t::tag"]
        [::std::mem::offset_of!(__wasi_prestat_t, tag) - 0usize];
    ["Offset of field: __wasi_prestat_t::u"][::std::mem::offset_of!(__wasi_prestat_t, u) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _G_fpos64_t {
    pub __opaque: [::std::os::raw::c_char; 16usize],
    pub __lldata: ::std::os::raw::c_longlong,
    pub __align: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__opaque"]
        [::std::mem::offset_of!(_G_fpos64_t, __opaque) - 0usize];
    ["Offset of field: _G_fpos64_t::__lldata"]
        [::std::mem::offset_of!(_G_fpos64_t, __lldata) - 0usize];
    ["Offset of field: _G_fpos64_t::__align"]
        [::std::mem::offset_of!(_G_fpos64_t, __align) - 0usize];
};
pub type fpos_t = _G_fpos64_t;
unsafe extern "C" {
    pub static stdin: *mut FILE;
}
unsafe extern "C" {
    pub static stdout: *mut FILE;
}
unsafe extern "C" {
    pub static stderr: *mut FILE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __clockid {
    _unused: [u8; 0],
}
pub type clockid_t = *const __clockid;
pub type clock_t = ::std::os::raw::c_longlong;
pub type register_t = ::std::os::raw::c_longlong;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type mode_t = ::std::os::raw::c_uint;
pub type nlink_t = ::std::os::raw::c_ulonglong;
pub type ino_t = ::std::os::raw::c_ulonglong;
pub type dev_t = ::std::os::raw::c_ulonglong;
pub type blksize_t = ::std::os::raw::c_long;
pub type blkcnt_t = ::std::os::raw::c_longlong;
pub type fsblkcnt_t = ::std::os::raw::c_ulonglong;
pub type fsfilcnt_t = ::std::os::raw::c_ulonglong;
pub type timer_t = *mut ::std::os::raw::c_void;
pub type pid_t = ::std::os::raw::c_int;
pub type id_t = ::std::os::raw::c_uint;
pub type uid_t = ::std::os::raw::c_uint;
pub type gid_t = ::std::os::raw::c_uint;
pub type key_t = ::std::os::raw::c_int;
pub type useconds_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread {
    _unused: [u8; 0],
}
pub type pthread_t = *mut __pthread;
pub type pthread_once_t = ::std::os::raw::c_int;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub __attr: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__attr"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __attr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub __attr: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__attr"]
        [::std::mem::offset_of!(pthread_condattr_t, __attr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr_t {
    pub __attr: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__attr"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __attr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr_t {
    pub __attr: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 4usize];
    ["Offset of field: pthread_rwlockattr_t::__attr"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __attr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_attr_t {
    pub __u: pthread_attr_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 9usize],
    pub __vi: [::std::os::raw::c_int; 9usize],
    pub __s: [::std::os::raw::c_ulong; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t__bindgen_ty_1"]
        [::std::mem::size_of::<pthread_attr_t__bindgen_ty_1>() - 36usize];
    ["Alignment of pthread_attr_t__bindgen_ty_1"]
        [::std::mem::align_of::<pthread_attr_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: pthread_attr_t__bindgen_ty_1::__i"]
        [::std::mem::offset_of!(pthread_attr_t__bindgen_ty_1, __i) - 0usize];
    ["Offset of field: pthread_attr_t__bindgen_ty_1::__vi"]
        [::std::mem::offset_of!(pthread_attr_t__bindgen_ty_1, __vi) - 0usize];
    ["Offset of field: pthread_attr_t__bindgen_ty_1::__s"]
        [::std::mem::offset_of!(pthread_attr_t__bindgen_ty_1, __s) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 36usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 4usize];
    ["Offset of field: pthread_attr_t::__u"][::std::mem::offset_of!(pthread_attr_t, __u) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutex_t {
    pub __u: pthread_mutex_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 6usize],
    pub __vi: [::std::os::raw::c_int; 6usize],
    pub __p: [*mut ::std::os::raw::c_void; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t__bindgen_ty_1"]
        [::std::mem::size_of::<pthread_mutex_t__bindgen_ty_1>() - 24usize];
    ["Alignment of pthread_mutex_t__bindgen_ty_1"]
        [::std::mem::align_of::<pthread_mutex_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: pthread_mutex_t__bindgen_ty_1::__i"]
        [::std::mem::offset_of!(pthread_mutex_t__bindgen_ty_1, __i) - 0usize];
    ["Offset of field: pthread_mutex_t__bindgen_ty_1::__vi"]
        [::std::mem::offset_of!(pthread_mutex_t__bindgen_ty_1, __vi) - 0usize];
    ["Offset of field: pthread_mutex_t__bindgen_ty_1::__p"]
        [::std::mem::offset_of!(pthread_mutex_t__bindgen_ty_1, __p) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 24usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 4usize];
    ["Offset of field: pthread_mutex_t::__u"]
        [::std::mem::offset_of!(pthread_mutex_t, __u) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_cond_t {
    pub __u: pthread_cond_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 12usize],
    pub __vi: [::std::os::raw::c_int; 12usize],
    pub __p: [*mut ::std::os::raw::c_void; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t__bindgen_ty_1"]
        [::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() - 48usize];
    ["Alignment of pthread_cond_t__bindgen_ty_1"]
        [::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__i"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __i) - 0usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__vi"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __vi) - 0usize];
    ["Offset of field: pthread_cond_t__bindgen_ty_1::__p"]
        [::std::mem::offset_of!(pthread_cond_t__bindgen_ty_1, __p) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 4usize];
    ["Offset of field: pthread_cond_t::__u"][::std::mem::offset_of!(pthread_cond_t, __u) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_rwlock_t {
    pub __u: pthread_rwlock_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 8usize],
    pub __vi: [::std::os::raw::c_int; 8usize],
    pub __p: [*mut ::std::os::raw::c_void; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t__bindgen_ty_1"]
        [::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() - 32usize];
    ["Alignment of pthread_rwlock_t__bindgen_ty_1"]
        [::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__i"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __i) - 0usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__vi"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __vi) - 0usize];
    ["Offset of field: pthread_rwlock_t__bindgen_ty_1::__p"]
        [::std::mem::offset_of!(pthread_rwlock_t__bindgen_ty_1, __p) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 32usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 4usize];
    ["Offset of field: pthread_rwlock_t::__u"]
        [::std::mem::offset_of!(pthread_rwlock_t, __u) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_barrier_t {
    pub __u: pthread_barrier_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t__bindgen_ty_1 {
    pub __i: [::std::os::raw::c_int; 5usize],
    pub __vi: [::std::os::raw::c_int; 5usize],
    pub __p: [*mut ::std::os::raw::c_void; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t__bindgen_ty_1"]
        [::std::mem::size_of::<pthread_barrier_t__bindgen_ty_1>() - 20usize];
    ["Alignment of pthread_barrier_t__bindgen_ty_1"]
        [::std::mem::align_of::<pthread_barrier_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: pthread_barrier_t__bindgen_ty_1::__i"]
        [::std::mem::offset_of!(pthread_barrier_t__bindgen_ty_1, __i) - 0usize];
    ["Offset of field: pthread_barrier_t__bindgen_ty_1::__vi"]
        [::std::mem::offset_of!(pthread_barrier_t__bindgen_ty_1, __vi) - 0usize];
    ["Offset of field: pthread_barrier_t__bindgen_ty_1::__p"]
        [::std::mem::offset_of!(pthread_barrier_t__bindgen_ty_1, __p) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 20usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 4usize];
    ["Offset of field: pthread_barrier_t::__u"]
        [::std::mem::offset_of!(pthread_barrier_t, __u) - 0usize];
};
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type ushort = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type uint = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type quad_t = ::std::os::raw::c_longlong;
pub type u_quad_t = ::std::os::raw::c_ulonglong;
pub type sigset_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __nfds: usize,
    pub __fds: [::std::os::raw::c_int; 1024usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 4100usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::__nfds"][::std::mem::offset_of!(fd_set, __nfds) - 0usize];
    ["Offset of field: fd_set::__fds"][::std::mem::offset_of!(fd_set, __fds) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 8usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 4usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
#[doc = " A list of offsets of newlines in a string. The offsets are assumed to be\n sorted/inserted in ascending order."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_newline_list_t {
    #[doc = " A pointer to the start of the source string."]
    pub start: *const u8,
    #[doc = " The number of offsets in the list."]
    pub size: usize,
    #[doc = " The capacity of the list that has been allocated."]
    pub capacity: usize,
    #[doc = " The list of offsets."]
    pub offsets: *mut usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_newline_list_t"][::std::mem::size_of::<pm_newline_list_t>() - 16usize];
    ["Alignment of pm_newline_list_t"][::std::mem::align_of::<pm_newline_list_t>() - 4usize];
    ["Offset of field: pm_newline_list_t::start"]
        [::std::mem::offset_of!(pm_newline_list_t, start) - 0usize];
    ["Offset of field: pm_newline_list_t::size"]
        [::std::mem::offset_of!(pm_newline_list_t, size) - 4usize];
    ["Offset of field: pm_newline_list_t::capacity"]
        [::std::mem::offset_of!(pm_newline_list_t, capacity) - 8usize];
    ["Offset of field: pm_newline_list_t::offsets"]
        [::std::mem::offset_of!(pm_newline_list_t, offsets) - 12usize];
};
#[doc = " A line and column in a string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_line_column_t {
    #[doc = " The line number."]
    pub line: i32,
    #[doc = " The column number."]
    pub column: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_line_column_t"][::std::mem::size_of::<pm_line_column_t>() - 8usize];
    ["Alignment of pm_line_column_t"][::std::mem::align_of::<pm_line_column_t>() - 4usize];
    ["Offset of field: pm_line_column_t::line"]
        [::std::mem::offset_of!(pm_line_column_t, line) - 0usize];
    ["Offset of field: pm_line_column_t::column"]
        [::std::mem::offset_of!(pm_line_column_t, column) - 4usize];
};
#[doc = " A pm_buffer_t is a simple memory buffer that stores data in a contiguous\n block of memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_buffer_t {
    #[doc = " The length of the buffer in bytes."]
    pub length: usize,
    #[doc = " The capacity of the buffer in bytes that has been allocated."]
    pub capacity: usize,
    #[doc = " A pointer to the start of the buffer."]
    pub value: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_buffer_t"][::std::mem::size_of::<pm_buffer_t>() - 12usize];
    ["Alignment of pm_buffer_t"][::std::mem::align_of::<pm_buffer_t>() - 4usize];
    ["Offset of field: pm_buffer_t::length"][::std::mem::offset_of!(pm_buffer_t, length) - 0usize];
    ["Offset of field: pm_buffer_t::capacity"]
        [::std::mem::offset_of!(pm_buffer_t, capacity) - 4usize];
    ["Offset of field: pm_buffer_t::value"][::std::mem::offset_of!(pm_buffer_t, value) - 8usize];
};
pub const pm_buffer_escaping_t_PM_BUFFER_ESCAPING_RUBY: pm_buffer_escaping_t = 0;
pub const pm_buffer_escaping_t_PM_BUFFER_ESCAPING_JSON: pm_buffer_escaping_t = 1;
#[doc = " The different types of escaping that can be performed by the buffer when\n appending a slice of Ruby source code."]
pub type pm_buffer_escaping_t = ::std::os::raw::c_uint;
#[doc = " A structure represents an arbitrary-sized integer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_integer_t {
    #[doc = " The number of allocated values. length is set to 0 if the integer fits\n into uint32_t."]
    pub length: usize,
    #[doc = " List of 32-bit integers. Set to NULL if the integer fits into uint32_t."]
    pub values: *mut u32,
    #[doc = " Embedded value for small integer. This value is set to 0 if the value\n does not fit into uint32_t."]
    pub value: u32,
    #[doc = " Whether or not the integer is negative. It is stored this way so that a\n zeroed pm_integer_t is always positive zero."]
    pub negative: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_integer_t"][::std::mem::size_of::<pm_integer_t>() - 16usize];
    ["Alignment of pm_integer_t"][::std::mem::align_of::<pm_integer_t>() - 4usize];
    ["Offset of field: pm_integer_t::length"]
        [::std::mem::offset_of!(pm_integer_t, length) - 0usize];
    ["Offset of field: pm_integer_t::values"]
        [::std::mem::offset_of!(pm_integer_t, values) - 4usize];
    ["Offset of field: pm_integer_t::value"][::std::mem::offset_of!(pm_integer_t, value) - 8usize];
    ["Offset of field: pm_integer_t::negative"]
        [::std::mem::offset_of!(pm_integer_t, negative) - 12usize];
};
#[doc = " The default decimal base, with no prefix. Leading 0s will be ignored."]
pub const pm_integer_base_t_PM_INTEGER_BASE_DEFAULT: pm_integer_base_t = 0;
#[doc = " The binary base, indicated by a 0b or 0B prefix."]
pub const pm_integer_base_t_PM_INTEGER_BASE_BINARY: pm_integer_base_t = 1;
#[doc = " The octal base, indicated by a 0, 0o, or 0O prefix."]
pub const pm_integer_base_t_PM_INTEGER_BASE_OCTAL: pm_integer_base_t = 2;
#[doc = " The decimal base, indicated by a 0d, 0D, or empty prefix."]
pub const pm_integer_base_t_PM_INTEGER_BASE_DECIMAL: pm_integer_base_t = 3;
#[doc = " The hexadecimal base, indicated by a 0x or 0X prefix."]
pub const pm_integer_base_t_PM_INTEGER_BASE_HEXADECIMAL: pm_integer_base_t = 4;
#[doc = " An unknown base, in which case pm_integer_parse will derive it based on\n the content of the string. This is less efficient and does more\n comparisons, so if callers know the base ahead of time, they should use\n that instead."]
pub const pm_integer_base_t_PM_INTEGER_BASE_UNKNOWN: pm_integer_base_t = 5;
#[doc = " An enum controlling the base of an integer. It is expected that the base is\n already known before parsing the integer, even though it could be derived\n from the string itself."]
pub type pm_integer_base_t = ::std::os::raw::c_uint;
#[doc = " This struct defines the functions necessary to implement the encoding\n interface so we can determine how many bytes the subsequent character takes.\n Each callback should return the number of bytes, or 0 if the next bytes are\n invalid for the encoding and type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_encoding_t {
    #[doc = " Return the number of bytes that the next character takes if it is valid\n in the encoding. Does not read more than n bytes. It is assumed that n is\n at least 1."]
    pub char_width: ::std::option::Option<unsafe extern "C" fn(b: *const u8, n: isize) -> usize>,
    #[doc = " Return the number of bytes that the next character takes if it is valid\n in the encoding and is alphabetical. Does not read more than n bytes. It\n is assumed that n is at least 1."]
    pub alpha_char: ::std::option::Option<unsafe extern "C" fn(b: *const u8, n: isize) -> usize>,
    #[doc = " Return the number of bytes that the next character takes if it is valid\n in the encoding and is alphanumeric. Does not read more than n bytes. It\n is assumed that n is at least 1."]
    pub alnum_char: ::std::option::Option<unsafe extern "C" fn(b: *const u8, n: isize) -> usize>,
    #[doc = " Return true if the next character is valid in the encoding and is an\n uppercase character. Does not read more than n bytes. It is assumed that\n n is at least 1."]
    pub isupper_char: ::std::option::Option<unsafe extern "C" fn(b: *const u8, n: isize) -> bool>,
    #[doc = " The name of the encoding. This should correspond to a value that can be\n passed to Encoding.find in Ruby."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Return true if the encoding is a multibyte encoding."]
    pub multibyte: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_encoding_t"][::std::mem::size_of::<pm_encoding_t>() - 24usize];
    ["Alignment of pm_encoding_t"][::std::mem::align_of::<pm_encoding_t>() - 4usize];
    ["Offset of field: pm_encoding_t::char_width"]
        [::std::mem::offset_of!(pm_encoding_t, char_width) - 0usize];
    ["Offset of field: pm_encoding_t::alpha_char"]
        [::std::mem::offset_of!(pm_encoding_t, alpha_char) - 4usize];
    ["Offset of field: pm_encoding_t::alnum_char"]
        [::std::mem::offset_of!(pm_encoding_t, alnum_char) - 8usize];
    ["Offset of field: pm_encoding_t::isupper_char"]
        [::std::mem::offset_of!(pm_encoding_t, isupper_char) - 12usize];
    ["Offset of field: pm_encoding_t::name"][::std::mem::offset_of!(pm_encoding_t, name) - 16usize];
    ["Offset of field: pm_encoding_t::multibyte"]
        [::std::mem::offset_of!(pm_encoding_t, multibyte) - 20usize];
};
unsafe extern "C" {
    #[doc = " This lookup table is referenced in both the UTF-8 encoding file and the\n parser directly in order to speed up the default encoding processing. It is\n used to indicate whether a character is alphabetical, alphanumeric, or\n uppercase in unicode mappings."]
    pub static pm_encoding_unicode_table: [u8; 256usize];
}
pub const pm_encoding_type_t_PM_ENCODING_UTF_8: pm_encoding_type_t = 0;
pub const pm_encoding_type_t_PM_ENCODING_US_ASCII: pm_encoding_type_t = 1;
pub const pm_encoding_type_t_PM_ENCODING_ASCII_8BIT: pm_encoding_type_t = 2;
pub const pm_encoding_type_t_PM_ENCODING_EUC_JP: pm_encoding_type_t = 3;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_31J: pm_encoding_type_t = 4;
pub const pm_encoding_type_t_PM_ENCODING_BIG5: pm_encoding_type_t = 5;
pub const pm_encoding_type_t_PM_ENCODING_BIG5_HKSCS: pm_encoding_type_t = 6;
pub const pm_encoding_type_t_PM_ENCODING_BIG5_UAO: pm_encoding_type_t = 7;
pub const pm_encoding_type_t_PM_ENCODING_CESU_8: pm_encoding_type_t = 8;
pub const pm_encoding_type_t_PM_ENCODING_CP51932: pm_encoding_type_t = 9;
pub const pm_encoding_type_t_PM_ENCODING_CP850: pm_encoding_type_t = 10;
pub const pm_encoding_type_t_PM_ENCODING_CP852: pm_encoding_type_t = 11;
pub const pm_encoding_type_t_PM_ENCODING_CP855: pm_encoding_type_t = 12;
pub const pm_encoding_type_t_PM_ENCODING_CP949: pm_encoding_type_t = 13;
pub const pm_encoding_type_t_PM_ENCODING_CP950: pm_encoding_type_t = 14;
pub const pm_encoding_type_t_PM_ENCODING_CP951: pm_encoding_type_t = 15;
pub const pm_encoding_type_t_PM_ENCODING_EMACS_MULE: pm_encoding_type_t = 16;
pub const pm_encoding_type_t_PM_ENCODING_EUC_JP_MS: pm_encoding_type_t = 17;
pub const pm_encoding_type_t_PM_ENCODING_EUC_JIS_2004: pm_encoding_type_t = 18;
pub const pm_encoding_type_t_PM_ENCODING_EUC_KR: pm_encoding_type_t = 19;
pub const pm_encoding_type_t_PM_ENCODING_EUC_TW: pm_encoding_type_t = 20;
pub const pm_encoding_type_t_PM_ENCODING_GB12345: pm_encoding_type_t = 21;
pub const pm_encoding_type_t_PM_ENCODING_GB18030: pm_encoding_type_t = 22;
pub const pm_encoding_type_t_PM_ENCODING_GB1988: pm_encoding_type_t = 23;
pub const pm_encoding_type_t_PM_ENCODING_GB2312: pm_encoding_type_t = 24;
pub const pm_encoding_type_t_PM_ENCODING_GBK: pm_encoding_type_t = 25;
pub const pm_encoding_type_t_PM_ENCODING_IBM437: pm_encoding_type_t = 26;
pub const pm_encoding_type_t_PM_ENCODING_IBM720: pm_encoding_type_t = 27;
pub const pm_encoding_type_t_PM_ENCODING_IBM737: pm_encoding_type_t = 28;
pub const pm_encoding_type_t_PM_ENCODING_IBM775: pm_encoding_type_t = 29;
pub const pm_encoding_type_t_PM_ENCODING_IBM852: pm_encoding_type_t = 30;
pub const pm_encoding_type_t_PM_ENCODING_IBM855: pm_encoding_type_t = 31;
pub const pm_encoding_type_t_PM_ENCODING_IBM857: pm_encoding_type_t = 32;
pub const pm_encoding_type_t_PM_ENCODING_IBM860: pm_encoding_type_t = 33;
pub const pm_encoding_type_t_PM_ENCODING_IBM861: pm_encoding_type_t = 34;
pub const pm_encoding_type_t_PM_ENCODING_IBM862: pm_encoding_type_t = 35;
pub const pm_encoding_type_t_PM_ENCODING_IBM863: pm_encoding_type_t = 36;
pub const pm_encoding_type_t_PM_ENCODING_IBM864: pm_encoding_type_t = 37;
pub const pm_encoding_type_t_PM_ENCODING_IBM865: pm_encoding_type_t = 38;
pub const pm_encoding_type_t_PM_ENCODING_IBM866: pm_encoding_type_t = 39;
pub const pm_encoding_type_t_PM_ENCODING_IBM869: pm_encoding_type_t = 40;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_1: pm_encoding_type_t = 41;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_2: pm_encoding_type_t = 42;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_3: pm_encoding_type_t = 43;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_4: pm_encoding_type_t = 44;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_5: pm_encoding_type_t = 45;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_6: pm_encoding_type_t = 46;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_7: pm_encoding_type_t = 47;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_8: pm_encoding_type_t = 48;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_9: pm_encoding_type_t = 49;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_10: pm_encoding_type_t = 50;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_11: pm_encoding_type_t = 51;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_13: pm_encoding_type_t = 52;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_14: pm_encoding_type_t = 53;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_15: pm_encoding_type_t = 54;
pub const pm_encoding_type_t_PM_ENCODING_ISO_8859_16: pm_encoding_type_t = 55;
pub const pm_encoding_type_t_PM_ENCODING_KOI8_R: pm_encoding_type_t = 56;
pub const pm_encoding_type_t_PM_ENCODING_KOI8_U: pm_encoding_type_t = 57;
pub const pm_encoding_type_t_PM_ENCODING_MAC_CENT_EURO: pm_encoding_type_t = 58;
pub const pm_encoding_type_t_PM_ENCODING_MAC_CROATIAN: pm_encoding_type_t = 59;
pub const pm_encoding_type_t_PM_ENCODING_MAC_CYRILLIC: pm_encoding_type_t = 60;
pub const pm_encoding_type_t_PM_ENCODING_MAC_GREEK: pm_encoding_type_t = 61;
pub const pm_encoding_type_t_PM_ENCODING_MAC_ICELAND: pm_encoding_type_t = 62;
pub const pm_encoding_type_t_PM_ENCODING_MAC_JAPANESE: pm_encoding_type_t = 63;
pub const pm_encoding_type_t_PM_ENCODING_MAC_ROMAN: pm_encoding_type_t = 64;
pub const pm_encoding_type_t_PM_ENCODING_MAC_ROMANIA: pm_encoding_type_t = 65;
pub const pm_encoding_type_t_PM_ENCODING_MAC_THAI: pm_encoding_type_t = 66;
pub const pm_encoding_type_t_PM_ENCODING_MAC_TURKISH: pm_encoding_type_t = 67;
pub const pm_encoding_type_t_PM_ENCODING_MAC_UKRAINE: pm_encoding_type_t = 68;
pub const pm_encoding_type_t_PM_ENCODING_SHIFT_JIS: pm_encoding_type_t = 69;
pub const pm_encoding_type_t_PM_ENCODING_SJIS_DOCOMO: pm_encoding_type_t = 70;
pub const pm_encoding_type_t_PM_ENCODING_SJIS_KDDI: pm_encoding_type_t = 71;
pub const pm_encoding_type_t_PM_ENCODING_SJIS_SOFTBANK: pm_encoding_type_t = 72;
pub const pm_encoding_type_t_PM_ENCODING_STATELESS_ISO_2022_JP: pm_encoding_type_t = 73;
pub const pm_encoding_type_t_PM_ENCODING_STATELESS_ISO_2022_JP_KDDI: pm_encoding_type_t = 74;
pub const pm_encoding_type_t_PM_ENCODING_TIS_620: pm_encoding_type_t = 75;
pub const pm_encoding_type_t_PM_ENCODING_UTF8_MAC: pm_encoding_type_t = 76;
pub const pm_encoding_type_t_PM_ENCODING_UTF8_DOCOMO: pm_encoding_type_t = 77;
pub const pm_encoding_type_t_PM_ENCODING_UTF8_KDDI: pm_encoding_type_t = 78;
pub const pm_encoding_type_t_PM_ENCODING_UTF8_SOFTBANK: pm_encoding_type_t = 79;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1250: pm_encoding_type_t = 80;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1251: pm_encoding_type_t = 81;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1252: pm_encoding_type_t = 82;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1253: pm_encoding_type_t = 83;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1254: pm_encoding_type_t = 84;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1255: pm_encoding_type_t = 85;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1256: pm_encoding_type_t = 86;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1257: pm_encoding_type_t = 87;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_1258: pm_encoding_type_t = 88;
pub const pm_encoding_type_t_PM_ENCODING_WINDOWS_874: pm_encoding_type_t = 89;
pub const pm_encoding_type_t_PM_ENCODING_MAXIMUM: pm_encoding_type_t = 90;
#[doc = " These are all of the encodings that prism supports."]
pub type pm_encoding_type_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " This is the table of all of the encodings that prism supports."]
    pub static pm_encodings: [pm_encoding_t; 90usize];
}
#[doc = " A constant id is a unique identifier for a constant in the constant pool."]
pub type pm_constant_id_t = u32;
#[doc = " A list of constant IDs. Usually used to represent a set of locals."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_id_list_t {
    #[doc = " The number of constant ids in the list."]
    pub size: usize,
    #[doc = " The number of constant ids that have been allocated in the list."]
    pub capacity: usize,
    #[doc = " The constant ids in the list."]
    pub ids: *mut pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_id_list_t"][::std::mem::size_of::<pm_constant_id_list_t>() - 12usize];
    ["Alignment of pm_constant_id_list_t"]
        [::std::mem::align_of::<pm_constant_id_list_t>() - 4usize];
    ["Offset of field: pm_constant_id_list_t::size"]
        [::std::mem::offset_of!(pm_constant_id_list_t, size) - 0usize];
    ["Offset of field: pm_constant_id_list_t::capacity"]
        [::std::mem::offset_of!(pm_constant_id_list_t, capacity) - 4usize];
    ["Offset of field: pm_constant_id_list_t::ids"]
        [::std::mem::offset_of!(pm_constant_id_list_t, ids) - 8usize];
};
#[doc = " The type of bucket in the constant pool hash map. This determines how the\n bucket should be freed."]
pub type pm_constant_pool_bucket_type_t = ::std::os::raw::c_uint;
#[doc = " By default, each constant is a slice of the source."]
pub const PM_CONSTANT_POOL_BUCKET_DEFAULT: pm_constant_pool_bucket_type_t = 0;
#[doc = " An owned constant is one for which memory has been allocated."]
pub const PM_CONSTANT_POOL_BUCKET_OWNED: pm_constant_pool_bucket_type_t = 1;
#[doc = " A constant constant is known at compile time."]
pub const PM_CONSTANT_POOL_BUCKET_CONSTANT: pm_constant_pool_bucket_type_t = 2;
#[doc = " A bucket in the hash map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_pool_bucket_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " The hash of the bucket."]
    pub hash: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_pool_bucket_t"]
        [::std::mem::size_of::<pm_constant_pool_bucket_t>() - 8usize];
    ["Alignment of pm_constant_pool_bucket_t"]
        [::std::mem::align_of::<pm_constant_pool_bucket_t>() - 4usize];
    ["Offset of field: pm_constant_pool_bucket_t::hash"]
        [::std::mem::offset_of!(pm_constant_pool_bucket_t, hash) - 4usize];
};
impl pm_constant_pool_bucket_t {
    #[inline]
    pub fn id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn id_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_id_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> pm_constant_pool_bucket_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: pm_constant_pool_bucket_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> pm_constant_pool_bucket_type_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: pm_constant_pool_bucket_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        id: ::std::os::raw::c_uint,
        type_: pm_constant_pool_bucket_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A constant in the pool which effectively stores a string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_t {
    #[doc = " A pointer to the start of the string."]
    pub start: *const u8,
    #[doc = " The length of the string."]
    pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_t"][::std::mem::size_of::<pm_constant_t>() - 8usize];
    ["Alignment of pm_constant_t"][::std::mem::align_of::<pm_constant_t>() - 4usize];
    ["Offset of field: pm_constant_t::start"]
        [::std::mem::offset_of!(pm_constant_t, start) - 0usize];
    ["Offset of field: pm_constant_t::length"]
        [::std::mem::offset_of!(pm_constant_t, length) - 4usize];
};
#[doc = " The overall constant pool, which stores constants found while parsing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_pool_t {
    #[doc = " The buckets in the hash map."]
    pub buckets: *mut pm_constant_pool_bucket_t,
    #[doc = " The constants that are stored in the buckets."]
    pub constants: *mut pm_constant_t,
    #[doc = " The number of buckets in the hash map."]
    pub size: u32,
    #[doc = " The number of buckets that have been allocated in the hash map."]
    pub capacity: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_pool_t"][::std::mem::size_of::<pm_constant_pool_t>() - 16usize];
    ["Alignment of pm_constant_pool_t"][::std::mem::align_of::<pm_constant_pool_t>() - 4usize];
    ["Offset of field: pm_constant_pool_t::buckets"]
        [::std::mem::offset_of!(pm_constant_pool_t, buckets) - 0usize];
    ["Offset of field: pm_constant_pool_t::constants"]
        [::std::mem::offset_of!(pm_constant_pool_t, constants) - 4usize];
    ["Offset of field: pm_constant_pool_t::size"]
        [::std::mem::offset_of!(pm_constant_pool_t, size) - 8usize];
    ["Offset of field: pm_constant_pool_t::capacity"]
        [::std::mem::offset_of!(pm_constant_pool_t, capacity) - 12usize];
};
unsafe extern "C" {
    pub static mut errno: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flock"][::std::mem::size_of::<flock>() - 32usize];
    ["Alignment of flock"][::std::mem::align_of::<flock>() - 8usize];
    ["Offset of field: flock::l_type"][::std::mem::offset_of!(flock, l_type) - 0usize];
    ["Offset of field: flock::l_whence"][::std::mem::offset_of!(flock, l_whence) - 2usize];
    ["Offset of field: flock::l_start"][::std::mem::offset_of!(flock, l_start) - 8usize];
    ["Offset of field: flock::l_len"][::std::mem::offset_of!(flock, l_len) - 16usize];
    ["Offset of field: flock::l_pid"][::std::mem::offset_of!(flock, l_pid) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_ino: ino_t,
    pub st_nlink: nlink_t,
    pub st_mode: mode_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub __pad0: ::std::os::raw::c_uint,
    pub st_rdev: dev_t,
    pub st_size: off_t,
    pub st_blksize: blksize_t,
    pub st_blocks: blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __reserved: [::std::os::raw::c_longlong; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stat"][::std::mem::size_of::<stat>() - 144usize];
    ["Alignment of stat"][::std::mem::align_of::<stat>() - 8usize];
    ["Offset of field: stat::st_dev"][::std::mem::offset_of!(stat, st_dev) - 0usize];
    ["Offset of field: stat::st_ino"][::std::mem::offset_of!(stat, st_ino) - 8usize];
    ["Offset of field: stat::st_nlink"][::std::mem::offset_of!(stat, st_nlink) - 16usize];
    ["Offset of field: stat::st_mode"][::std::mem::offset_of!(stat, st_mode) - 24usize];
    ["Offset of field: stat::st_uid"][::std::mem::offset_of!(stat, st_uid) - 28usize];
    ["Offset of field: stat::st_gid"][::std::mem::offset_of!(stat, st_gid) - 32usize];
    ["Offset of field: stat::__pad0"][::std::mem::offset_of!(stat, __pad0) - 36usize];
    ["Offset of field: stat::st_rdev"][::std::mem::offset_of!(stat, st_rdev) - 40usize];
    ["Offset of field: stat::st_size"][::std::mem::offset_of!(stat, st_size) - 48usize];
    ["Offset of field: stat::st_blksize"][::std::mem::offset_of!(stat, st_blksize) - 56usize];
    ["Offset of field: stat::st_blocks"][::std::mem::offset_of!(stat, st_blocks) - 64usize];
    ["Offset of field: stat::st_atim"][::std::mem::offset_of!(stat, st_atim) - 72usize];
    ["Offset of field: stat::st_mtim"][::std::mem::offset_of!(stat, st_mtim) - 88usize];
    ["Offset of field: stat::st_ctim"][::std::mem::offset_of!(stat, st_ctim) - 104usize];
    ["Offset of field: stat::__reserved"][::std::mem::offset_of!(stat, __reserved) - 120usize];
};
#[doc = " A generic string type that can have various ownership semantics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_string_t {
    #[doc = " A pointer to the start of the string."]
    pub source: *const u8,
    #[doc = " The length of the string in bytes of memory."]
    pub length: usize,
    pub type_: pm_string_t__bindgen_ty_1,
}
#[doc = " This string is a constant string, and should not be freed."]
pub const pm_string_t_PM_STRING_CONSTANT: pm_string_t__bindgen_ty_1 = 0;
#[doc = " This is a slice of another string, and should not be freed."]
pub const pm_string_t_PM_STRING_SHARED: pm_string_t__bindgen_ty_1 = 1;
#[doc = " This string owns its memory, and should be freed using `pm_string_free`."]
pub const pm_string_t_PM_STRING_OWNED: pm_string_t__bindgen_ty_1 = 2;
#[doc = " The type of the string. This field determines how the string should be freed."]
pub type pm_string_t__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_string_t"][::std::mem::size_of::<pm_string_t>() - 12usize];
    ["Alignment of pm_string_t"][::std::mem::align_of::<pm_string_t>() - 4usize];
    ["Offset of field: pm_string_t::source"][::std::mem::offset_of!(pm_string_t, source) - 0usize];
    ["Offset of field: pm_string_t::length"][::std::mem::offset_of!(pm_string_t, length) - 4usize];
    ["Offset of field: pm_string_t::type_"][::std::mem::offset_of!(pm_string_t, type_) - 8usize];
};
#[doc = " Indicates that the string was successfully initialized."]
pub const pm_string_init_result_t_PM_STRING_INIT_SUCCESS: pm_string_init_result_t = 0;
#[doc = " Indicates a generic error from a string_*_init function, where the type\n of error should be read from `errno` or `GetLastError()`."]
pub const pm_string_init_result_t_PM_STRING_INIT_ERROR_GENERIC: pm_string_init_result_t = 1;
#[doc = " Indicates that the file that was attempted to be opened was a directory."]
pub const pm_string_init_result_t_PM_STRING_INIT_ERROR_DIRECTORY: pm_string_init_result_t = 2;
#[doc = " Represents the result of calling pm_string_mapped_init or\n pm_string_file_init. We need this additional information because there is\n not a platform-agnostic way to indicate that the file that was attempted to\n be opened was a directory."]
pub type pm_string_init_result_t = ::std::os::raw::c_uint;
#[doc = " final token in the file"]
pub const pm_token_type_PM_TOKEN_EOF: pm_token_type = 1;
#[doc = " a token that was expected but not found"]
pub const pm_token_type_PM_TOKEN_MISSING: pm_token_type = 2;
#[doc = " a token that was not present but it is okay"]
pub const pm_token_type_PM_TOKEN_NOT_PROVIDED: pm_token_type = 3;
#[doc = " &"]
pub const pm_token_type_PM_TOKEN_AMPERSAND: pm_token_type = 4;
#[doc = " &&"]
pub const pm_token_type_PM_TOKEN_AMPERSAND_AMPERSAND: pm_token_type = 5;
#[doc = " &&="]
pub const pm_token_type_PM_TOKEN_AMPERSAND_AMPERSAND_EQUAL: pm_token_type = 6;
#[doc = " &."]
pub const pm_token_type_PM_TOKEN_AMPERSAND_DOT: pm_token_type = 7;
#[doc = " &="]
pub const pm_token_type_PM_TOKEN_AMPERSAND_EQUAL: pm_token_type = 8;
#[doc = " `"]
pub const pm_token_type_PM_TOKEN_BACKTICK: pm_token_type = 9;
#[doc = " a back reference"]
pub const pm_token_type_PM_TOKEN_BACK_REFERENCE: pm_token_type = 10;
#[doc = " ! or !@"]
pub const pm_token_type_PM_TOKEN_BANG: pm_token_type = 11;
#[doc = " !="]
pub const pm_token_type_PM_TOKEN_BANG_EQUAL: pm_token_type = 12;
#[doc = " !~"]
pub const pm_token_type_PM_TOKEN_BANG_TILDE: pm_token_type = 13;
#[doc = " {"]
pub const pm_token_type_PM_TOKEN_BRACE_LEFT: pm_token_type = 14;
#[doc = " }"]
pub const pm_token_type_PM_TOKEN_BRACE_RIGHT: pm_token_type = 15;
#[doc = " ["]
pub const pm_token_type_PM_TOKEN_BRACKET_LEFT: pm_token_type = 16;
#[doc = " [ for the beginning of an array"]
pub const pm_token_type_PM_TOKEN_BRACKET_LEFT_ARRAY: pm_token_type = 17;
#[doc = " []"]
pub const pm_token_type_PM_TOKEN_BRACKET_LEFT_RIGHT: pm_token_type = 18;
#[doc = " []="]
pub const pm_token_type_PM_TOKEN_BRACKET_LEFT_RIGHT_EQUAL: pm_token_type = 19;
#[doc = " ]"]
pub const pm_token_type_PM_TOKEN_BRACKET_RIGHT: pm_token_type = 20;
#[doc = " ^"]
pub const pm_token_type_PM_TOKEN_CARET: pm_token_type = 21;
#[doc = " ^="]
pub const pm_token_type_PM_TOKEN_CARET_EQUAL: pm_token_type = 22;
#[doc = " a character literal"]
pub const pm_token_type_PM_TOKEN_CHARACTER_LITERAL: pm_token_type = 23;
#[doc = " a class variable"]
pub const pm_token_type_PM_TOKEN_CLASS_VARIABLE: pm_token_type = 24;
#[doc = " :"]
pub const pm_token_type_PM_TOKEN_COLON: pm_token_type = 25;
#[doc = " ::"]
pub const pm_token_type_PM_TOKEN_COLON_COLON: pm_token_type = 26;
#[doc = " ,"]
pub const pm_token_type_PM_TOKEN_COMMA: pm_token_type = 27;
#[doc = " a comment"]
pub const pm_token_type_PM_TOKEN_COMMENT: pm_token_type = 28;
#[doc = " a constant"]
pub const pm_token_type_PM_TOKEN_CONSTANT: pm_token_type = 29;
#[doc = " the . call operator"]
pub const pm_token_type_PM_TOKEN_DOT: pm_token_type = 30;
#[doc = " the .. range operator"]
pub const pm_token_type_PM_TOKEN_DOT_DOT: pm_token_type = 31;
#[doc = " the ... range operator or forwarding parameter"]
pub const pm_token_type_PM_TOKEN_DOT_DOT_DOT: pm_token_type = 32;
#[doc = " =begin"]
pub const pm_token_type_PM_TOKEN_EMBDOC_BEGIN: pm_token_type = 33;
#[doc = " =end"]
pub const pm_token_type_PM_TOKEN_EMBDOC_END: pm_token_type = 34;
#[doc = " a line inside of embedded documentation"]
pub const pm_token_type_PM_TOKEN_EMBDOC_LINE: pm_token_type = 35;
#[doc = " #{"]
pub const pm_token_type_PM_TOKEN_EMBEXPR_BEGIN: pm_token_type = 36;
#[doc = " }"]
pub const pm_token_type_PM_TOKEN_EMBEXPR_END: pm_token_type = 37;
#[doc = " #"]
pub const pm_token_type_PM_TOKEN_EMBVAR: pm_token_type = 38;
#[doc = " ="]
pub const pm_token_type_PM_TOKEN_EQUAL: pm_token_type = 39;
#[doc = " =="]
pub const pm_token_type_PM_TOKEN_EQUAL_EQUAL: pm_token_type = 40;
#[doc = " ==="]
pub const pm_token_type_PM_TOKEN_EQUAL_EQUAL_EQUAL: pm_token_type = 41;
#[doc = " =>"]
pub const pm_token_type_PM_TOKEN_EQUAL_GREATER: pm_token_type = 42;
#[doc = " =~"]
pub const pm_token_type_PM_TOKEN_EQUAL_TILDE: pm_token_type = 43;
#[doc = " a floating point number"]
pub const pm_token_type_PM_TOKEN_FLOAT: pm_token_type = 44;
#[doc = " a floating pointer number with an imaginary suffix"]
pub const pm_token_type_PM_TOKEN_FLOAT_IMAGINARY: pm_token_type = 45;
#[doc = " a floating pointer number with a rational suffix"]
pub const pm_token_type_PM_TOKEN_FLOAT_RATIONAL: pm_token_type = 46;
#[doc = " a floating pointer number with a rational and imaginary suffix"]
pub const pm_token_type_PM_TOKEN_FLOAT_RATIONAL_IMAGINARY: pm_token_type = 47;
#[doc = " a global variable"]
pub const pm_token_type_PM_TOKEN_GLOBAL_VARIABLE: pm_token_type = 48;
#[doc = " >"]
pub const pm_token_type_PM_TOKEN_GREATER: pm_token_type = 49;
#[doc = " >="]
pub const pm_token_type_PM_TOKEN_GREATER_EQUAL: pm_token_type = 50;
#[doc = " >>"]
pub const pm_token_type_PM_TOKEN_GREATER_GREATER: pm_token_type = 51;
#[doc = " >>="]
pub const pm_token_type_PM_TOKEN_GREATER_GREATER_EQUAL: pm_token_type = 52;
#[doc = " the end of a heredoc"]
pub const pm_token_type_PM_TOKEN_HEREDOC_END: pm_token_type = 53;
#[doc = " the start of a heredoc"]
pub const pm_token_type_PM_TOKEN_HEREDOC_START: pm_token_type = 54;
#[doc = " an identifier"]
pub const pm_token_type_PM_TOKEN_IDENTIFIER: pm_token_type = 55;
#[doc = " an ignored newline"]
pub const pm_token_type_PM_TOKEN_IGNORED_NEWLINE: pm_token_type = 56;
#[doc = " an instance variable"]
pub const pm_token_type_PM_TOKEN_INSTANCE_VARIABLE: pm_token_type = 57;
#[doc = " an integer (any base)"]
pub const pm_token_type_PM_TOKEN_INTEGER: pm_token_type = 58;
#[doc = " an integer with an imaginary suffix"]
pub const pm_token_type_PM_TOKEN_INTEGER_IMAGINARY: pm_token_type = 59;
#[doc = " an integer with a rational suffix"]
pub const pm_token_type_PM_TOKEN_INTEGER_RATIONAL: pm_token_type = 60;
#[doc = " an integer with a rational and imaginary suffix"]
pub const pm_token_type_PM_TOKEN_INTEGER_RATIONAL_IMAGINARY: pm_token_type = 61;
#[doc = " alias"]
pub const pm_token_type_PM_TOKEN_KEYWORD_ALIAS: pm_token_type = 62;
#[doc = " and"]
pub const pm_token_type_PM_TOKEN_KEYWORD_AND: pm_token_type = 63;
#[doc = " begin"]
pub const pm_token_type_PM_TOKEN_KEYWORD_BEGIN: pm_token_type = 64;
#[doc = " BEGIN"]
pub const pm_token_type_PM_TOKEN_KEYWORD_BEGIN_UPCASE: pm_token_type = 65;
#[doc = " break"]
pub const pm_token_type_PM_TOKEN_KEYWORD_BREAK: pm_token_type = 66;
#[doc = " case"]
pub const pm_token_type_PM_TOKEN_KEYWORD_CASE: pm_token_type = 67;
#[doc = " class"]
pub const pm_token_type_PM_TOKEN_KEYWORD_CLASS: pm_token_type = 68;
#[doc = " def"]
pub const pm_token_type_PM_TOKEN_KEYWORD_DEF: pm_token_type = 69;
#[doc = " defined?"]
pub const pm_token_type_PM_TOKEN_KEYWORD_DEFINED: pm_token_type = 70;
#[doc = " do"]
pub const pm_token_type_PM_TOKEN_KEYWORD_DO: pm_token_type = 71;
#[doc = " do keyword for a predicate in a while, until, or for loop"]
pub const pm_token_type_PM_TOKEN_KEYWORD_DO_LOOP: pm_token_type = 72;
#[doc = " else"]
pub const pm_token_type_PM_TOKEN_KEYWORD_ELSE: pm_token_type = 73;
#[doc = " elsif"]
pub const pm_token_type_PM_TOKEN_KEYWORD_ELSIF: pm_token_type = 74;
#[doc = " end"]
pub const pm_token_type_PM_TOKEN_KEYWORD_END: pm_token_type = 75;
#[doc = " END"]
pub const pm_token_type_PM_TOKEN_KEYWORD_END_UPCASE: pm_token_type = 76;
#[doc = " ensure"]
pub const pm_token_type_PM_TOKEN_KEYWORD_ENSURE: pm_token_type = 77;
#[doc = " false"]
pub const pm_token_type_PM_TOKEN_KEYWORD_FALSE: pm_token_type = 78;
#[doc = " for"]
pub const pm_token_type_PM_TOKEN_KEYWORD_FOR: pm_token_type = 79;
#[doc = " if"]
pub const pm_token_type_PM_TOKEN_KEYWORD_IF: pm_token_type = 80;
#[doc = " if in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_IF_MODIFIER: pm_token_type = 81;
#[doc = " in"]
pub const pm_token_type_PM_TOKEN_KEYWORD_IN: pm_token_type = 82;
#[doc = " module"]
pub const pm_token_type_PM_TOKEN_KEYWORD_MODULE: pm_token_type = 83;
#[doc = " next"]
pub const pm_token_type_PM_TOKEN_KEYWORD_NEXT: pm_token_type = 84;
#[doc = " nil"]
pub const pm_token_type_PM_TOKEN_KEYWORD_NIL: pm_token_type = 85;
#[doc = " not"]
pub const pm_token_type_PM_TOKEN_KEYWORD_NOT: pm_token_type = 86;
#[doc = " or"]
pub const pm_token_type_PM_TOKEN_KEYWORD_OR: pm_token_type = 87;
#[doc = " redo"]
pub const pm_token_type_PM_TOKEN_KEYWORD_REDO: pm_token_type = 88;
#[doc = " rescue"]
pub const pm_token_type_PM_TOKEN_KEYWORD_RESCUE: pm_token_type = 89;
#[doc = " rescue in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_RESCUE_MODIFIER: pm_token_type = 90;
#[doc = " retry"]
pub const pm_token_type_PM_TOKEN_KEYWORD_RETRY: pm_token_type = 91;
#[doc = " return"]
pub const pm_token_type_PM_TOKEN_KEYWORD_RETURN: pm_token_type = 92;
#[doc = " self"]
pub const pm_token_type_PM_TOKEN_KEYWORD_SELF: pm_token_type = 93;
#[doc = " super"]
pub const pm_token_type_PM_TOKEN_KEYWORD_SUPER: pm_token_type = 94;
#[doc = " then"]
pub const pm_token_type_PM_TOKEN_KEYWORD_THEN: pm_token_type = 95;
#[doc = " true"]
pub const pm_token_type_PM_TOKEN_KEYWORD_TRUE: pm_token_type = 96;
#[doc = " undef"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNDEF: pm_token_type = 97;
#[doc = " unless"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNLESS: pm_token_type = 98;
#[doc = " unless in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNLESS_MODIFIER: pm_token_type = 99;
#[doc = " until"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNTIL: pm_token_type = 100;
#[doc = " until in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_UNTIL_MODIFIER: pm_token_type = 101;
#[doc = " when"]
pub const pm_token_type_PM_TOKEN_KEYWORD_WHEN: pm_token_type = 102;
#[doc = " while"]
pub const pm_token_type_PM_TOKEN_KEYWORD_WHILE: pm_token_type = 103;
#[doc = " while in the modifier form"]
pub const pm_token_type_PM_TOKEN_KEYWORD_WHILE_MODIFIER: pm_token_type = 104;
#[doc = " yield"]
pub const pm_token_type_PM_TOKEN_KEYWORD_YIELD: pm_token_type = 105;
#[doc = " __ENCODING__"]
pub const pm_token_type_PM_TOKEN_KEYWORD___ENCODING__: pm_token_type = 106;
#[doc = " __FILE__"]
pub const pm_token_type_PM_TOKEN_KEYWORD___FILE__: pm_token_type = 107;
#[doc = " __LINE__"]
pub const pm_token_type_PM_TOKEN_KEYWORD___LINE__: pm_token_type = 108;
#[doc = " a label"]
pub const pm_token_type_PM_TOKEN_LABEL: pm_token_type = 109;
#[doc = " the end of a label"]
pub const pm_token_type_PM_TOKEN_LABEL_END: pm_token_type = 110;
#[doc = " {"]
pub const pm_token_type_PM_TOKEN_LAMBDA_BEGIN: pm_token_type = 111;
#[doc = " <"]
pub const pm_token_type_PM_TOKEN_LESS: pm_token_type = 112;
#[doc = " <="]
pub const pm_token_type_PM_TOKEN_LESS_EQUAL: pm_token_type = 113;
#[doc = " <=>"]
pub const pm_token_type_PM_TOKEN_LESS_EQUAL_GREATER: pm_token_type = 114;
#[doc = " <<"]
pub const pm_token_type_PM_TOKEN_LESS_LESS: pm_token_type = 115;
#[doc = " <<="]
pub const pm_token_type_PM_TOKEN_LESS_LESS_EQUAL: pm_token_type = 116;
#[doc = " a method name"]
pub const pm_token_type_PM_TOKEN_METHOD_NAME: pm_token_type = 117;
#[doc = " -"]
pub const pm_token_type_PM_TOKEN_MINUS: pm_token_type = 118;
#[doc = " -="]
pub const pm_token_type_PM_TOKEN_MINUS_EQUAL: pm_token_type = 119;
#[doc = " ->"]
pub const pm_token_type_PM_TOKEN_MINUS_GREATER: pm_token_type = 120;
#[doc = " a newline character outside of other tokens"]
pub const pm_token_type_PM_TOKEN_NEWLINE: pm_token_type = 121;
#[doc = " a numbered reference to a capture group in the previous regular expression match"]
pub const pm_token_type_PM_TOKEN_NUMBERED_REFERENCE: pm_token_type = 122;
#[doc = " ("]
pub const pm_token_type_PM_TOKEN_PARENTHESIS_LEFT: pm_token_type = 123;
#[doc = " ( for a parentheses node"]
pub const pm_token_type_PM_TOKEN_PARENTHESIS_LEFT_PARENTHESES: pm_token_type = 124;
#[doc = " )"]
pub const pm_token_type_PM_TOKEN_PARENTHESIS_RIGHT: pm_token_type = 125;
#[doc = " %"]
pub const pm_token_type_PM_TOKEN_PERCENT: pm_token_type = 126;
#[doc = " %="]
pub const pm_token_type_PM_TOKEN_PERCENT_EQUAL: pm_token_type = 127;
#[doc = " %i"]
pub const pm_token_type_PM_TOKEN_PERCENT_LOWER_I: pm_token_type = 128;
#[doc = " %w"]
pub const pm_token_type_PM_TOKEN_PERCENT_LOWER_W: pm_token_type = 129;
#[doc = " %x"]
pub const pm_token_type_PM_TOKEN_PERCENT_LOWER_X: pm_token_type = 130;
#[doc = " %I"]
pub const pm_token_type_PM_TOKEN_PERCENT_UPPER_I: pm_token_type = 131;
#[doc = " %W"]
pub const pm_token_type_PM_TOKEN_PERCENT_UPPER_W: pm_token_type = 132;
#[doc = " |"]
pub const pm_token_type_PM_TOKEN_PIPE: pm_token_type = 133;
#[doc = " |="]
pub const pm_token_type_PM_TOKEN_PIPE_EQUAL: pm_token_type = 134;
#[doc = " ||"]
pub const pm_token_type_PM_TOKEN_PIPE_PIPE: pm_token_type = 135;
#[doc = " ||="]
pub const pm_token_type_PM_TOKEN_PIPE_PIPE_EQUAL: pm_token_type = 136;
#[doc = " +"]
pub const pm_token_type_PM_TOKEN_PLUS: pm_token_type = 137;
#[doc = " +="]
pub const pm_token_type_PM_TOKEN_PLUS_EQUAL: pm_token_type = 138;
#[doc = " ?"]
pub const pm_token_type_PM_TOKEN_QUESTION_MARK: pm_token_type = 139;
#[doc = " the beginning of a regular expression"]
pub const pm_token_type_PM_TOKEN_REGEXP_BEGIN: pm_token_type = 140;
#[doc = " the end of a regular expression"]
pub const pm_token_type_PM_TOKEN_REGEXP_END: pm_token_type = 141;
#[doc = " ;"]
pub const pm_token_type_PM_TOKEN_SEMICOLON: pm_token_type = 142;
#[doc = " /"]
pub const pm_token_type_PM_TOKEN_SLASH: pm_token_type = 143;
#[doc = " /="]
pub const pm_token_type_PM_TOKEN_SLASH_EQUAL: pm_token_type = 144;
#[doc = " *"]
pub const pm_token_type_PM_TOKEN_STAR: pm_token_type = 145;
#[doc = " *="]
pub const pm_token_type_PM_TOKEN_STAR_EQUAL: pm_token_type = 146;
#[doc = " **"]
pub const pm_token_type_PM_TOKEN_STAR_STAR: pm_token_type = 147;
#[doc = " **="]
pub const pm_token_type_PM_TOKEN_STAR_STAR_EQUAL: pm_token_type = 148;
#[doc = " the beginning of a string"]
pub const pm_token_type_PM_TOKEN_STRING_BEGIN: pm_token_type = 149;
#[doc = " the contents of a string"]
pub const pm_token_type_PM_TOKEN_STRING_CONTENT: pm_token_type = 150;
#[doc = " the end of a string"]
pub const pm_token_type_PM_TOKEN_STRING_END: pm_token_type = 151;
#[doc = " the beginning of a symbol"]
pub const pm_token_type_PM_TOKEN_SYMBOL_BEGIN: pm_token_type = 152;
#[doc = " ~ or ~@"]
pub const pm_token_type_PM_TOKEN_TILDE: pm_token_type = 153;
#[doc = " unary &"]
pub const pm_token_type_PM_TOKEN_UAMPERSAND: pm_token_type = 154;
#[doc = " unary ::"]
pub const pm_token_type_PM_TOKEN_UCOLON_COLON: pm_token_type = 155;
#[doc = " unary .. operator"]
pub const pm_token_type_PM_TOKEN_UDOT_DOT: pm_token_type = 156;
#[doc = " unary ... operator"]
pub const pm_token_type_PM_TOKEN_UDOT_DOT_DOT: pm_token_type = 157;
#[doc = " -@"]
pub const pm_token_type_PM_TOKEN_UMINUS: pm_token_type = 158;
#[doc = " -@ for a number"]
pub const pm_token_type_PM_TOKEN_UMINUS_NUM: pm_token_type = 159;
#[doc = " +@"]
pub const pm_token_type_PM_TOKEN_UPLUS: pm_token_type = 160;
#[doc = " unary *"]
pub const pm_token_type_PM_TOKEN_USTAR: pm_token_type = 161;
#[doc = " unary **"]
pub const pm_token_type_PM_TOKEN_USTAR_STAR: pm_token_type = 162;
#[doc = " a separator between words in a list"]
pub const pm_token_type_PM_TOKEN_WORDS_SEP: pm_token_type = 163;
#[doc = " marker for the point in the file at which the parser should stop"]
pub const pm_token_type_PM_TOKEN___END__: pm_token_type = 164;
#[doc = " The maximum token value."]
pub const pm_token_type_PM_TOKEN_MAXIMUM: pm_token_type = 165;
#[doc = " This enum represents every type of token in the Ruby source."]
pub type pm_token_type = ::std::os::raw::c_uint;
#[doc = " This enum represents every type of token in the Ruby source."]
pub use self::pm_token_type as pm_token_type_t;
#[doc = " This struct represents a token in the Ruby source. We use it to track both\n type and location information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_token_t {
    #[doc = " The type of the token."]
    pub type_: pm_token_type_t,
    #[doc = " A pointer to the start location of the token in the source."]
    pub start: *const u8,
    #[doc = " A pointer to the end location of the token in the source."]
    pub end: *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_token_t"][::std::mem::size_of::<pm_token_t>() - 12usize];
    ["Alignment of pm_token_t"][::std::mem::align_of::<pm_token_t>() - 4usize];
    ["Offset of field: pm_token_t::type_"][::std::mem::offset_of!(pm_token_t, type_) - 0usize];
    ["Offset of field: pm_token_t::start"][::std::mem::offset_of!(pm_token_t, start) - 4usize];
    ["Offset of field: pm_token_t::end"][::std::mem::offset_of!(pm_token_t, end) - 8usize];
};
#[doc = " This represents a range of bytes in the source string to which a node or\n token corresponds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_location_t {
    #[doc = " A pointer to the start location of the range in the source."]
    pub start: *const u8,
    #[doc = " A pointer to the end location of the range in the source."]
    pub end: *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_location_t"][::std::mem::size_of::<pm_location_t>() - 8usize];
    ["Alignment of pm_location_t"][::std::mem::align_of::<pm_location_t>() - 4usize];
    ["Offset of field: pm_location_t::start"]
        [::std::mem::offset_of!(pm_location_t, start) - 0usize];
    ["Offset of field: pm_location_t::end"][::std::mem::offset_of!(pm_location_t, end) - 4usize];
};
#[doc = " A list of nodes in the source, most often used for lists of children."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_node_list {
    #[doc = " The number of nodes in the list."]
    pub size: usize,
    #[doc = " The capacity of the list that has been allocated."]
    pub capacity: usize,
    #[doc = " The nodes in the list."]
    pub nodes: *mut *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_node_list"][::std::mem::size_of::<pm_node_list>() - 12usize];
    ["Alignment of pm_node_list"][::std::mem::align_of::<pm_node_list>() - 4usize];
    ["Offset of field: pm_node_list::size"][::std::mem::offset_of!(pm_node_list, size) - 0usize];
    ["Offset of field: pm_node_list::capacity"]
        [::std::mem::offset_of!(pm_node_list, capacity) - 4usize];
    ["Offset of field: pm_node_list::nodes"][::std::mem::offset_of!(pm_node_list, nodes) - 8usize];
};
#[doc = " A list of nodes in the source, most often used for lists of children."]
pub type pm_node_list_t = pm_node_list;
#[doc = " AliasGlobalVariableNode"]
pub const pm_node_type_PM_ALIAS_GLOBAL_VARIABLE_NODE: pm_node_type = 1;
#[doc = " AliasMethodNode"]
pub const pm_node_type_PM_ALIAS_METHOD_NODE: pm_node_type = 2;
#[doc = " AlternationPatternNode"]
pub const pm_node_type_PM_ALTERNATION_PATTERN_NODE: pm_node_type = 3;
#[doc = " AndNode"]
pub const pm_node_type_PM_AND_NODE: pm_node_type = 4;
#[doc = " ArgumentsNode"]
pub const pm_node_type_PM_ARGUMENTS_NODE: pm_node_type = 5;
#[doc = " ArrayNode"]
pub const pm_node_type_PM_ARRAY_NODE: pm_node_type = 6;
#[doc = " ArrayPatternNode"]
pub const pm_node_type_PM_ARRAY_PATTERN_NODE: pm_node_type = 7;
#[doc = " AssocNode"]
pub const pm_node_type_PM_ASSOC_NODE: pm_node_type = 8;
#[doc = " AssocSplatNode"]
pub const pm_node_type_PM_ASSOC_SPLAT_NODE: pm_node_type = 9;
#[doc = " BackReferenceReadNode"]
pub const pm_node_type_PM_BACK_REFERENCE_READ_NODE: pm_node_type = 10;
#[doc = " BeginNode"]
pub const pm_node_type_PM_BEGIN_NODE: pm_node_type = 11;
#[doc = " BlockArgumentNode"]
pub const pm_node_type_PM_BLOCK_ARGUMENT_NODE: pm_node_type = 12;
#[doc = " BlockLocalVariableNode"]
pub const pm_node_type_PM_BLOCK_LOCAL_VARIABLE_NODE: pm_node_type = 13;
#[doc = " BlockNode"]
pub const pm_node_type_PM_BLOCK_NODE: pm_node_type = 14;
#[doc = " BlockParameterNode"]
pub const pm_node_type_PM_BLOCK_PARAMETER_NODE: pm_node_type = 15;
#[doc = " BlockParametersNode"]
pub const pm_node_type_PM_BLOCK_PARAMETERS_NODE: pm_node_type = 16;
#[doc = " BreakNode"]
pub const pm_node_type_PM_BREAK_NODE: pm_node_type = 17;
#[doc = " CallAndWriteNode"]
pub const pm_node_type_PM_CALL_AND_WRITE_NODE: pm_node_type = 18;
#[doc = " CallNode"]
pub const pm_node_type_PM_CALL_NODE: pm_node_type = 19;
#[doc = " CallOperatorWriteNode"]
pub const pm_node_type_PM_CALL_OPERATOR_WRITE_NODE: pm_node_type = 20;
#[doc = " CallOrWriteNode"]
pub const pm_node_type_PM_CALL_OR_WRITE_NODE: pm_node_type = 21;
#[doc = " CallTargetNode"]
pub const pm_node_type_PM_CALL_TARGET_NODE: pm_node_type = 22;
#[doc = " CapturePatternNode"]
pub const pm_node_type_PM_CAPTURE_PATTERN_NODE: pm_node_type = 23;
#[doc = " CaseMatchNode"]
pub const pm_node_type_PM_CASE_MATCH_NODE: pm_node_type = 24;
#[doc = " CaseNode"]
pub const pm_node_type_PM_CASE_NODE: pm_node_type = 25;
#[doc = " ClassNode"]
pub const pm_node_type_PM_CLASS_NODE: pm_node_type = 26;
#[doc = " ClassVariableAndWriteNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_AND_WRITE_NODE: pm_node_type = 27;
#[doc = " ClassVariableOperatorWriteNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_OPERATOR_WRITE_NODE: pm_node_type = 28;
#[doc = " ClassVariableOrWriteNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_OR_WRITE_NODE: pm_node_type = 29;
#[doc = " ClassVariableReadNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_READ_NODE: pm_node_type = 30;
#[doc = " ClassVariableTargetNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_TARGET_NODE: pm_node_type = 31;
#[doc = " ClassVariableWriteNode"]
pub const pm_node_type_PM_CLASS_VARIABLE_WRITE_NODE: pm_node_type = 32;
#[doc = " ConstantAndWriteNode"]
pub const pm_node_type_PM_CONSTANT_AND_WRITE_NODE: pm_node_type = 33;
#[doc = " ConstantOperatorWriteNode"]
pub const pm_node_type_PM_CONSTANT_OPERATOR_WRITE_NODE: pm_node_type = 34;
#[doc = " ConstantOrWriteNode"]
pub const pm_node_type_PM_CONSTANT_OR_WRITE_NODE: pm_node_type = 35;
#[doc = " ConstantPathAndWriteNode"]
pub const pm_node_type_PM_CONSTANT_PATH_AND_WRITE_NODE: pm_node_type = 36;
#[doc = " ConstantPathNode"]
pub const pm_node_type_PM_CONSTANT_PATH_NODE: pm_node_type = 37;
#[doc = " ConstantPathOperatorWriteNode"]
pub const pm_node_type_PM_CONSTANT_PATH_OPERATOR_WRITE_NODE: pm_node_type = 38;
#[doc = " ConstantPathOrWriteNode"]
pub const pm_node_type_PM_CONSTANT_PATH_OR_WRITE_NODE: pm_node_type = 39;
#[doc = " ConstantPathTargetNode"]
pub const pm_node_type_PM_CONSTANT_PATH_TARGET_NODE: pm_node_type = 40;
#[doc = " ConstantPathWriteNode"]
pub const pm_node_type_PM_CONSTANT_PATH_WRITE_NODE: pm_node_type = 41;
#[doc = " ConstantReadNode"]
pub const pm_node_type_PM_CONSTANT_READ_NODE: pm_node_type = 42;
#[doc = " ConstantTargetNode"]
pub const pm_node_type_PM_CONSTANT_TARGET_NODE: pm_node_type = 43;
#[doc = " ConstantWriteNode"]
pub const pm_node_type_PM_CONSTANT_WRITE_NODE: pm_node_type = 44;
#[doc = " DefNode"]
pub const pm_node_type_PM_DEF_NODE: pm_node_type = 45;
#[doc = " DefinedNode"]
pub const pm_node_type_PM_DEFINED_NODE: pm_node_type = 46;
#[doc = " ElseNode"]
pub const pm_node_type_PM_ELSE_NODE: pm_node_type = 47;
#[doc = " EmbeddedStatementsNode"]
pub const pm_node_type_PM_EMBEDDED_STATEMENTS_NODE: pm_node_type = 48;
#[doc = " EmbeddedVariableNode"]
pub const pm_node_type_PM_EMBEDDED_VARIABLE_NODE: pm_node_type = 49;
#[doc = " EnsureNode"]
pub const pm_node_type_PM_ENSURE_NODE: pm_node_type = 50;
#[doc = " FalseNode"]
pub const pm_node_type_PM_FALSE_NODE: pm_node_type = 51;
#[doc = " FindPatternNode"]
pub const pm_node_type_PM_FIND_PATTERN_NODE: pm_node_type = 52;
#[doc = " FlipFlopNode"]
pub const pm_node_type_PM_FLIP_FLOP_NODE: pm_node_type = 53;
#[doc = " FloatNode"]
pub const pm_node_type_PM_FLOAT_NODE: pm_node_type = 54;
#[doc = " ForNode"]
pub const pm_node_type_PM_FOR_NODE: pm_node_type = 55;
#[doc = " ForwardingArgumentsNode"]
pub const pm_node_type_PM_FORWARDING_ARGUMENTS_NODE: pm_node_type = 56;
#[doc = " ForwardingParameterNode"]
pub const pm_node_type_PM_FORWARDING_PARAMETER_NODE: pm_node_type = 57;
#[doc = " ForwardingSuperNode"]
pub const pm_node_type_PM_FORWARDING_SUPER_NODE: pm_node_type = 58;
#[doc = " GlobalVariableAndWriteNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_AND_WRITE_NODE: pm_node_type = 59;
#[doc = " GlobalVariableOperatorWriteNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE: pm_node_type = 60;
#[doc = " GlobalVariableOrWriteNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_OR_WRITE_NODE: pm_node_type = 61;
#[doc = " GlobalVariableReadNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_READ_NODE: pm_node_type = 62;
#[doc = " GlobalVariableTargetNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_TARGET_NODE: pm_node_type = 63;
#[doc = " GlobalVariableWriteNode"]
pub const pm_node_type_PM_GLOBAL_VARIABLE_WRITE_NODE: pm_node_type = 64;
#[doc = " HashNode"]
pub const pm_node_type_PM_HASH_NODE: pm_node_type = 65;
#[doc = " HashPatternNode"]
pub const pm_node_type_PM_HASH_PATTERN_NODE: pm_node_type = 66;
#[doc = " IfNode"]
pub const pm_node_type_PM_IF_NODE: pm_node_type = 67;
#[doc = " ImaginaryNode"]
pub const pm_node_type_PM_IMAGINARY_NODE: pm_node_type = 68;
#[doc = " ImplicitNode"]
pub const pm_node_type_PM_IMPLICIT_NODE: pm_node_type = 69;
#[doc = " ImplicitRestNode"]
pub const pm_node_type_PM_IMPLICIT_REST_NODE: pm_node_type = 70;
#[doc = " InNode"]
pub const pm_node_type_PM_IN_NODE: pm_node_type = 71;
#[doc = " IndexAndWriteNode"]
pub const pm_node_type_PM_INDEX_AND_WRITE_NODE: pm_node_type = 72;
#[doc = " IndexOperatorWriteNode"]
pub const pm_node_type_PM_INDEX_OPERATOR_WRITE_NODE: pm_node_type = 73;
#[doc = " IndexOrWriteNode"]
pub const pm_node_type_PM_INDEX_OR_WRITE_NODE: pm_node_type = 74;
#[doc = " IndexTargetNode"]
pub const pm_node_type_PM_INDEX_TARGET_NODE: pm_node_type = 75;
#[doc = " InstanceVariableAndWriteNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_AND_WRITE_NODE: pm_node_type = 76;
#[doc = " InstanceVariableOperatorWriteNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE: pm_node_type = 77;
#[doc = " InstanceVariableOrWriteNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_OR_WRITE_NODE: pm_node_type = 78;
#[doc = " InstanceVariableReadNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_READ_NODE: pm_node_type = 79;
#[doc = " InstanceVariableTargetNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_TARGET_NODE: pm_node_type = 80;
#[doc = " InstanceVariableWriteNode"]
pub const pm_node_type_PM_INSTANCE_VARIABLE_WRITE_NODE: pm_node_type = 81;
#[doc = " IntegerNode"]
pub const pm_node_type_PM_INTEGER_NODE: pm_node_type = 82;
#[doc = " InterpolatedMatchLastLineNode"]
pub const pm_node_type_PM_INTERPOLATED_MATCH_LAST_LINE_NODE: pm_node_type = 83;
#[doc = " InterpolatedRegularExpressionNode"]
pub const pm_node_type_PM_INTERPOLATED_REGULAR_EXPRESSION_NODE: pm_node_type = 84;
#[doc = " InterpolatedStringNode"]
pub const pm_node_type_PM_INTERPOLATED_STRING_NODE: pm_node_type = 85;
#[doc = " InterpolatedSymbolNode"]
pub const pm_node_type_PM_INTERPOLATED_SYMBOL_NODE: pm_node_type = 86;
#[doc = " InterpolatedXStringNode"]
pub const pm_node_type_PM_INTERPOLATED_X_STRING_NODE: pm_node_type = 87;
#[doc = " ItLocalVariableReadNode"]
pub const pm_node_type_PM_IT_LOCAL_VARIABLE_READ_NODE: pm_node_type = 88;
#[doc = " ItParametersNode"]
pub const pm_node_type_PM_IT_PARAMETERS_NODE: pm_node_type = 89;
#[doc = " KeywordHashNode"]
pub const pm_node_type_PM_KEYWORD_HASH_NODE: pm_node_type = 90;
#[doc = " KeywordRestParameterNode"]
pub const pm_node_type_PM_KEYWORD_REST_PARAMETER_NODE: pm_node_type = 91;
#[doc = " LambdaNode"]
pub const pm_node_type_PM_LAMBDA_NODE: pm_node_type = 92;
#[doc = " LocalVariableAndWriteNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_AND_WRITE_NODE: pm_node_type = 93;
#[doc = " LocalVariableOperatorWriteNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_OPERATOR_WRITE_NODE: pm_node_type = 94;
#[doc = " LocalVariableOrWriteNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_OR_WRITE_NODE: pm_node_type = 95;
#[doc = " LocalVariableReadNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_READ_NODE: pm_node_type = 96;
#[doc = " LocalVariableTargetNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_TARGET_NODE: pm_node_type = 97;
#[doc = " LocalVariableWriteNode"]
pub const pm_node_type_PM_LOCAL_VARIABLE_WRITE_NODE: pm_node_type = 98;
#[doc = " MatchLastLineNode"]
pub const pm_node_type_PM_MATCH_LAST_LINE_NODE: pm_node_type = 99;
#[doc = " MatchPredicateNode"]
pub const pm_node_type_PM_MATCH_PREDICATE_NODE: pm_node_type = 100;
#[doc = " MatchRequiredNode"]
pub const pm_node_type_PM_MATCH_REQUIRED_NODE: pm_node_type = 101;
#[doc = " MatchWriteNode"]
pub const pm_node_type_PM_MATCH_WRITE_NODE: pm_node_type = 102;
#[doc = " MissingNode"]
pub const pm_node_type_PM_MISSING_NODE: pm_node_type = 103;
#[doc = " ModuleNode"]
pub const pm_node_type_PM_MODULE_NODE: pm_node_type = 104;
#[doc = " MultiTargetNode"]
pub const pm_node_type_PM_MULTI_TARGET_NODE: pm_node_type = 105;
#[doc = " MultiWriteNode"]
pub const pm_node_type_PM_MULTI_WRITE_NODE: pm_node_type = 106;
#[doc = " NextNode"]
pub const pm_node_type_PM_NEXT_NODE: pm_node_type = 107;
#[doc = " NilNode"]
pub const pm_node_type_PM_NIL_NODE: pm_node_type = 108;
#[doc = " NoKeywordsParameterNode"]
pub const pm_node_type_PM_NO_KEYWORDS_PARAMETER_NODE: pm_node_type = 109;
#[doc = " NumberedParametersNode"]
pub const pm_node_type_PM_NUMBERED_PARAMETERS_NODE: pm_node_type = 110;
#[doc = " NumberedReferenceReadNode"]
pub const pm_node_type_PM_NUMBERED_REFERENCE_READ_NODE: pm_node_type = 111;
#[doc = " OptionalKeywordParameterNode"]
pub const pm_node_type_PM_OPTIONAL_KEYWORD_PARAMETER_NODE: pm_node_type = 112;
#[doc = " OptionalParameterNode"]
pub const pm_node_type_PM_OPTIONAL_PARAMETER_NODE: pm_node_type = 113;
#[doc = " OrNode"]
pub const pm_node_type_PM_OR_NODE: pm_node_type = 114;
#[doc = " ParametersNode"]
pub const pm_node_type_PM_PARAMETERS_NODE: pm_node_type = 115;
#[doc = " ParenthesesNode"]
pub const pm_node_type_PM_PARENTHESES_NODE: pm_node_type = 116;
#[doc = " PinnedExpressionNode"]
pub const pm_node_type_PM_PINNED_EXPRESSION_NODE: pm_node_type = 117;
#[doc = " PinnedVariableNode"]
pub const pm_node_type_PM_PINNED_VARIABLE_NODE: pm_node_type = 118;
#[doc = " PostExecutionNode"]
pub const pm_node_type_PM_POST_EXECUTION_NODE: pm_node_type = 119;
#[doc = " PreExecutionNode"]
pub const pm_node_type_PM_PRE_EXECUTION_NODE: pm_node_type = 120;
#[doc = " ProgramNode"]
pub const pm_node_type_PM_PROGRAM_NODE: pm_node_type = 121;
#[doc = " RangeNode"]
pub const pm_node_type_PM_RANGE_NODE: pm_node_type = 122;
#[doc = " RationalNode"]
pub const pm_node_type_PM_RATIONAL_NODE: pm_node_type = 123;
#[doc = " RedoNode"]
pub const pm_node_type_PM_REDO_NODE: pm_node_type = 124;
#[doc = " RegularExpressionNode"]
pub const pm_node_type_PM_REGULAR_EXPRESSION_NODE: pm_node_type = 125;
#[doc = " RequiredKeywordParameterNode"]
pub const pm_node_type_PM_REQUIRED_KEYWORD_PARAMETER_NODE: pm_node_type = 126;
#[doc = " RequiredParameterNode"]
pub const pm_node_type_PM_REQUIRED_PARAMETER_NODE: pm_node_type = 127;
#[doc = " RescueModifierNode"]
pub const pm_node_type_PM_RESCUE_MODIFIER_NODE: pm_node_type = 128;
#[doc = " RescueNode"]
pub const pm_node_type_PM_RESCUE_NODE: pm_node_type = 129;
#[doc = " RestParameterNode"]
pub const pm_node_type_PM_REST_PARAMETER_NODE: pm_node_type = 130;
#[doc = " RetryNode"]
pub const pm_node_type_PM_RETRY_NODE: pm_node_type = 131;
#[doc = " ReturnNode"]
pub const pm_node_type_PM_RETURN_NODE: pm_node_type = 132;
#[doc = " SelfNode"]
pub const pm_node_type_PM_SELF_NODE: pm_node_type = 133;
#[doc = " ShareableConstantNode"]
pub const pm_node_type_PM_SHAREABLE_CONSTANT_NODE: pm_node_type = 134;
#[doc = " SingletonClassNode"]
pub const pm_node_type_PM_SINGLETON_CLASS_NODE: pm_node_type = 135;
#[doc = " SourceEncodingNode"]
pub const pm_node_type_PM_SOURCE_ENCODING_NODE: pm_node_type = 136;
#[doc = " SourceFileNode"]
pub const pm_node_type_PM_SOURCE_FILE_NODE: pm_node_type = 137;
#[doc = " SourceLineNode"]
pub const pm_node_type_PM_SOURCE_LINE_NODE: pm_node_type = 138;
#[doc = " SplatNode"]
pub const pm_node_type_PM_SPLAT_NODE: pm_node_type = 139;
#[doc = " StatementsNode"]
pub const pm_node_type_PM_STATEMENTS_NODE: pm_node_type = 140;
#[doc = " StringNode"]
pub const pm_node_type_PM_STRING_NODE: pm_node_type = 141;
#[doc = " SuperNode"]
pub const pm_node_type_PM_SUPER_NODE: pm_node_type = 142;
#[doc = " SymbolNode"]
pub const pm_node_type_PM_SYMBOL_NODE: pm_node_type = 143;
#[doc = " TrueNode"]
pub const pm_node_type_PM_TRUE_NODE: pm_node_type = 144;
#[doc = " UndefNode"]
pub const pm_node_type_PM_UNDEF_NODE: pm_node_type = 145;
#[doc = " UnlessNode"]
pub const pm_node_type_PM_UNLESS_NODE: pm_node_type = 146;
#[doc = " UntilNode"]
pub const pm_node_type_PM_UNTIL_NODE: pm_node_type = 147;
#[doc = " WhenNode"]
pub const pm_node_type_PM_WHEN_NODE: pm_node_type = 148;
#[doc = " WhileNode"]
pub const pm_node_type_PM_WHILE_NODE: pm_node_type = 149;
#[doc = " XStringNode"]
pub const pm_node_type_PM_X_STRING_NODE: pm_node_type = 150;
#[doc = " YieldNode"]
pub const pm_node_type_PM_YIELD_NODE: pm_node_type = 151;
#[doc = " A special kind of node used for compilation."]
pub const pm_node_type_PM_SCOPE_NODE: pm_node_type = 152;
#[doc = " This enum represents every type of node in the Ruby syntax tree."]
pub type pm_node_type = ::std::os::raw::c_uint;
#[doc = " This is the type of node embedded in the node struct. We explicitly control\n the size of it here to avoid having the variable-width enum."]
pub type pm_node_type_t = u16;
#[doc = " These are the flags embedded in the node struct. We explicitly control the\n size of it here to avoid having the variable-width enum."]
pub type pm_node_flags_t = u16;
#[doc = " We store the flags enum in every node in the tree. Some flags are common to\n all nodes (the ones listed below). Others are specific to certain node types."]
pub const PM_NODE_FLAG_NEWLINE: pm_node_flags_t = 1;
pub const PM_NODE_FLAG_STATIC_LITERAL: pm_node_flags_t = 2;
#[doc = " This is the base structure that represents a node in the syntax tree. It is\n embedded into every node type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_node {
    #[doc = " This represents the type of the node. It somewhat maps to the nodes that\n existed in the original grammar and ripper, but it's not a 1:1 mapping."]
    pub type_: pm_node_type_t,
    #[doc = " This represents any flags on the node. Some are common to all nodes, and\n some are specific to the type of node."]
    pub flags: pm_node_flags_t,
    #[doc = " The unique identifier for this node, which is deterministic based on the\n source. It is used to identify unique nodes across parses."]
    pub node_id: u32,
    #[doc = " This is the location of the node in the source. It's a range of bytes\n containing a start and an end."]
    pub location: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_node"][::std::mem::size_of::<pm_node>() - 16usize];
    ["Alignment of pm_node"][::std::mem::align_of::<pm_node>() - 4usize];
    ["Offset of field: pm_node::type_"][::std::mem::offset_of!(pm_node, type_) - 0usize];
    ["Offset of field: pm_node::flags"][::std::mem::offset_of!(pm_node, flags) - 2usize];
    ["Offset of field: pm_node::node_id"][::std::mem::offset_of!(pm_node, node_id) - 4usize];
    ["Offset of field: pm_node::location"][::std::mem::offset_of!(pm_node, location) - 8usize];
};
#[doc = " This is the base structure that represents a node in the syntax tree. It is\n embedded into every node type."]
pub type pm_node_t = pm_node;
#[doc = " AliasGlobalVariableNode\n\n Represents the use of the `alias` keyword to alias a global variable.\n\n     alias $foo $bar\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_ALIAS_GLOBAL_VARIABLE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_alias_global_variable_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AliasGlobalVariableNode#new_name\n\n Represents the new name of the global variable that can be used after aliasing.\n\n     alias $foo $bar\n           ^^^^"]
    pub new_name: *mut pm_node,
    #[doc = " AliasGlobalVariableNode#old_name\n\n Represents the old name of the global variable that can be used before aliasing.\n\n     alias $foo $bar\n                ^^^^"]
    pub old_name: *mut pm_node,
    #[doc = " AliasGlobalVariableNode#keyword_loc\n\n The location of the `alias` keyword.\n\n     alias $foo $bar\n     ^^^^^"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_alias_global_variable_node"]
        [::std::mem::size_of::<pm_alias_global_variable_node>() - 32usize];
    ["Alignment of pm_alias_global_variable_node"]
        [::std::mem::align_of::<pm_alias_global_variable_node>() - 4usize];
    ["Offset of field: pm_alias_global_variable_node::base"]
        [::std::mem::offset_of!(pm_alias_global_variable_node, base) - 0usize];
    ["Offset of field: pm_alias_global_variable_node::new_name"]
        [::std::mem::offset_of!(pm_alias_global_variable_node, new_name) - 16usize];
    ["Offset of field: pm_alias_global_variable_node::old_name"]
        [::std::mem::offset_of!(pm_alias_global_variable_node, old_name) - 20usize];
    ["Offset of field: pm_alias_global_variable_node::keyword_loc"]
        [::std::mem::offset_of!(pm_alias_global_variable_node, keyword_loc) - 24usize];
};
#[doc = " AliasGlobalVariableNode\n\n Represents the use of the `alias` keyword to alias a global variable.\n\n     alias $foo $bar\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_ALIAS_GLOBAL_VARIABLE_NODE\n\n @extends pm_node_t"]
pub type pm_alias_global_variable_node_t = pm_alias_global_variable_node;
#[doc = " AliasMethodNode\n\n Represents the use of the `alias` keyword to alias a method.\n\n     alias foo bar\n     ^^^^^^^^^^^^^\n\n Type: ::PM_ALIAS_METHOD_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_alias_method_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AliasMethodNode#new_name\n\n Represents the new name of the method that will be aliased.\n\n     alias foo bar\n           ^^^\n\n     alias :foo :bar\n           ^^^^\n\n     alias :\"#{foo}\" :\"#{bar}\"\n           ^^^^^^^^^"]
    pub new_name: *mut pm_node,
    #[doc = " AliasMethodNode#old_name\n\n Represents the old name of the method that will be aliased.\n\n     alias foo bar\n               ^^^\n\n     alias :foo :bar\n                ^^^^\n\n     alias :\"#{foo}\" :\"#{bar}\"\n                     ^^^^^^^^^"]
    pub old_name: *mut pm_node,
    #[doc = " AliasMethodNode#keyword_loc\n\n Represents the location of the `alias` keyword.\n\n     alias foo bar\n     ^^^^^"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_alias_method_node"][::std::mem::size_of::<pm_alias_method_node>() - 32usize];
    ["Alignment of pm_alias_method_node"][::std::mem::align_of::<pm_alias_method_node>() - 4usize];
    ["Offset of field: pm_alias_method_node::base"]
        [::std::mem::offset_of!(pm_alias_method_node, base) - 0usize];
    ["Offset of field: pm_alias_method_node::new_name"]
        [::std::mem::offset_of!(pm_alias_method_node, new_name) - 16usize];
    ["Offset of field: pm_alias_method_node::old_name"]
        [::std::mem::offset_of!(pm_alias_method_node, old_name) - 20usize];
    ["Offset of field: pm_alias_method_node::keyword_loc"]
        [::std::mem::offset_of!(pm_alias_method_node, keyword_loc) - 24usize];
};
#[doc = " AliasMethodNode\n\n Represents the use of the `alias` keyword to alias a method.\n\n     alias foo bar\n     ^^^^^^^^^^^^^\n\n Type: ::PM_ALIAS_METHOD_NODE\n\n @extends pm_node_t"]
pub type pm_alias_method_node_t = pm_alias_method_node;
#[doc = " AlternationPatternNode\n\n Represents an alternation pattern in pattern matching.\n\n     foo => bar | baz\n            ^^^^^^^^^\n\n Type: ::PM_ALTERNATION_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_alternation_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AlternationPatternNode#left\n\n Represents the left side of the expression.\n\n     foo => bar | baz\n            ^^^"]
    pub left: *mut pm_node,
    #[doc = " AlternationPatternNode#right\n\n Represents the right side of the expression.\n\n     foo => bar | baz\n                  ^^^"]
    pub right: *mut pm_node,
    #[doc = " AlternationPatternNode#operator_loc\n\n Represents the alternation operator location.\n\n     foo => bar | baz\n                ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_alternation_pattern_node"]
        [::std::mem::size_of::<pm_alternation_pattern_node>() - 32usize];
    ["Alignment of pm_alternation_pattern_node"]
        [::std::mem::align_of::<pm_alternation_pattern_node>() - 4usize];
    ["Offset of field: pm_alternation_pattern_node::base"]
        [::std::mem::offset_of!(pm_alternation_pattern_node, base) - 0usize];
    ["Offset of field: pm_alternation_pattern_node::left"]
        [::std::mem::offset_of!(pm_alternation_pattern_node, left) - 16usize];
    ["Offset of field: pm_alternation_pattern_node::right"]
        [::std::mem::offset_of!(pm_alternation_pattern_node, right) - 20usize];
    ["Offset of field: pm_alternation_pattern_node::operator_loc"]
        [::std::mem::offset_of!(pm_alternation_pattern_node, operator_loc) - 24usize];
};
#[doc = " AlternationPatternNode\n\n Represents an alternation pattern in pattern matching.\n\n     foo => bar | baz\n            ^^^^^^^^^\n\n Type: ::PM_ALTERNATION_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_alternation_pattern_node_t = pm_alternation_pattern_node;
#[doc = " AndNode\n\n Represents the use of the `&&` operator or the `and` keyword.\n\n     left and right\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_AND_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_and_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AndNode#left\n\n Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     left and right\n     ^^^^\n\n     1 && 2\n     ^"]
    pub left: *mut pm_node,
    #[doc = " AndNode#right\n\n Represents the right side of the expression.\n\n     left && right\n             ^^^^^\n\n     1 and 2\n           ^"]
    pub right: *mut pm_node,
    #[doc = " AndNode#operator_loc\n\n The location of the `and` keyword or the `&&` operator.\n\n     left and right\n          ^^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_and_node"][::std::mem::size_of::<pm_and_node>() - 32usize];
    ["Alignment of pm_and_node"][::std::mem::align_of::<pm_and_node>() - 4usize];
    ["Offset of field: pm_and_node::base"][::std::mem::offset_of!(pm_and_node, base) - 0usize];
    ["Offset of field: pm_and_node::left"][::std::mem::offset_of!(pm_and_node, left) - 16usize];
    ["Offset of field: pm_and_node::right"][::std::mem::offset_of!(pm_and_node, right) - 20usize];
    ["Offset of field: pm_and_node::operator_loc"]
        [::std::mem::offset_of!(pm_and_node, operator_loc) - 24usize];
};
#[doc = " AndNode\n\n Represents the use of the `&&` operator or the `and` keyword.\n\n     left and right\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_AND_NODE\n\n @extends pm_node_t"]
pub type pm_and_node_t = pm_and_node;
#[doc = " ArgumentsNode\n\n Represents a set of arguments to a method or a keyword.\n\n     return foo, bar, baz\n            ^^^^^^^^^^^^^\n\n Type: ::PM_ARGUMENTS_NODE\n\n Flags (#pm_arguments_node_flags):\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_FORWARDING\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORDS\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORD_SPLAT\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_SPLAT\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_MULTIPLE_SPLATS\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_arguments_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ArgumentsNode#arguments\n\n The list of arguments, if present. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo(bar, baz)\n         ^^^^^^^^"]
    pub arguments: pm_node_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_arguments_node"][::std::mem::size_of::<pm_arguments_node>() - 28usize];
    ["Alignment of pm_arguments_node"][::std::mem::align_of::<pm_arguments_node>() - 4usize];
    ["Offset of field: pm_arguments_node::base"]
        [::std::mem::offset_of!(pm_arguments_node, base) - 0usize];
    ["Offset of field: pm_arguments_node::arguments"]
        [::std::mem::offset_of!(pm_arguments_node, arguments) - 16usize];
};
#[doc = " ArgumentsNode\n\n Represents a set of arguments to a method or a keyword.\n\n     return foo, bar, baz\n            ^^^^^^^^^^^^^\n\n Type: ::PM_ARGUMENTS_NODE\n\n Flags (#pm_arguments_node_flags):\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_FORWARDING\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORDS\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORD_SPLAT\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_SPLAT\n * ::PM_ARGUMENTS_NODE_FLAGS_CONTAINS_MULTIPLE_SPLATS\n\n @extends pm_node_t"]
pub type pm_arguments_node_t = pm_arguments_node;
#[doc = " ArrayNode\n\n Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.\n\n     [1, 2, 3]\n     ^^^^^^^^^\n\n Type: ::PM_ARRAY_NODE\n\n Flags (#pm_array_node_flags):\n * ::PM_ARRAY_NODE_FLAGS_CONTAINS_SPLAT\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_array_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ArrayNode#elements\n\n Represent the list of zero or more [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression) within the array."]
    pub elements: pm_node_list,
    #[doc = " ArrayNode#opening_loc\n\n Represents the optional source location for the opening token.\n\n     [1,2,3]                 # \"[\"\n     %w[foo bar baz]         # \"%w[\"\n     %I(apple orange banana) # \"%I(\"\n     foo = 1, 2, 3           # nil"]
    pub opening_loc: pm_location_t,
    #[doc = " ArrayNode#closing_loc\n\n Represents the optional source location for the closing token.\n\n     [1,2,3]                 # \"]\"\n     %w[foo bar baz]         # \"]\"\n     %I(apple orange banana) # \")\"\n     foo = 1, 2, 3           # nil"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_array_node"][::std::mem::size_of::<pm_array_node>() - 44usize];
    ["Alignment of pm_array_node"][::std::mem::align_of::<pm_array_node>() - 4usize];
    ["Offset of field: pm_array_node::base"][::std::mem::offset_of!(pm_array_node, base) - 0usize];
    ["Offset of field: pm_array_node::elements"]
        [::std::mem::offset_of!(pm_array_node, elements) - 16usize];
    ["Offset of field: pm_array_node::opening_loc"]
        [::std::mem::offset_of!(pm_array_node, opening_loc) - 28usize];
    ["Offset of field: pm_array_node::closing_loc"]
        [::std::mem::offset_of!(pm_array_node, closing_loc) - 36usize];
};
#[doc = " ArrayNode\n\n Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.\n\n     [1, 2, 3]\n     ^^^^^^^^^\n\n Type: ::PM_ARRAY_NODE\n\n Flags (#pm_array_node_flags):\n * ::PM_ARRAY_NODE_FLAGS_CONTAINS_SPLAT\n\n @extends pm_node_t"]
pub type pm_array_node_t = pm_array_node;
#[doc = " ArrayPatternNode\n\n Represents an array pattern in pattern matching.\n\n     foo in 1, 2\n     ^^^^^^^^^^^\n\n     foo in [1, 2]\n     ^^^^^^^^^^^^^\n\n     foo in *bar\n     ^^^^^^^^^^^\n\n     foo in Bar[]\n     ^^^^^^^^^^^^\n\n     foo in Bar[1, 2, 3]\n     ^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_ARRAY_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_array_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ArrayPatternNode#constant"]
    pub constant: *mut pm_node,
    #[doc = " ArrayPatternNode#requireds\n\n Represents the required elements of the array pattern.\n\n     foo in [1, 2]\n             ^  ^"]
    pub requireds: pm_node_list,
    #[doc = " ArrayPatternNode#rest\n\n Represents the rest element of the array pattern.\n\n     foo in *bar\n            ^^^^"]
    pub rest: *mut pm_node,
    #[doc = " ArrayPatternNode#posts\n\n Represents the elements after the rest element of the array pattern.\n\n     foo in *bar, baz\n                  ^^^"]
    pub posts: pm_node_list,
    #[doc = " ArrayPatternNode#opening_loc\n\n Represents the opening location of the array pattern.\n\n     foo in [1, 2]\n            ^"]
    pub opening_loc: pm_location_t,
    #[doc = " ArrayPatternNode#closing_loc\n\n Represents the closing location of the array pattern.\n\n     foo in [1, 2]\n                 ^"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_array_pattern_node"][::std::mem::size_of::<pm_array_pattern_node>() - 64usize];
    ["Alignment of pm_array_pattern_node"]
        [::std::mem::align_of::<pm_array_pattern_node>() - 4usize];
    ["Offset of field: pm_array_pattern_node::base"]
        [::std::mem::offset_of!(pm_array_pattern_node, base) - 0usize];
    ["Offset of field: pm_array_pattern_node::constant"]
        [::std::mem::offset_of!(pm_array_pattern_node, constant) - 16usize];
    ["Offset of field: pm_array_pattern_node::requireds"]
        [::std::mem::offset_of!(pm_array_pattern_node, requireds) - 20usize];
    ["Offset of field: pm_array_pattern_node::rest"]
        [::std::mem::offset_of!(pm_array_pattern_node, rest) - 32usize];
    ["Offset of field: pm_array_pattern_node::posts"]
        [::std::mem::offset_of!(pm_array_pattern_node, posts) - 36usize];
    ["Offset of field: pm_array_pattern_node::opening_loc"]
        [::std::mem::offset_of!(pm_array_pattern_node, opening_loc) - 48usize];
    ["Offset of field: pm_array_pattern_node::closing_loc"]
        [::std::mem::offset_of!(pm_array_pattern_node, closing_loc) - 56usize];
};
#[doc = " ArrayPatternNode\n\n Represents an array pattern in pattern matching.\n\n     foo in 1, 2\n     ^^^^^^^^^^^\n\n     foo in [1, 2]\n     ^^^^^^^^^^^^^\n\n     foo in *bar\n     ^^^^^^^^^^^\n\n     foo in Bar[]\n     ^^^^^^^^^^^^\n\n     foo in Bar[1, 2, 3]\n     ^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_ARRAY_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_array_pattern_node_t = pm_array_pattern_node;
#[doc = " AssocNode\n\n Represents a hash key/value pair.\n\n     { a => b }\n       ^^^^^^\n\n Type: ::PM_ASSOC_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_assoc_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AssocNode#key\n\n The key of the association. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     { a: b }\n       ^\n\n     { foo => bar }\n       ^^^\n\n     { def a; end => 1 }\n       ^^^^^^^^^^"]
    pub key: *mut pm_node,
    #[doc = " AssocNode#value\n\n The value of the association, if present. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     { foo => bar }\n              ^^^\n\n     { x: 1 }\n          ^"]
    pub value: *mut pm_node,
    #[doc = " AssocNode#operator_loc\n\n The location of the `=>` operator, if present.\n\n     { foo => bar }\n           ^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_assoc_node"][::std::mem::size_of::<pm_assoc_node>() - 32usize];
    ["Alignment of pm_assoc_node"][::std::mem::align_of::<pm_assoc_node>() - 4usize];
    ["Offset of field: pm_assoc_node::base"][::std::mem::offset_of!(pm_assoc_node, base) - 0usize];
    ["Offset of field: pm_assoc_node::key"][::std::mem::offset_of!(pm_assoc_node, key) - 16usize];
    ["Offset of field: pm_assoc_node::value"]
        [::std::mem::offset_of!(pm_assoc_node, value) - 20usize];
    ["Offset of field: pm_assoc_node::operator_loc"]
        [::std::mem::offset_of!(pm_assoc_node, operator_loc) - 24usize];
};
#[doc = " AssocNode\n\n Represents a hash key/value pair.\n\n     { a => b }\n       ^^^^^^\n\n Type: ::PM_ASSOC_NODE\n\n @extends pm_node_t"]
pub type pm_assoc_node_t = pm_assoc_node;
#[doc = " AssocSplatNode\n\n Represents a splat in a hash literal.\n\n     { **foo }\n       ^^^^^\n\n Type: ::PM_ASSOC_SPLAT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_assoc_splat_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " AssocSplatNode#value\n\n The value to be splatted, if present. Will be missing when keyword rest argument forwarding is used.\n\n     { **foo }\n         ^^^"]
    pub value: *mut pm_node,
    #[doc = " AssocSplatNode#operator_loc\n\n The location of the `**` operator.\n\n     { **x }\n       ^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_assoc_splat_node"][::std::mem::size_of::<pm_assoc_splat_node>() - 28usize];
    ["Alignment of pm_assoc_splat_node"][::std::mem::align_of::<pm_assoc_splat_node>() - 4usize];
    ["Offset of field: pm_assoc_splat_node::base"]
        [::std::mem::offset_of!(pm_assoc_splat_node, base) - 0usize];
    ["Offset of field: pm_assoc_splat_node::value"]
        [::std::mem::offset_of!(pm_assoc_splat_node, value) - 16usize];
    ["Offset of field: pm_assoc_splat_node::operator_loc"]
        [::std::mem::offset_of!(pm_assoc_splat_node, operator_loc) - 20usize];
};
#[doc = " AssocSplatNode\n\n Represents a splat in a hash literal.\n\n     { **foo }\n       ^^^^^\n\n Type: ::PM_ASSOC_SPLAT_NODE\n\n @extends pm_node_t"]
pub type pm_assoc_splat_node_t = pm_assoc_splat_node;
#[doc = " BackReferenceReadNode\n\n Represents reading a reference to a field in the previous match.\n\n     $'\n     ^^\n\n Type: ::PM_BACK_REFERENCE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_back_reference_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BackReferenceReadNode#name\n\n The name of the back-reference variable, including the leading `$`.\n\n     $& # name `:$&`\n\n     $+ # name `:$+`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_back_reference_read_node"]
        [::std::mem::size_of::<pm_back_reference_read_node>() - 20usize];
    ["Alignment of pm_back_reference_read_node"]
        [::std::mem::align_of::<pm_back_reference_read_node>() - 4usize];
    ["Offset of field: pm_back_reference_read_node::base"]
        [::std::mem::offset_of!(pm_back_reference_read_node, base) - 0usize];
    ["Offset of field: pm_back_reference_read_node::name"]
        [::std::mem::offset_of!(pm_back_reference_read_node, name) - 16usize];
};
#[doc = " BackReferenceReadNode\n\n Represents reading a reference to a field in the previous match.\n\n     $'\n     ^^\n\n Type: ::PM_BACK_REFERENCE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_back_reference_read_node_t = pm_back_reference_read_node;
#[doc = " BeginNode\n\n Represents a begin statement.\n\n     begin\n       foo\n     end\n     ^^^^^\n\n Type: ::PM_BEGIN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_begin_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BeginNode#begin_keyword_loc\n\n Represents the location of the `begin` keyword.\n\n     begin x end\n     ^^^^^"]
    pub begin_keyword_loc: pm_location_t,
    #[doc = " BeginNode#statements\n\n Represents the statements within the begin block.\n\n     begin x end\n           ^"]
    pub statements: *mut pm_statements_node,
    #[doc = " BeginNode#rescue_clause\n\n Represents the rescue clause within the begin block.\n\n     begin x; rescue y; end\n              ^^^^^^^^"]
    pub rescue_clause: *mut pm_rescue_node,
    #[doc = " BeginNode#else_clause\n\n Represents the else clause within the begin block.\n\n     begin x; rescue y; else z; end\n                        ^^^^^^"]
    pub else_clause: *mut pm_else_node,
    #[doc = " BeginNode#ensure_clause\n\n Represents the ensure clause within the begin block.\n\n     begin x; ensure y; end\n              ^^^^^^^^"]
    pub ensure_clause: *mut pm_ensure_node,
    #[doc = " BeginNode#end_keyword_loc\n\n Represents the location of the `end` keyword.\n\n     begin x end\n             ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_begin_node"][::std::mem::size_of::<pm_begin_node>() - 48usize];
    ["Alignment of pm_begin_node"][::std::mem::align_of::<pm_begin_node>() - 4usize];
    ["Offset of field: pm_begin_node::base"][::std::mem::offset_of!(pm_begin_node, base) - 0usize];
    ["Offset of field: pm_begin_node::begin_keyword_loc"]
        [::std::mem::offset_of!(pm_begin_node, begin_keyword_loc) - 16usize];
    ["Offset of field: pm_begin_node::statements"]
        [::std::mem::offset_of!(pm_begin_node, statements) - 24usize];
    ["Offset of field: pm_begin_node::rescue_clause"]
        [::std::mem::offset_of!(pm_begin_node, rescue_clause) - 28usize];
    ["Offset of field: pm_begin_node::else_clause"]
        [::std::mem::offset_of!(pm_begin_node, else_clause) - 32usize];
    ["Offset of field: pm_begin_node::ensure_clause"]
        [::std::mem::offset_of!(pm_begin_node, ensure_clause) - 36usize];
    ["Offset of field: pm_begin_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_begin_node, end_keyword_loc) - 40usize];
};
#[doc = " BeginNode\n\n Represents a begin statement.\n\n     begin\n       foo\n     end\n     ^^^^^\n\n Type: ::PM_BEGIN_NODE\n\n @extends pm_node_t"]
pub type pm_begin_node_t = pm_begin_node;
#[doc = " BlockArgumentNode\n\n Represents a block argument using `&`.\n\n     bar(&args)\n     ^^^^^^^^^^\n\n Type: ::PM_BLOCK_ARGUMENT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_argument_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockArgumentNode#expression\n\n The expression that is being passed as a block argument. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo(&args)\n         ^^^^^"]
    pub expression: *mut pm_node,
    #[doc = " BlockArgumentNode#operator_loc\n\n Represents the location of the `&` operator.\n\n     foo(&args)\n         ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_argument_node"][::std::mem::size_of::<pm_block_argument_node>() - 28usize];
    ["Alignment of pm_block_argument_node"]
        [::std::mem::align_of::<pm_block_argument_node>() - 4usize];
    ["Offset of field: pm_block_argument_node::base"]
        [::std::mem::offset_of!(pm_block_argument_node, base) - 0usize];
    ["Offset of field: pm_block_argument_node::expression"]
        [::std::mem::offset_of!(pm_block_argument_node, expression) - 16usize];
    ["Offset of field: pm_block_argument_node::operator_loc"]
        [::std::mem::offset_of!(pm_block_argument_node, operator_loc) - 20usize];
};
#[doc = " BlockArgumentNode\n\n Represents a block argument using `&`.\n\n     bar(&args)\n     ^^^^^^^^^^\n\n Type: ::PM_BLOCK_ARGUMENT_NODE\n\n @extends pm_node_t"]
pub type pm_block_argument_node_t = pm_block_argument_node;
#[doc = " BlockLocalVariableNode\n\n Represents a block local variable.\n\n     a { |; b| }\n            ^\n\n Type: ::PM_BLOCK_LOCAL_VARIABLE_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_local_variable_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockLocalVariableNode#name\n\n The name of the block local variable.\n\n     a { |; b| } # name `:b`\n            ^"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_local_variable_node"]
        [::std::mem::size_of::<pm_block_local_variable_node>() - 20usize];
    ["Alignment of pm_block_local_variable_node"]
        [::std::mem::align_of::<pm_block_local_variable_node>() - 4usize];
    ["Offset of field: pm_block_local_variable_node::base"]
        [::std::mem::offset_of!(pm_block_local_variable_node, base) - 0usize];
    ["Offset of field: pm_block_local_variable_node::name"]
        [::std::mem::offset_of!(pm_block_local_variable_node, name) - 16usize];
};
#[doc = " BlockLocalVariableNode\n\n Represents a block local variable.\n\n     a { |; b| }\n            ^\n\n Type: ::PM_BLOCK_LOCAL_VARIABLE_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_block_local_variable_node_t = pm_block_local_variable_node;
#[doc = " BlockNode\n\n Represents a block of ruby code.\n\n     [1, 2, 3].each { |i| puts x }\n                    ^^^^^^^^^^^^^^\n\n Type: ::PM_BLOCK_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockNode#locals\n\n The local variables declared in the block.\n\n     [1, 2, 3].each { |i| puts x } # locals: [:i]\n                       ^"]
    pub locals: pm_constant_id_list_t,
    #[doc = " BlockNode#parameters\n\n The parameters of the block.\n\n     [1, 2, 3].each { |i| puts x }\n                      ^^^\n     [1, 2, 3].each { puts _1 }\n                    ^^^^^^^^^^^\n     [1, 2, 3].each { puts it }\n                    ^^^^^^^^^^^"]
    pub parameters: *mut pm_node,
    #[doc = " BlockNode#body\n\n The body of the block.\n\n     [1, 2, 3].each { |i| puts x }\n                          ^^^^^^"]
    pub body: *mut pm_node,
    #[doc = " BlockNode#opening_loc\n\n Represents the location of the opening `|`.\n\n     [1, 2, 3].each { |i| puts x }\n                      ^"]
    pub opening_loc: pm_location_t,
    #[doc = " BlockNode#closing_loc\n\n Represents the location of the closing `|`.\n\n     [1, 2, 3].each { |i| puts x }\n                        ^"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_node"][::std::mem::size_of::<pm_block_node>() - 52usize];
    ["Alignment of pm_block_node"][::std::mem::align_of::<pm_block_node>() - 4usize];
    ["Offset of field: pm_block_node::base"][::std::mem::offset_of!(pm_block_node, base) - 0usize];
    ["Offset of field: pm_block_node::locals"]
        [::std::mem::offset_of!(pm_block_node, locals) - 16usize];
    ["Offset of field: pm_block_node::parameters"]
        [::std::mem::offset_of!(pm_block_node, parameters) - 28usize];
    ["Offset of field: pm_block_node::body"][::std::mem::offset_of!(pm_block_node, body) - 32usize];
    ["Offset of field: pm_block_node::opening_loc"]
        [::std::mem::offset_of!(pm_block_node, opening_loc) - 36usize];
    ["Offset of field: pm_block_node::closing_loc"]
        [::std::mem::offset_of!(pm_block_node, closing_loc) - 44usize];
};
#[doc = " BlockNode\n\n Represents a block of ruby code.\n\n     [1, 2, 3].each { |i| puts x }\n                    ^^^^^^^^^^^^^^\n\n Type: ::PM_BLOCK_NODE\n\n @extends pm_node_t"]
pub type pm_block_node_t = pm_block_node;
#[doc = " BlockParameterNode\n\n Represents a block parameter of a method, block, or lambda definition.\n\n     def a(&b)\n           ^^\n     end\n\n Type: ::PM_BLOCK_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockParameterNode#name\n\n The name of the block parameter.\n\n     def a(&b) # name `:b`\n            ^\n     end"]
    pub name: pm_constant_id_t,
    #[doc = " BlockParameterNode#name_loc\n\n Represents the location of the block parameter name.\n\n     def a(&b)\n            ^"]
    pub name_loc: pm_location_t,
    #[doc = " BlockParameterNode#operator_loc\n\n Represents the location of the `&` operator.\n\n     def a(&b)\n           ^\n     end"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_parameter_node"][::std::mem::size_of::<pm_block_parameter_node>() - 36usize];
    ["Alignment of pm_block_parameter_node"]
        [::std::mem::align_of::<pm_block_parameter_node>() - 4usize];
    ["Offset of field: pm_block_parameter_node::base"]
        [::std::mem::offset_of!(pm_block_parameter_node, base) - 0usize];
    ["Offset of field: pm_block_parameter_node::name"]
        [::std::mem::offset_of!(pm_block_parameter_node, name) - 16usize];
    ["Offset of field: pm_block_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_block_parameter_node, name_loc) - 20usize];
    ["Offset of field: pm_block_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_block_parameter_node, operator_loc) - 28usize];
};
#[doc = " BlockParameterNode\n\n Represents a block parameter of a method, block, or lambda definition.\n\n     def a(&b)\n           ^^\n     end\n\n Type: ::PM_BLOCK_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_block_parameter_node_t = pm_block_parameter_node;
#[doc = " BlockParametersNode\n\n Represents a block's parameters declaration.\n\n     -> (a, b = 1; local) { }\n        ^^^^^^^^^^^^^^^^^\n\n     foo do |a, b = 1; local|\n            ^^^^^^^^^^^^^^^^^\n     end\n\n Type: ::PM_BLOCK_PARAMETERS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_block_parameters_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BlockParametersNode#parameters\n\n Represents the parameters of the block.\n\n     -> (a, b = 1; local) { }\n         ^^^^^^^^\n\n     foo do |a, b = 1; local|\n             ^^^^^^^^\n     end"]
    pub parameters: *mut pm_parameters_node,
    #[doc = " BlockParametersNode#locals\n\n Represents the local variables of the block.\n\n     -> (a, b = 1; local) { }\n                   ^^^^^\n\n     foo do |a, b = 1; local|\n                       ^^^^^\n     end"]
    pub locals: pm_node_list,
    #[doc = " BlockParametersNode#opening_loc\n\n Represents the opening location of the block parameters.\n\n     -> (a, b = 1; local) { }\n        ^\n\n     foo do |a, b = 1; local|\n            ^\n     end"]
    pub opening_loc: pm_location_t,
    #[doc = " BlockParametersNode#closing_loc\n\n Represents the closing location of the block parameters.\n\n     -> (a, b = 1; local) { }\n                        ^\n\n     foo do |a, b = 1; local|\n                            ^\n     end"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_block_parameters_node"]
        [::std::mem::size_of::<pm_block_parameters_node>() - 48usize];
    ["Alignment of pm_block_parameters_node"]
        [::std::mem::align_of::<pm_block_parameters_node>() - 4usize];
    ["Offset of field: pm_block_parameters_node::base"]
        [::std::mem::offset_of!(pm_block_parameters_node, base) - 0usize];
    ["Offset of field: pm_block_parameters_node::parameters"]
        [::std::mem::offset_of!(pm_block_parameters_node, parameters) - 16usize];
    ["Offset of field: pm_block_parameters_node::locals"]
        [::std::mem::offset_of!(pm_block_parameters_node, locals) - 20usize];
    ["Offset of field: pm_block_parameters_node::opening_loc"]
        [::std::mem::offset_of!(pm_block_parameters_node, opening_loc) - 32usize];
    ["Offset of field: pm_block_parameters_node::closing_loc"]
        [::std::mem::offset_of!(pm_block_parameters_node, closing_loc) - 40usize];
};
#[doc = " BlockParametersNode\n\n Represents a block's parameters declaration.\n\n     -> (a, b = 1; local) { }\n        ^^^^^^^^^^^^^^^^^\n\n     foo do |a, b = 1; local|\n            ^^^^^^^^^^^^^^^^^\n     end\n\n Type: ::PM_BLOCK_PARAMETERS_NODE\n\n @extends pm_node_t"]
pub type pm_block_parameters_node_t = pm_block_parameters_node;
#[doc = " BreakNode\n\n Represents the use of the `break` keyword.\n\n     break foo\n     ^^^^^^^^^\n\n Type: ::PM_BREAK_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_break_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " BreakNode#arguments\n\n The arguments to the break statement, if present. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     break foo\n           ^^^"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " BreakNode#keyword_loc\n\n The location of the `break` keyword.\n\n     break foo\n     ^^^^^"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_break_node"][::std::mem::size_of::<pm_break_node>() - 28usize];
    ["Alignment of pm_break_node"][::std::mem::align_of::<pm_break_node>() - 4usize];
    ["Offset of field: pm_break_node::base"][::std::mem::offset_of!(pm_break_node, base) - 0usize];
    ["Offset of field: pm_break_node::arguments"]
        [::std::mem::offset_of!(pm_break_node, arguments) - 16usize];
    ["Offset of field: pm_break_node::keyword_loc"]
        [::std::mem::offset_of!(pm_break_node, keyword_loc) - 20usize];
};
#[doc = " BreakNode\n\n Represents the use of the `break` keyword.\n\n     break foo\n     ^^^^^^^^^\n\n Type: ::PM_BREAK_NODE\n\n @extends pm_node_t"]
pub type pm_break_node_t = pm_break_node;
#[doc = " CallAndWriteNode\n\n Represents the use of the `&&=` operator on a call.\n\n     foo.bar &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_AND_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallAndWriteNode#receiver\n\n The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar &&= value\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallAndWriteNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar &&= value\n        ^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallAndWriteNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar &&= value\n         ^^^"]
    pub message_loc: pm_location_t,
    #[doc = " CallAndWriteNode#read_name\n\n Represents the name of the method being called.\n\n     foo.bar &&= value # read_name `:bar`\n         ^^^"]
    pub read_name: pm_constant_id_t,
    #[doc = " CallAndWriteNode#write_name\n\n Represents the name of the method being written to.\n\n     foo.bar &&= value # write_name `:bar=`\n         ^^^"]
    pub write_name: pm_constant_id_t,
    #[doc = " CallAndWriteNode#operator_loc\n\n Represents the location of the operator.\n\n     foo.bar &&= value\n             ^^^"]
    pub operator_loc: pm_location_t,
    #[doc = " CallAndWriteNode#value\n\n Represents the value being assigned.\n\n     foo.bar &&= value\n                 ^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_and_write_node"][::std::mem::size_of::<pm_call_and_write_node>() - 56usize];
    ["Alignment of pm_call_and_write_node"]
        [::std::mem::align_of::<pm_call_and_write_node>() - 4usize];
    ["Offset of field: pm_call_and_write_node::base"]
        [::std::mem::offset_of!(pm_call_and_write_node, base) - 0usize];
    ["Offset of field: pm_call_and_write_node::receiver"]
        [::std::mem::offset_of!(pm_call_and_write_node, receiver) - 16usize];
    ["Offset of field: pm_call_and_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_and_write_node, call_operator_loc) - 20usize];
    ["Offset of field: pm_call_and_write_node::message_loc"]
        [::std::mem::offset_of!(pm_call_and_write_node, message_loc) - 28usize];
    ["Offset of field: pm_call_and_write_node::read_name"]
        [::std::mem::offset_of!(pm_call_and_write_node, read_name) - 36usize];
    ["Offset of field: pm_call_and_write_node::write_name"]
        [::std::mem::offset_of!(pm_call_and_write_node, write_name) - 40usize];
    ["Offset of field: pm_call_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_call_and_write_node, operator_loc) - 44usize];
    ["Offset of field: pm_call_and_write_node::value"]
        [::std::mem::offset_of!(pm_call_and_write_node, value) - 52usize];
};
#[doc = " CallAndWriteNode\n\n Represents the use of the `&&=` operator on a call.\n\n     foo.bar &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_AND_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_and_write_node_t = pm_call_and_write_node;
#[doc = " CallNode\n\n Represents a method call, in all of the various forms that can take.\n\n     foo\n     ^^^\n\n     foo()\n     ^^^^^\n\n     +foo\n     ^^^^\n\n     foo + bar\n     ^^^^^^^^^\n\n     foo.bar\n     ^^^^^^^\n\n     foo&.bar\n     ^^^^^^^^\n\n Type: ::PM_CALL_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallNode#receiver\n\n The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar\n     ^^^\n\n     +foo\n      ^^^\n\n     foo + bar\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar\n        ^\n\n     foo&.bar\n        ^^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallNode#name\n\n Represents the name of the method being called.\n\n     foo.bar # name `:foo`\n     ^^^"]
    pub name: pm_constant_id_t,
    #[doc = " CallNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar\n         ^^^"]
    pub message_loc: pm_location_t,
    #[doc = " CallNode#opening_loc\n\n Represents the location of the left parenthesis.\n     foo(bar)\n        ^"]
    pub opening_loc: pm_location_t,
    #[doc = " CallNode#arguments\n\n Represents the arguments to the method call. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo(bar)\n         ^^^"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " CallNode#closing_loc\n\n Represents the location of the right parenthesis.\n\n     foo(bar)\n            ^"]
    pub closing_loc: pm_location_t,
    #[doc = " CallNode#block\n\n Represents the block that is being passed to the method.\n\n     foo { |a| a }\n         ^^^^^^^^^"]
    pub block: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_node"][::std::mem::size_of::<pm_call_node>() - 64usize];
    ["Alignment of pm_call_node"][::std::mem::align_of::<pm_call_node>() - 4usize];
    ["Offset of field: pm_call_node::base"][::std::mem::offset_of!(pm_call_node, base) - 0usize];
    ["Offset of field: pm_call_node::receiver"]
        [::std::mem::offset_of!(pm_call_node, receiver) - 16usize];
    ["Offset of field: pm_call_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_node, call_operator_loc) - 20usize];
    ["Offset of field: pm_call_node::name"][::std::mem::offset_of!(pm_call_node, name) - 28usize];
    ["Offset of field: pm_call_node::message_loc"]
        [::std::mem::offset_of!(pm_call_node, message_loc) - 32usize];
    ["Offset of field: pm_call_node::opening_loc"]
        [::std::mem::offset_of!(pm_call_node, opening_loc) - 40usize];
    ["Offset of field: pm_call_node::arguments"]
        [::std::mem::offset_of!(pm_call_node, arguments) - 48usize];
    ["Offset of field: pm_call_node::closing_loc"]
        [::std::mem::offset_of!(pm_call_node, closing_loc) - 52usize];
    ["Offset of field: pm_call_node::block"][::std::mem::offset_of!(pm_call_node, block) - 60usize];
};
#[doc = " CallNode\n\n Represents a method call, in all of the various forms that can take.\n\n     foo\n     ^^^\n\n     foo()\n     ^^^^^\n\n     +foo\n     ^^^^\n\n     foo + bar\n     ^^^^^^^^^\n\n     foo.bar\n     ^^^^^^^\n\n     foo&.bar\n     ^^^^^^^^\n\n Type: ::PM_CALL_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_node_t = pm_call_node;
#[doc = " CallOperatorWriteNode\n\n Represents the use of an assignment operator on a call.\n\n     foo.bar += baz\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_OPERATOR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallOperatorWriteNode#receiver\n\n The object that the method is being called on. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar += value\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallOperatorWriteNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar += value\n        ^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallOperatorWriteNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar += value\n         ^^^"]
    pub message_loc: pm_location_t,
    #[doc = " CallOperatorWriteNode#read_name\n\n Represents the name of the method being called.\n\n     foo.bar += value # read_name `:bar`\n         ^^^"]
    pub read_name: pm_constant_id_t,
    #[doc = " CallOperatorWriteNode#write_name\n\n Represents the name of the method being written to.\n\n     foo.bar += value # write_name `:bar=`\n         ^^^"]
    pub write_name: pm_constant_id_t,
    #[doc = " CallOperatorWriteNode#binary_operator\n\n Represents the binary operator being used.\n\n     foo.bar += value # binary_operator `:+`\n             ^"]
    pub binary_operator: pm_constant_id_t,
    #[doc = " CallOperatorWriteNode#binary_operator_loc\n\n Represents the location of the binary operator.\n\n     foo.bar += value\n             ^^"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " CallOperatorWriteNode#value\n\n Represents the value being assigned.\n\n     foo.bar += value\n                ^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_operator_write_node"]
        [::std::mem::size_of::<pm_call_operator_write_node>() - 60usize];
    ["Alignment of pm_call_operator_write_node"]
        [::std::mem::align_of::<pm_call_operator_write_node>() - 4usize];
    ["Offset of field: pm_call_operator_write_node::base"]
        [::std::mem::offset_of!(pm_call_operator_write_node, base) - 0usize];
    ["Offset of field: pm_call_operator_write_node::receiver"]
        [::std::mem::offset_of!(pm_call_operator_write_node, receiver) - 16usize];
    ["Offset of field: pm_call_operator_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_operator_write_node, call_operator_loc) - 20usize];
    ["Offset of field: pm_call_operator_write_node::message_loc"]
        [::std::mem::offset_of!(pm_call_operator_write_node, message_loc) - 28usize];
    ["Offset of field: pm_call_operator_write_node::read_name"]
        [::std::mem::offset_of!(pm_call_operator_write_node, read_name) - 36usize];
    ["Offset of field: pm_call_operator_write_node::write_name"]
        [::std::mem::offset_of!(pm_call_operator_write_node, write_name) - 40usize];
    ["Offset of field: pm_call_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_call_operator_write_node, binary_operator) - 44usize];
    ["Offset of field: pm_call_operator_write_node::binary_operator_loc"]
        [::std::mem::offset_of!(pm_call_operator_write_node, binary_operator_loc) - 48usize];
    ["Offset of field: pm_call_operator_write_node::value"]
        [::std::mem::offset_of!(pm_call_operator_write_node, value) - 56usize];
};
#[doc = " CallOperatorWriteNode\n\n Represents the use of an assignment operator on a call.\n\n     foo.bar += baz\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_OPERATOR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_operator_write_node_t = pm_call_operator_write_node;
#[doc = " CallOrWriteNode\n\n Represents the use of the `||=` operator on a call.\n\n     foo.bar ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_OR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallOrWriteNode#receiver\n\n The object that the method is being called on. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar ||= value\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallOrWriteNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar ||= value\n        ^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallOrWriteNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar ||= value\n         ^^^"]
    pub message_loc: pm_location_t,
    #[doc = " CallOrWriteNode#read_name\n\n Represents the name of the method being called.\n\n     foo.bar ||= value # read_name `:bar`\n         ^^^"]
    pub read_name: pm_constant_id_t,
    #[doc = " CallOrWriteNode#write_name\n\n Represents the name of the method being written to.\n\n     foo.bar ||= value # write_name `:bar=`\n         ^^^"]
    pub write_name: pm_constant_id_t,
    #[doc = " CallOrWriteNode#operator_loc\n\n Represents the location of the operator.\n\n     foo.bar ||= value\n             ^^^"]
    pub operator_loc: pm_location_t,
    #[doc = " CallOrWriteNode#value\n\n Represents the value being assigned.\n\n     foo.bar ||= value\n                 ^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_or_write_node"][::std::mem::size_of::<pm_call_or_write_node>() - 56usize];
    ["Alignment of pm_call_or_write_node"]
        [::std::mem::align_of::<pm_call_or_write_node>() - 4usize];
    ["Offset of field: pm_call_or_write_node::base"]
        [::std::mem::offset_of!(pm_call_or_write_node, base) - 0usize];
    ["Offset of field: pm_call_or_write_node::receiver"]
        [::std::mem::offset_of!(pm_call_or_write_node, receiver) - 16usize];
    ["Offset of field: pm_call_or_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_or_write_node, call_operator_loc) - 20usize];
    ["Offset of field: pm_call_or_write_node::message_loc"]
        [::std::mem::offset_of!(pm_call_or_write_node, message_loc) - 28usize];
    ["Offset of field: pm_call_or_write_node::read_name"]
        [::std::mem::offset_of!(pm_call_or_write_node, read_name) - 36usize];
    ["Offset of field: pm_call_or_write_node::write_name"]
        [::std::mem::offset_of!(pm_call_or_write_node, write_name) - 40usize];
    ["Offset of field: pm_call_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_call_or_write_node, operator_loc) - 44usize];
    ["Offset of field: pm_call_or_write_node::value"]
        [::std::mem::offset_of!(pm_call_or_write_node, value) - 52usize];
};
#[doc = " CallOrWriteNode\n\n Represents the use of the `||=` operator on a call.\n\n     foo.bar ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CALL_OR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_or_write_node_t = pm_call_or_write_node;
#[doc = " CallTargetNode\n\n Represents assigning to a method call.\n\n     foo.bar, = 1\n     ^^^^^^^\n\n     begin\n     rescue => foo.bar\n               ^^^^^^^\n     end\n\n     for foo.bar in baz do end\n         ^^^^^^^\n\n Type: ::PM_CALL_TARGET_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_call_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CallTargetNode#receiver\n\n The object that the method is being called on. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo.bar = 1\n     ^^^"]
    pub receiver: *mut pm_node,
    #[doc = " CallTargetNode#call_operator_loc\n\n Represents the location of the call operator.\n\n     foo.bar = 1\n        ^"]
    pub call_operator_loc: pm_location_t,
    #[doc = " CallTargetNode#name\n\n Represents the name of the method being called.\n\n     foo.bar = 1 # name `:foo`\n     ^^^"]
    pub name: pm_constant_id_t,
    #[doc = " CallTargetNode#message_loc\n\n Represents the location of the message.\n\n     foo.bar = 1\n         ^^^"]
    pub message_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_call_target_node"][::std::mem::size_of::<pm_call_target_node>() - 40usize];
    ["Alignment of pm_call_target_node"][::std::mem::align_of::<pm_call_target_node>() - 4usize];
    ["Offset of field: pm_call_target_node::base"]
        [::std::mem::offset_of!(pm_call_target_node, base) - 0usize];
    ["Offset of field: pm_call_target_node::receiver"]
        [::std::mem::offset_of!(pm_call_target_node, receiver) - 16usize];
    ["Offset of field: pm_call_target_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_call_target_node, call_operator_loc) - 20usize];
    ["Offset of field: pm_call_target_node::name"]
        [::std::mem::offset_of!(pm_call_target_node, name) - 28usize];
    ["Offset of field: pm_call_target_node::message_loc"]
        [::std::mem::offset_of!(pm_call_target_node, message_loc) - 32usize];
};
#[doc = " CallTargetNode\n\n Represents assigning to a method call.\n\n     foo.bar, = 1\n     ^^^^^^^\n\n     begin\n     rescue => foo.bar\n               ^^^^^^^\n     end\n\n     for foo.bar in baz do end\n         ^^^^^^^\n\n Type: ::PM_CALL_TARGET_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_call_target_node_t = pm_call_target_node;
#[doc = " CapturePatternNode\n\n Represents assigning to a local variable in pattern matching.\n\n     foo => [bar => baz]\n            ^^^^^^^^^^^^\n\n Type: ::PM_CAPTURE_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_capture_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CapturePatternNode#value\n\n Represents the value to capture.\n\n     foo => bar\n            ^^^"]
    pub value: *mut pm_node,
    #[doc = " CapturePatternNode#target\n\n Represents the target of the capture.\n\n     foo => bar\n     ^^^"]
    pub target: *mut pm_local_variable_target_node,
    #[doc = " CapturePatternNode#operator_loc\n\n Represents the location of the `=>` operator.\n\n     foo => bar\n         ^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_capture_pattern_node"][::std::mem::size_of::<pm_capture_pattern_node>() - 32usize];
    ["Alignment of pm_capture_pattern_node"]
        [::std::mem::align_of::<pm_capture_pattern_node>() - 4usize];
    ["Offset of field: pm_capture_pattern_node::base"]
        [::std::mem::offset_of!(pm_capture_pattern_node, base) - 0usize];
    ["Offset of field: pm_capture_pattern_node::value"]
        [::std::mem::offset_of!(pm_capture_pattern_node, value) - 16usize];
    ["Offset of field: pm_capture_pattern_node::target"]
        [::std::mem::offset_of!(pm_capture_pattern_node, target) - 20usize];
    ["Offset of field: pm_capture_pattern_node::operator_loc"]
        [::std::mem::offset_of!(pm_capture_pattern_node, operator_loc) - 24usize];
};
#[doc = " CapturePatternNode\n\n Represents assigning to a local variable in pattern matching.\n\n     foo => [bar => baz]\n            ^^^^^^^^^^^^\n\n Type: ::PM_CAPTURE_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_capture_pattern_node_t = pm_capture_pattern_node;
#[doc = " CaseMatchNode\n\n Represents the use of a case statement for pattern matching.\n\n     case true\n     in false\n     end\n     ^^^^^^^^^\n\n Type: ::PM_CASE_MATCH_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_case_match_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CaseMatchNode#predicate\n\n Represents the predicate of the case match. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     case true; in false; end\n     ^^^^"]
    pub predicate: *mut pm_node,
    #[doc = " CaseMatchNode#conditions\n\n Represents the conditions of the case match.\n\n     case true; in false; end\n                ^^^^^^^^"]
    pub conditions: pm_node_list,
    #[doc = " CaseMatchNode#else_clause\n\n Represents the else clause of the case match.\n\n     case true; in false; else; end\n                          ^^^^"]
    pub else_clause: *mut pm_else_node,
    #[doc = " CaseMatchNode#case_keyword_loc\n\n Represents the location of the `case` keyword.\n\n     case true; in false; end\n     ^^^^"]
    pub case_keyword_loc: pm_location_t,
    #[doc = " CaseMatchNode#end_keyword_loc\n\n Represents the location of the `end` keyword.\n\n     case true; in false; end\n                          ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_case_match_node"][::std::mem::size_of::<pm_case_match_node>() - 52usize];
    ["Alignment of pm_case_match_node"][::std::mem::align_of::<pm_case_match_node>() - 4usize];
    ["Offset of field: pm_case_match_node::base"]
        [::std::mem::offset_of!(pm_case_match_node, base) - 0usize];
    ["Offset of field: pm_case_match_node::predicate"]
        [::std::mem::offset_of!(pm_case_match_node, predicate) - 16usize];
    ["Offset of field: pm_case_match_node::conditions"]
        [::std::mem::offset_of!(pm_case_match_node, conditions) - 20usize];
    ["Offset of field: pm_case_match_node::else_clause"]
        [::std::mem::offset_of!(pm_case_match_node, else_clause) - 32usize];
    ["Offset of field: pm_case_match_node::case_keyword_loc"]
        [::std::mem::offset_of!(pm_case_match_node, case_keyword_loc) - 36usize];
    ["Offset of field: pm_case_match_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_case_match_node, end_keyword_loc) - 44usize];
};
#[doc = " CaseMatchNode\n\n Represents the use of a case statement for pattern matching.\n\n     case true\n     in false\n     end\n     ^^^^^^^^^\n\n Type: ::PM_CASE_MATCH_NODE\n\n @extends pm_node_t"]
pub type pm_case_match_node_t = pm_case_match_node;
#[doc = " CaseNode\n\n Represents the use of a case statement.\n\n     case true\n     when false\n     end\n     ^^^^^^^^^^\n\n Type: ::PM_CASE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_case_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " CaseNode#predicate\n\n Represents the predicate of the case statement. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     case true; when false; end\n     ^^^^"]
    pub predicate: *mut pm_node,
    #[doc = " CaseNode#conditions\n\n Represents the conditions of the case statement.\n\n     case true; when false; end\n                ^^^^^^^^^^"]
    pub conditions: pm_node_list,
    #[doc = " CaseNode#else_clause\n\n Represents the else clause of the case statement.\n\n     case true; when false; else; end\n                            ^^^^"]
    pub else_clause: *mut pm_else_node,
    #[doc = " CaseNode#case_keyword_loc\n\n Represents the location of the `case` keyword.\n\n     case true; when false; end\n     ^^^^"]
    pub case_keyword_loc: pm_location_t,
    #[doc = " CaseNode#end_keyword_loc\n\n Represents the location of the `end` keyword.\n\n     case true; when false; end\n                            ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_case_node"][::std::mem::size_of::<pm_case_node>() - 52usize];
    ["Alignment of pm_case_node"][::std::mem::align_of::<pm_case_node>() - 4usize];
    ["Offset of field: pm_case_node::base"][::std::mem::offset_of!(pm_case_node, base) - 0usize];
    ["Offset of field: pm_case_node::predicate"]
        [::std::mem::offset_of!(pm_case_node, predicate) - 16usize];
    ["Offset of field: pm_case_node::conditions"]
        [::std::mem::offset_of!(pm_case_node, conditions) - 20usize];
    ["Offset of field: pm_case_node::else_clause"]
        [::std::mem::offset_of!(pm_case_node, else_clause) - 32usize];
    ["Offset of field: pm_case_node::case_keyword_loc"]
        [::std::mem::offset_of!(pm_case_node, case_keyword_loc) - 36usize];
    ["Offset of field: pm_case_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_case_node, end_keyword_loc) - 44usize];
};
#[doc = " CaseNode\n\n Represents the use of a case statement.\n\n     case true\n     when false\n     end\n     ^^^^^^^^^^\n\n Type: ::PM_CASE_NODE\n\n @extends pm_node_t"]
pub type pm_case_node_t = pm_case_node;
#[doc = " ClassNode\n\n Represents a class declaration involving the `class` keyword.\n\n     class Foo end\n     ^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " ClassNode#class_keyword_loc"]
    pub class_keyword_loc: pm_location_t,
    #[doc = " ClassNode#constant_path"]
    pub constant_path: *mut pm_node,
    #[doc = " ClassNode#inheritance_operator_loc"]
    pub inheritance_operator_loc: pm_location_t,
    #[doc = " ClassNode#superclass"]
    pub superclass: *mut pm_node,
    #[doc = " ClassNode#body"]
    pub body: *mut pm_node,
    #[doc = " ClassNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
    #[doc = " ClassNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_node"][::std::mem::size_of::<pm_class_node>() - 68usize];
    ["Alignment of pm_class_node"][::std::mem::align_of::<pm_class_node>() - 4usize];
    ["Offset of field: pm_class_node::base"][::std::mem::offset_of!(pm_class_node, base) - 0usize];
    ["Offset of field: pm_class_node::locals"]
        [::std::mem::offset_of!(pm_class_node, locals) - 16usize];
    ["Offset of field: pm_class_node::class_keyword_loc"]
        [::std::mem::offset_of!(pm_class_node, class_keyword_loc) - 28usize];
    ["Offset of field: pm_class_node::constant_path"]
        [::std::mem::offset_of!(pm_class_node, constant_path) - 36usize];
    ["Offset of field: pm_class_node::inheritance_operator_loc"]
        [::std::mem::offset_of!(pm_class_node, inheritance_operator_loc) - 40usize];
    ["Offset of field: pm_class_node::superclass"]
        [::std::mem::offset_of!(pm_class_node, superclass) - 48usize];
    ["Offset of field: pm_class_node::body"][::std::mem::offset_of!(pm_class_node, body) - 52usize];
    ["Offset of field: pm_class_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_class_node, end_keyword_loc) - 56usize];
    ["Offset of field: pm_class_node::name"][::std::mem::offset_of!(pm_class_node, name) - 64usize];
};
#[doc = " ClassNode\n\n Represents a class declaration involving the `class` keyword.\n\n     class Foo end\n     ^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_NODE\n\n @extends pm_node_t"]
pub type pm_class_node_t = pm_class_node;
#[doc = " ClassVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a class variable.\n\n     @@target &&= value\n     ^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableAndWriteNode#name\n\n The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @@target &&= value # name `:@@target`\n     ^^^^^^^^"]
    pub name: pm_constant_id_t,
    #[doc = " ClassVariableAndWriteNode#name_loc\n\n Represents the location of the variable name.\n\n     @@target &&= value\n     ^^^^^^^^"]
    pub name_loc: pm_location_t,
    #[doc = " ClassVariableAndWriteNode#operator_loc\n\n Represents the location of the `&&=` operator.\n\n     @@target &&= value\n              ^^^"]
    pub operator_loc: pm_location_t,
    #[doc = " ClassVariableAndWriteNode#value\n\n Represents the value being assigned. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     @@target &&= value\n                  ^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_and_write_node"]
        [::std::mem::size_of::<pm_class_variable_and_write_node>() - 40usize];
    ["Alignment of pm_class_variable_and_write_node"]
        [::std::mem::align_of::<pm_class_variable_and_write_node>() - 4usize];
    ["Offset of field: pm_class_variable_and_write_node::base"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, base) - 0usize];
    ["Offset of field: pm_class_variable_and_write_node::name"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, name) - 16usize];
    ["Offset of field: pm_class_variable_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, name_loc) - 20usize];
    ["Offset of field: pm_class_variable_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, operator_loc) - 28usize];
    ["Offset of field: pm_class_variable_and_write_node::value"]
        [::std::mem::offset_of!(pm_class_variable_and_write_node, value) - 36usize];
};
#[doc = " ClassVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a class variable.\n\n     @@target &&= value\n     ^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_and_write_node_t = pm_class_variable_and_write_node;
#[doc = " ClassVariableOperatorWriteNode\n\n Represents assigning to a class variable using an operator that isn't `=`.\n\n     @@target += value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ClassVariableOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ClassVariableOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " ClassVariableOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " ClassVariableOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_operator_write_node"]
        [::std::mem::size_of::<pm_class_variable_operator_write_node>() - 44usize];
    ["Alignment of pm_class_variable_operator_write_node"]
        [::std::mem::align_of::<pm_class_variable_operator_write_node>() - 4usize];
    ["Offset of field: pm_class_variable_operator_write_node::base"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, base) - 0usize];
    ["Offset of field: pm_class_variable_operator_write_node::name"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, name) - 16usize];
    ["Offset of field: pm_class_variable_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, name_loc) - 20usize];
    ["Offset of field: pm_class_variable_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_class_variable_operator_write_node,
        binary_operator_loc
    ) - 28usize];
    ["Offset of field: pm_class_variable_operator_write_node::value"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, value) - 36usize];
    ["Offset of field: pm_class_variable_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_class_variable_operator_write_node, binary_operator) - 40usize];
};
#[doc = " ClassVariableOperatorWriteNode\n\n Represents assigning to a class variable using an operator that isn't `=`.\n\n     @@target += value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_operator_write_node_t = pm_class_variable_operator_write_node;
#[doc = " ClassVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a class variable.\n\n     @@target ||= value\n     ^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ClassVariableOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ClassVariableOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ClassVariableOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_or_write_node"]
        [::std::mem::size_of::<pm_class_variable_or_write_node>() - 40usize];
    ["Alignment of pm_class_variable_or_write_node"]
        [::std::mem::align_of::<pm_class_variable_or_write_node>() - 4usize];
    ["Offset of field: pm_class_variable_or_write_node::base"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, base) - 0usize];
    ["Offset of field: pm_class_variable_or_write_node::name"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, name) - 16usize];
    ["Offset of field: pm_class_variable_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, name_loc) - 20usize];
    ["Offset of field: pm_class_variable_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, operator_loc) - 28usize];
    ["Offset of field: pm_class_variable_or_write_node::value"]
        [::std::mem::offset_of!(pm_class_variable_or_write_node, value) - 36usize];
};
#[doc = " ClassVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a class variable.\n\n     @@target ||= value\n     ^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_or_write_node_t = pm_class_variable_or_write_node;
#[doc = " ClassVariableReadNode\n\n Represents referencing a class variable.\n\n     @@foo\n     ^^^^^\n\n Type: ::PM_CLASS_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableReadNode#name\n\n The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @@abc   # name `:@@abc`\n\n     @@_test # name `:@@_test`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_read_node"]
        [::std::mem::size_of::<pm_class_variable_read_node>() - 20usize];
    ["Alignment of pm_class_variable_read_node"]
        [::std::mem::align_of::<pm_class_variable_read_node>() - 4usize];
    ["Offset of field: pm_class_variable_read_node::base"]
        [::std::mem::offset_of!(pm_class_variable_read_node, base) - 0usize];
    ["Offset of field: pm_class_variable_read_node::name"]
        [::std::mem::offset_of!(pm_class_variable_read_node, name) - 16usize];
};
#[doc = " ClassVariableReadNode\n\n Represents referencing a class variable.\n\n     @@foo\n     ^^^^^\n\n Type: ::PM_CLASS_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_read_node_t = pm_class_variable_read_node;
#[doc = " ClassVariableTargetNode\n\n Represents writing to a class variable in a context that doesn't have an explicit value.\n\n     @@foo, @@bar = baz\n     ^^^^^  ^^^^^\n\n Type: ::PM_CLASS_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableTargetNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_target_node"]
        [::std::mem::size_of::<pm_class_variable_target_node>() - 20usize];
    ["Alignment of pm_class_variable_target_node"]
        [::std::mem::align_of::<pm_class_variable_target_node>() - 4usize];
    ["Offset of field: pm_class_variable_target_node::base"]
        [::std::mem::offset_of!(pm_class_variable_target_node, base) - 0usize];
    ["Offset of field: pm_class_variable_target_node::name"]
        [::std::mem::offset_of!(pm_class_variable_target_node, name) - 16usize];
};
#[doc = " ClassVariableTargetNode\n\n Represents writing to a class variable in a context that doesn't have an explicit value.\n\n     @@foo, @@bar = baz\n     ^^^^^  ^^^^^\n\n Type: ::PM_CLASS_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_target_node_t = pm_class_variable_target_node;
#[doc = " ClassVariableWriteNode\n\n Represents writing to a class variable.\n\n     @@foo = 1\n     ^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_class_variable_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ClassVariableWriteNode#name\n\n The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @@abc = 123     # name `@@abc`\n\n     @@_test = :test # name `@@_test`"]
    pub name: pm_constant_id_t,
    #[doc = " ClassVariableWriteNode#name_loc\n\n The location of the variable name.\n\n     @@foo = :bar\n     ^^^^^"]
    pub name_loc: pm_location_t,
    #[doc = " ClassVariableWriteNode#value\n\n The value to write to the class variable. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     @@foo = :bar\n             ^^^^\n\n     @@_xyz = 123\n              ^^^"]
    pub value: *mut pm_node,
    #[doc = " ClassVariableWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     @@foo = :bar\n           ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_class_variable_write_node"]
        [::std::mem::size_of::<pm_class_variable_write_node>() - 40usize];
    ["Alignment of pm_class_variable_write_node"]
        [::std::mem::align_of::<pm_class_variable_write_node>() - 4usize];
    ["Offset of field: pm_class_variable_write_node::base"]
        [::std::mem::offset_of!(pm_class_variable_write_node, base) - 0usize];
    ["Offset of field: pm_class_variable_write_node::name"]
        [::std::mem::offset_of!(pm_class_variable_write_node, name) - 16usize];
    ["Offset of field: pm_class_variable_write_node::name_loc"]
        [::std::mem::offset_of!(pm_class_variable_write_node, name_loc) - 20usize];
    ["Offset of field: pm_class_variable_write_node::value"]
        [::std::mem::offset_of!(pm_class_variable_write_node, value) - 28usize];
    ["Offset of field: pm_class_variable_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_class_variable_write_node, operator_loc) - 32usize];
};
#[doc = " ClassVariableWriteNode\n\n Represents writing to a class variable.\n\n     @@foo = 1\n     ^^^^^^^^^\n\n Type: ::PM_CLASS_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_class_variable_write_node_t = pm_class_variable_write_node;
#[doc = " ConstantAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a constant.\n\n     Target &&= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantAndWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantAndWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ConstantAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_and_write_node"]
        [::std::mem::size_of::<pm_constant_and_write_node>() - 40usize];
    ["Alignment of pm_constant_and_write_node"]
        [::std::mem::align_of::<pm_constant_and_write_node>() - 4usize];
    ["Offset of field: pm_constant_and_write_node::base"]
        [::std::mem::offset_of!(pm_constant_and_write_node, base) - 0usize];
    ["Offset of field: pm_constant_and_write_node::name"]
        [::std::mem::offset_of!(pm_constant_and_write_node, name) - 16usize];
    ["Offset of field: pm_constant_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_and_write_node, name_loc) - 20usize];
    ["Offset of field: pm_constant_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_and_write_node, operator_loc) - 28usize];
    ["Offset of field: pm_constant_and_write_node::value"]
        [::std::mem::offset_of!(pm_constant_and_write_node, value) - 36usize];
};
#[doc = " ConstantAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a constant.\n\n     Target &&= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_and_write_node_t = pm_constant_and_write_node;
#[doc = " ConstantOperatorWriteNode\n\n Represents assigning to a constant using an operator that isn't `=`.\n\n     Target += value\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ConstantOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " ConstantOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " ConstantOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_operator_write_node"]
        [::std::mem::size_of::<pm_constant_operator_write_node>() - 44usize];
    ["Alignment of pm_constant_operator_write_node"]
        [::std::mem::align_of::<pm_constant_operator_write_node>() - 4usize];
    ["Offset of field: pm_constant_operator_write_node::base"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, base) - 0usize];
    ["Offset of field: pm_constant_operator_write_node::name"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, name) - 16usize];
    ["Offset of field: pm_constant_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, name_loc) - 20usize];
    ["Offset of field: pm_constant_operator_write_node::binary_operator_loc"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, binary_operator_loc) - 28usize];
    ["Offset of field: pm_constant_operator_write_node::value"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, value) - 36usize];
    ["Offset of field: pm_constant_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_constant_operator_write_node, binary_operator) - 40usize];
};
#[doc = " ConstantOperatorWriteNode\n\n Represents assigning to a constant using an operator that isn't `=`.\n\n     Target += value\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_operator_write_node_t = pm_constant_operator_write_node;
#[doc = " ConstantOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a constant.\n\n     Target ||= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " ConstantOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_or_write_node"]
        [::std::mem::size_of::<pm_constant_or_write_node>() - 40usize];
    ["Alignment of pm_constant_or_write_node"]
        [::std::mem::align_of::<pm_constant_or_write_node>() - 4usize];
    ["Offset of field: pm_constant_or_write_node::base"]
        [::std::mem::offset_of!(pm_constant_or_write_node, base) - 0usize];
    ["Offset of field: pm_constant_or_write_node::name"]
        [::std::mem::offset_of!(pm_constant_or_write_node, name) - 16usize];
    ["Offset of field: pm_constant_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_or_write_node, name_loc) - 20usize];
    ["Offset of field: pm_constant_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_or_write_node, operator_loc) - 28usize];
    ["Offset of field: pm_constant_or_write_node::value"]
        [::std::mem::offset_of!(pm_constant_or_write_node, value) - 36usize];
};
#[doc = " ConstantOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a constant.\n\n     Target ||= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_or_write_node_t = pm_constant_or_write_node;
#[doc = " ConstantPathAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a constant path.\n\n     Parent::Child &&= value\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathAndWriteNode#target"]
    pub target: *mut pm_constant_path_node,
    #[doc = " ConstantPathAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantPathAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_and_write_node"]
        [::std::mem::size_of::<pm_constant_path_and_write_node>() - 32usize];
    ["Alignment of pm_constant_path_and_write_node"]
        [::std::mem::align_of::<pm_constant_path_and_write_node>() - 4usize];
    ["Offset of field: pm_constant_path_and_write_node::base"]
        [::std::mem::offset_of!(pm_constant_path_and_write_node, base) - 0usize];
    ["Offset of field: pm_constant_path_and_write_node::target"]
        [::std::mem::offset_of!(pm_constant_path_and_write_node, target) - 16usize];
    ["Offset of field: pm_constant_path_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_path_and_write_node, operator_loc) - 20usize];
    ["Offset of field: pm_constant_path_and_write_node::value"]
        [::std::mem::offset_of!(pm_constant_path_and_write_node, value) - 28usize];
};
#[doc = " ConstantPathAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a constant path.\n\n     Parent::Child &&= value\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_and_write_node_t = pm_constant_path_and_write_node;
#[doc = " ConstantPathNode\n\n Represents accessing a constant through a path of `::` operators.\n\n     Foo::Bar\n     ^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathNode#parent\n\n The left-hand node of the path, if present. It can be `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression). It will be `nil` when the constant lookup is at the root of the module tree.\n\n     Foo::Bar\n     ^^^\n\n     self::Test\n     ^^^^\n\n     a.b::C\n     ^^^"]
    pub parent: *mut pm_node,
    #[doc = " ConstantPathNode#name\n\n The name of the constant being accessed. This could be `nil` in the event of a syntax error."]
    pub name: pm_constant_id_t,
    #[doc = " ConstantPathNode#delimiter_loc\n\n The location of the `::` delimiter.\n\n     ::Foo\n     ^^\n\n     One::Two\n        ^^"]
    pub delimiter_loc: pm_location_t,
    #[doc = " ConstantPathNode#name_loc\n\n The location of the name of the constant.\n\n     ::Foo\n       ^^^\n\n     One::Two\n          ^^^"]
    pub name_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_node"][::std::mem::size_of::<pm_constant_path_node>() - 40usize];
    ["Alignment of pm_constant_path_node"]
        [::std::mem::align_of::<pm_constant_path_node>() - 4usize];
    ["Offset of field: pm_constant_path_node::base"]
        [::std::mem::offset_of!(pm_constant_path_node, base) - 0usize];
    ["Offset of field: pm_constant_path_node::parent"]
        [::std::mem::offset_of!(pm_constant_path_node, parent) - 16usize];
    ["Offset of field: pm_constant_path_node::name"]
        [::std::mem::offset_of!(pm_constant_path_node, name) - 20usize];
    ["Offset of field: pm_constant_path_node::delimiter_loc"]
        [::std::mem::offset_of!(pm_constant_path_node, delimiter_loc) - 24usize];
    ["Offset of field: pm_constant_path_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_path_node, name_loc) - 32usize];
};
#[doc = " ConstantPathNode\n\n Represents accessing a constant through a path of `::` operators.\n\n     Foo::Bar\n     ^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_node_t = pm_constant_path_node;
#[doc = " ConstantPathOperatorWriteNode\n\n Represents assigning to a constant path using an operator that isn't `=`.\n\n     Parent::Child += value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathOperatorWriteNode#target"]
    pub target: *mut pm_constant_path_node,
    #[doc = " ConstantPathOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " ConstantPathOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " ConstantPathOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_operator_write_node"]
        [::std::mem::size_of::<pm_constant_path_operator_write_node>() - 36usize];
    ["Alignment of pm_constant_path_operator_write_node"]
        [::std::mem::align_of::<pm_constant_path_operator_write_node>() - 4usize];
    ["Offset of field: pm_constant_path_operator_write_node::base"]
        [::std::mem::offset_of!(pm_constant_path_operator_write_node, base) - 0usize];
    ["Offset of field: pm_constant_path_operator_write_node::target"]
        [::std::mem::offset_of!(pm_constant_path_operator_write_node, target) - 16usize];
    ["Offset of field: pm_constant_path_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_constant_path_operator_write_node,
        binary_operator_loc
    ) - 20usize];
    ["Offset of field: pm_constant_path_operator_write_node::value"]
        [::std::mem::offset_of!(pm_constant_path_operator_write_node, value) - 28usize];
    ["Offset of field: pm_constant_path_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_constant_path_operator_write_node, binary_operator) - 32usize];
};
#[doc = " ConstantPathOperatorWriteNode\n\n Represents assigning to a constant path using an operator that isn't `=`.\n\n     Parent::Child += value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_operator_write_node_t = pm_constant_path_operator_write_node;
#[doc = " ConstantPathOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a constant path.\n\n     Parent::Child ||= value\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathOrWriteNode#target"]
    pub target: *mut pm_constant_path_node,
    #[doc = " ConstantPathOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantPathOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_or_write_node"]
        [::std::mem::size_of::<pm_constant_path_or_write_node>() - 32usize];
    ["Alignment of pm_constant_path_or_write_node"]
        [::std::mem::align_of::<pm_constant_path_or_write_node>() - 4usize];
    ["Offset of field: pm_constant_path_or_write_node::base"]
        [::std::mem::offset_of!(pm_constant_path_or_write_node, base) - 0usize];
    ["Offset of field: pm_constant_path_or_write_node::target"]
        [::std::mem::offset_of!(pm_constant_path_or_write_node, target) - 16usize];
    ["Offset of field: pm_constant_path_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_path_or_write_node, operator_loc) - 20usize];
    ["Offset of field: pm_constant_path_or_write_node::value"]
        [::std::mem::offset_of!(pm_constant_path_or_write_node, value) - 28usize];
};
#[doc = " ConstantPathOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a constant path.\n\n     Parent::Child ||= value\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_or_write_node_t = pm_constant_path_or_write_node;
#[doc = " ConstantPathTargetNode\n\n Represents writing to a constant path in a context that doesn't have an explicit value.\n\n     Foo::Foo, Bar::Bar = baz\n     ^^^^^^^^  ^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathTargetNode#parent"]
    pub parent: *mut pm_node,
    #[doc = " ConstantPathTargetNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantPathTargetNode#delimiter_loc"]
    pub delimiter_loc: pm_location_t,
    #[doc = " ConstantPathTargetNode#name_loc"]
    pub name_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_target_node"]
        [::std::mem::size_of::<pm_constant_path_target_node>() - 40usize];
    ["Alignment of pm_constant_path_target_node"]
        [::std::mem::align_of::<pm_constant_path_target_node>() - 4usize];
    ["Offset of field: pm_constant_path_target_node::base"]
        [::std::mem::offset_of!(pm_constant_path_target_node, base) - 0usize];
    ["Offset of field: pm_constant_path_target_node::parent"]
        [::std::mem::offset_of!(pm_constant_path_target_node, parent) - 16usize];
    ["Offset of field: pm_constant_path_target_node::name"]
        [::std::mem::offset_of!(pm_constant_path_target_node, name) - 20usize];
    ["Offset of field: pm_constant_path_target_node::delimiter_loc"]
        [::std::mem::offset_of!(pm_constant_path_target_node, delimiter_loc) - 24usize];
    ["Offset of field: pm_constant_path_target_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_path_target_node, name_loc) - 32usize];
};
#[doc = " ConstantPathTargetNode\n\n Represents writing to a constant path in a context that doesn't have an explicit value.\n\n     Foo::Foo, Bar::Bar = baz\n     ^^^^^^^^  ^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_target_node_t = pm_constant_path_target_node;
#[doc = " ConstantPathWriteNode\n\n Represents writing to a constant path.\n\n     ::Foo = 1\n     ^^^^^^^^^\n\n     Foo::Bar = 1\n     ^^^^^^^^^^^^\n\n     ::Foo::Bar = 1\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_path_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantPathWriteNode#target\n\n A node representing the constant path being written to.\n\n     Foo::Bar = 1\n     ^^^^^^^^\n\n     ::Foo = :abc\n     ^^^^^"]
    pub target: *mut pm_constant_path_node,
    #[doc = " ConstantPathWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     ::ABC = 123\n           ^"]
    pub operator_loc: pm_location_t,
    #[doc = " ConstantPathWriteNode#value\n\n The value to write to the constant path. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     FOO::BAR = :abc\n                ^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_path_write_node"]
        [::std::mem::size_of::<pm_constant_path_write_node>() - 32usize];
    ["Alignment of pm_constant_path_write_node"]
        [::std::mem::align_of::<pm_constant_path_write_node>() - 4usize];
    ["Offset of field: pm_constant_path_write_node::base"]
        [::std::mem::offset_of!(pm_constant_path_write_node, base) - 0usize];
    ["Offset of field: pm_constant_path_write_node::target"]
        [::std::mem::offset_of!(pm_constant_path_write_node, target) - 16usize];
    ["Offset of field: pm_constant_path_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_path_write_node, operator_loc) - 20usize];
    ["Offset of field: pm_constant_path_write_node::value"]
        [::std::mem::offset_of!(pm_constant_path_write_node, value) - 28usize];
};
#[doc = " ConstantPathWriteNode\n\n Represents writing to a constant path.\n\n     ::Foo = 1\n     ^^^^^^^^^\n\n     Foo::Bar = 1\n     ^^^^^^^^^^^^\n\n     ::Foo::Bar = 1\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_CONSTANT_PATH_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_path_write_node_t = pm_constant_path_write_node;
#[doc = " ConstantReadNode\n\n Represents referencing a constant.\n\n     Foo\n     ^^^\n\n Type: ::PM_CONSTANT_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantReadNode#name\n\n The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).\n\n     X              # name `:X`\n\n     SOME_CONSTANT  # name `:SOME_CONSTANT`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_read_node"][::std::mem::size_of::<pm_constant_read_node>() - 20usize];
    ["Alignment of pm_constant_read_node"]
        [::std::mem::align_of::<pm_constant_read_node>() - 4usize];
    ["Offset of field: pm_constant_read_node::base"]
        [::std::mem::offset_of!(pm_constant_read_node, base) - 0usize];
    ["Offset of field: pm_constant_read_node::name"]
        [::std::mem::offset_of!(pm_constant_read_node, name) - 16usize];
};
#[doc = " ConstantReadNode\n\n Represents referencing a constant.\n\n     Foo\n     ^^^\n\n Type: ::PM_CONSTANT_READ_NODE\n\n @extends pm_node_t"]
pub type pm_constant_read_node_t = pm_constant_read_node;
#[doc = " ConstantTargetNode\n\n Represents writing to a constant in a context that doesn't have an explicit value.\n\n     Foo, Bar = baz\n     ^^^  ^^^\n\n Type: ::PM_CONSTANT_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantTargetNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_target_node"][::std::mem::size_of::<pm_constant_target_node>() - 20usize];
    ["Alignment of pm_constant_target_node"]
        [::std::mem::align_of::<pm_constant_target_node>() - 4usize];
    ["Offset of field: pm_constant_target_node::base"]
        [::std::mem::offset_of!(pm_constant_target_node, base) - 0usize];
    ["Offset of field: pm_constant_target_node::name"]
        [::std::mem::offset_of!(pm_constant_target_node, name) - 16usize];
};
#[doc = " ConstantTargetNode\n\n Represents writing to a constant in a context that doesn't have an explicit value.\n\n     Foo, Bar = baz\n     ^^^  ^^^\n\n Type: ::PM_CONSTANT_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_constant_target_node_t = pm_constant_target_node;
#[doc = " ConstantWriteNode\n\n Represents writing to a constant.\n\n     Foo = 1\n     ^^^^^^^\n\n Type: ::PM_CONSTANT_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_constant_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ConstantWriteNode#name\n\n The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).\n\n     Foo = :bar # name `:Foo`\n\n     XYZ = 1    # name `:XYZ`"]
    pub name: pm_constant_id_t,
    #[doc = " ConstantWriteNode#name_loc\n\n The location of the constant name.\n\n     FOO = 1\n     ^^^"]
    pub name_loc: pm_location_t,
    #[doc = " ConstantWriteNode#value\n\n The value to write to the constant. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     FOO = :bar\n           ^^^^\n\n     MyClass = Class.new\n               ^^^^^^^^^"]
    pub value: *mut pm_node,
    #[doc = " ConstantWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     FOO = :bar\n         ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_constant_write_node"][::std::mem::size_of::<pm_constant_write_node>() - 40usize];
    ["Alignment of pm_constant_write_node"]
        [::std::mem::align_of::<pm_constant_write_node>() - 4usize];
    ["Offset of field: pm_constant_write_node::base"]
        [::std::mem::offset_of!(pm_constant_write_node, base) - 0usize];
    ["Offset of field: pm_constant_write_node::name"]
        [::std::mem::offset_of!(pm_constant_write_node, name) - 16usize];
    ["Offset of field: pm_constant_write_node::name_loc"]
        [::std::mem::offset_of!(pm_constant_write_node, name_loc) - 20usize];
    ["Offset of field: pm_constant_write_node::value"]
        [::std::mem::offset_of!(pm_constant_write_node, value) - 28usize];
    ["Offset of field: pm_constant_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_constant_write_node, operator_loc) - 32usize];
};
#[doc = " ConstantWriteNode\n\n Represents writing to a constant.\n\n     Foo = 1\n     ^^^^^^^\n\n Type: ::PM_CONSTANT_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_constant_write_node_t = pm_constant_write_node;
#[doc = " DefNode\n\n Represents a method definition.\n\n     def method\n     end\n     ^^^^^^^^^^\n\n Type: ::PM_DEF_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_def_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " DefNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " DefNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " DefNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " DefNode#parameters"]
    pub parameters: *mut pm_parameters_node,
    #[doc = " DefNode#body"]
    pub body: *mut pm_node,
    #[doc = " DefNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " DefNode#def_keyword_loc"]
    pub def_keyword_loc: pm_location_t,
    #[doc = " DefNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " DefNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " DefNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
    #[doc = " DefNode#equal_loc"]
    pub equal_loc: pm_location_t,
    #[doc = " DefNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_def_node"][::std::mem::size_of::<pm_def_node>() - 100usize];
    ["Alignment of pm_def_node"][::std::mem::align_of::<pm_def_node>() - 4usize];
    ["Offset of field: pm_def_node::base"][::std::mem::offset_of!(pm_def_node, base) - 0usize];
    ["Offset of field: pm_def_node::name"][::std::mem::offset_of!(pm_def_node, name) - 16usize];
    ["Offset of field: pm_def_node::name_loc"]
        [::std::mem::offset_of!(pm_def_node, name_loc) - 20usize];
    ["Offset of field: pm_def_node::receiver"]
        [::std::mem::offset_of!(pm_def_node, receiver) - 28usize];
    ["Offset of field: pm_def_node::parameters"]
        [::std::mem::offset_of!(pm_def_node, parameters) - 32usize];
    ["Offset of field: pm_def_node::body"][::std::mem::offset_of!(pm_def_node, body) - 36usize];
    ["Offset of field: pm_def_node::locals"][::std::mem::offset_of!(pm_def_node, locals) - 40usize];
    ["Offset of field: pm_def_node::def_keyword_loc"]
        [::std::mem::offset_of!(pm_def_node, def_keyword_loc) - 52usize];
    ["Offset of field: pm_def_node::operator_loc"]
        [::std::mem::offset_of!(pm_def_node, operator_loc) - 60usize];
    ["Offset of field: pm_def_node::lparen_loc"]
        [::std::mem::offset_of!(pm_def_node, lparen_loc) - 68usize];
    ["Offset of field: pm_def_node::rparen_loc"]
        [::std::mem::offset_of!(pm_def_node, rparen_loc) - 76usize];
    ["Offset of field: pm_def_node::equal_loc"]
        [::std::mem::offset_of!(pm_def_node, equal_loc) - 84usize];
    ["Offset of field: pm_def_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_def_node, end_keyword_loc) - 92usize];
};
#[doc = " DefNode\n\n Represents a method definition.\n\n     def method\n     end\n     ^^^^^^^^^^\n\n Type: ::PM_DEF_NODE\n\n @extends pm_node_t"]
pub type pm_def_node_t = pm_def_node;
#[doc = " DefinedNode\n\n Represents the use of the `defined?` keyword.\n\n     defined?(a)\n     ^^^^^^^^^^^\n\n Type: ::PM_DEFINED_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_defined_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " DefinedNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " DefinedNode#value"]
    pub value: *mut pm_node,
    #[doc = " DefinedNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
    #[doc = " DefinedNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_defined_node"][::std::mem::size_of::<pm_defined_node>() - 44usize];
    ["Alignment of pm_defined_node"][::std::mem::align_of::<pm_defined_node>() - 4usize];
    ["Offset of field: pm_defined_node::base"]
        [::std::mem::offset_of!(pm_defined_node, base) - 0usize];
    ["Offset of field: pm_defined_node::lparen_loc"]
        [::std::mem::offset_of!(pm_defined_node, lparen_loc) - 16usize];
    ["Offset of field: pm_defined_node::value"]
        [::std::mem::offset_of!(pm_defined_node, value) - 24usize];
    ["Offset of field: pm_defined_node::rparen_loc"]
        [::std::mem::offset_of!(pm_defined_node, rparen_loc) - 28usize];
    ["Offset of field: pm_defined_node::keyword_loc"]
        [::std::mem::offset_of!(pm_defined_node, keyword_loc) - 36usize];
};
#[doc = " DefinedNode\n\n Represents the use of the `defined?` keyword.\n\n     defined?(a)\n     ^^^^^^^^^^^\n\n Type: ::PM_DEFINED_NODE\n\n @extends pm_node_t"]
pub type pm_defined_node_t = pm_defined_node;
#[doc = " ElseNode\n\n Represents an `else` clause in a `case`, `if`, or `unless` statement.\n\n     if a then b else c end\n                 ^^^^^^^^^^\n\n Type: ::PM_ELSE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_else_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ElseNode#else_keyword_loc"]
    pub else_keyword_loc: pm_location_t,
    #[doc = " ElseNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " ElseNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_else_node"][::std::mem::size_of::<pm_else_node>() - 36usize];
    ["Alignment of pm_else_node"][::std::mem::align_of::<pm_else_node>() - 4usize];
    ["Offset of field: pm_else_node::base"][::std::mem::offset_of!(pm_else_node, base) - 0usize];
    ["Offset of field: pm_else_node::else_keyword_loc"]
        [::std::mem::offset_of!(pm_else_node, else_keyword_loc) - 16usize];
    ["Offset of field: pm_else_node::statements"]
        [::std::mem::offset_of!(pm_else_node, statements) - 24usize];
    ["Offset of field: pm_else_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_else_node, end_keyword_loc) - 28usize];
};
#[doc = " ElseNode\n\n Represents an `else` clause in a `case`, `if`, or `unless` statement.\n\n     if a then b else c end\n                 ^^^^^^^^^^\n\n Type: ::PM_ELSE_NODE\n\n @extends pm_node_t"]
pub type pm_else_node_t = pm_else_node;
#[doc = " EmbeddedStatementsNode\n\n Represents an interpolated set of statements.\n\n     \"foo #{bar}\"\n          ^^^^^^\n\n Type: ::PM_EMBEDDED_STATEMENTS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_embedded_statements_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " EmbeddedStatementsNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " EmbeddedStatementsNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " EmbeddedStatementsNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_embedded_statements_node"]
        [::std::mem::size_of::<pm_embedded_statements_node>() - 36usize];
    ["Alignment of pm_embedded_statements_node"]
        [::std::mem::align_of::<pm_embedded_statements_node>() - 4usize];
    ["Offset of field: pm_embedded_statements_node::base"]
        [::std::mem::offset_of!(pm_embedded_statements_node, base) - 0usize];
    ["Offset of field: pm_embedded_statements_node::opening_loc"]
        [::std::mem::offset_of!(pm_embedded_statements_node, opening_loc) - 16usize];
    ["Offset of field: pm_embedded_statements_node::statements"]
        [::std::mem::offset_of!(pm_embedded_statements_node, statements) - 24usize];
    ["Offset of field: pm_embedded_statements_node::closing_loc"]
        [::std::mem::offset_of!(pm_embedded_statements_node, closing_loc) - 28usize];
};
#[doc = " EmbeddedStatementsNode\n\n Represents an interpolated set of statements.\n\n     \"foo #{bar}\"\n          ^^^^^^\n\n Type: ::PM_EMBEDDED_STATEMENTS_NODE\n\n @extends pm_node_t"]
pub type pm_embedded_statements_node_t = pm_embedded_statements_node;
#[doc = " EmbeddedVariableNode\n\n Represents an interpolated variable.\n\n     \"foo #@bar\"\n          ^^^^^\n\n Type: ::PM_EMBEDDED_VARIABLE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_embedded_variable_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " EmbeddedVariableNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " EmbeddedVariableNode#variable"]
    pub variable: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_embedded_variable_node"]
        [::std::mem::size_of::<pm_embedded_variable_node>() - 28usize];
    ["Alignment of pm_embedded_variable_node"]
        [::std::mem::align_of::<pm_embedded_variable_node>() - 4usize];
    ["Offset of field: pm_embedded_variable_node::base"]
        [::std::mem::offset_of!(pm_embedded_variable_node, base) - 0usize];
    ["Offset of field: pm_embedded_variable_node::operator_loc"]
        [::std::mem::offset_of!(pm_embedded_variable_node, operator_loc) - 16usize];
    ["Offset of field: pm_embedded_variable_node::variable"]
        [::std::mem::offset_of!(pm_embedded_variable_node, variable) - 24usize];
};
#[doc = " EmbeddedVariableNode\n\n Represents an interpolated variable.\n\n     \"foo #@bar\"\n          ^^^^^\n\n Type: ::PM_EMBEDDED_VARIABLE_NODE\n\n @extends pm_node_t"]
pub type pm_embedded_variable_node_t = pm_embedded_variable_node;
#[doc = " EnsureNode\n\n Represents an `ensure` clause in a `begin` statement.\n\n     begin\n       foo\n     ensure\n     ^^^^^^\n       bar\n     end\n\n Type: ::PM_ENSURE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_ensure_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " EnsureNode#ensure_keyword_loc"]
    pub ensure_keyword_loc: pm_location_t,
    #[doc = " EnsureNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " EnsureNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_ensure_node"][::std::mem::size_of::<pm_ensure_node>() - 36usize];
    ["Alignment of pm_ensure_node"][::std::mem::align_of::<pm_ensure_node>() - 4usize];
    ["Offset of field: pm_ensure_node::base"]
        [::std::mem::offset_of!(pm_ensure_node, base) - 0usize];
    ["Offset of field: pm_ensure_node::ensure_keyword_loc"]
        [::std::mem::offset_of!(pm_ensure_node, ensure_keyword_loc) - 16usize];
    ["Offset of field: pm_ensure_node::statements"]
        [::std::mem::offset_of!(pm_ensure_node, statements) - 24usize];
    ["Offset of field: pm_ensure_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_ensure_node, end_keyword_loc) - 28usize];
};
#[doc = " EnsureNode\n\n Represents an `ensure` clause in a `begin` statement.\n\n     begin\n       foo\n     ensure\n     ^^^^^^\n       bar\n     end\n\n Type: ::PM_ENSURE_NODE\n\n @extends pm_node_t"]
pub type pm_ensure_node_t = pm_ensure_node;
#[doc = " FalseNode\n\n Represents the use of the literal `false` keyword.\n\n     false\n     ^^^^^\n\n Type: ::PM_FALSE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_false_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_false_node"][::std::mem::size_of::<pm_false_node>() - 16usize];
    ["Alignment of pm_false_node"][::std::mem::align_of::<pm_false_node>() - 4usize];
    ["Offset of field: pm_false_node::base"][::std::mem::offset_of!(pm_false_node, base) - 0usize];
};
#[doc = " FalseNode\n\n Represents the use of the literal `false` keyword.\n\n     false\n     ^^^^^\n\n Type: ::PM_FALSE_NODE\n\n @extends pm_node_t"]
pub type pm_false_node_t = pm_false_node;
#[doc = " FindPatternNode\n\n Represents a find pattern in pattern matching.\n\n     foo in *bar, baz, *qux\n            ^^^^^^^^^^^^^^^\n\n     foo in [*bar, baz, *qux]\n            ^^^^^^^^^^^^^^^^^\n\n     foo in Foo(*bar, baz, *qux)\n            ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_FIND_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_find_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " FindPatternNode#constant"]
    pub constant: *mut pm_node,
    #[doc = " FindPatternNode#left"]
    pub left: *mut pm_splat_node,
    #[doc = " FindPatternNode#requireds"]
    pub requireds: pm_node_list,
    #[doc = " FindPatternNode#right"]
    pub right: *mut pm_node,
    #[doc = " FindPatternNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " FindPatternNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_find_pattern_node"][::std::mem::size_of::<pm_find_pattern_node>() - 56usize];
    ["Alignment of pm_find_pattern_node"][::std::mem::align_of::<pm_find_pattern_node>() - 4usize];
    ["Offset of field: pm_find_pattern_node::base"]
        [::std::mem::offset_of!(pm_find_pattern_node, base) - 0usize];
    ["Offset of field: pm_find_pattern_node::constant"]
        [::std::mem::offset_of!(pm_find_pattern_node, constant) - 16usize];
    ["Offset of field: pm_find_pattern_node::left"]
        [::std::mem::offset_of!(pm_find_pattern_node, left) - 20usize];
    ["Offset of field: pm_find_pattern_node::requireds"]
        [::std::mem::offset_of!(pm_find_pattern_node, requireds) - 24usize];
    ["Offset of field: pm_find_pattern_node::right"]
        [::std::mem::offset_of!(pm_find_pattern_node, right) - 36usize];
    ["Offset of field: pm_find_pattern_node::opening_loc"]
        [::std::mem::offset_of!(pm_find_pattern_node, opening_loc) - 40usize];
    ["Offset of field: pm_find_pattern_node::closing_loc"]
        [::std::mem::offset_of!(pm_find_pattern_node, closing_loc) - 48usize];
};
#[doc = " FindPatternNode\n\n Represents a find pattern in pattern matching.\n\n     foo in *bar, baz, *qux\n            ^^^^^^^^^^^^^^^\n\n     foo in [*bar, baz, *qux]\n            ^^^^^^^^^^^^^^^^^\n\n     foo in Foo(*bar, baz, *qux)\n            ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_FIND_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_find_pattern_node_t = pm_find_pattern_node;
#[doc = " FlipFlopNode\n\n Represents the use of the `..` or `...` operators to create flip flops.\n\n     baz if foo .. bar\n            ^^^^^^^^^^\n\n Type: ::PM_FLIP_FLOP_NODE\n\n Flags (#pm_range_flags):\n * ::PM_RANGE_FLAGS_EXCLUDE_END\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_flip_flop_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " FlipFlopNode#left"]
    pub left: *mut pm_node,
    #[doc = " FlipFlopNode#right"]
    pub right: *mut pm_node,
    #[doc = " FlipFlopNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_flip_flop_node"][::std::mem::size_of::<pm_flip_flop_node>() - 32usize];
    ["Alignment of pm_flip_flop_node"][::std::mem::align_of::<pm_flip_flop_node>() - 4usize];
    ["Offset of field: pm_flip_flop_node::base"]
        [::std::mem::offset_of!(pm_flip_flop_node, base) - 0usize];
    ["Offset of field: pm_flip_flop_node::left"]
        [::std::mem::offset_of!(pm_flip_flop_node, left) - 16usize];
    ["Offset of field: pm_flip_flop_node::right"]
        [::std::mem::offset_of!(pm_flip_flop_node, right) - 20usize];
    ["Offset of field: pm_flip_flop_node::operator_loc"]
        [::std::mem::offset_of!(pm_flip_flop_node, operator_loc) - 24usize];
};
#[doc = " FlipFlopNode\n\n Represents the use of the `..` or `...` operators to create flip flops.\n\n     baz if foo .. bar\n            ^^^^^^^^^^\n\n Type: ::PM_FLIP_FLOP_NODE\n\n Flags (#pm_range_flags):\n * ::PM_RANGE_FLAGS_EXCLUDE_END\n\n @extends pm_node_t"]
pub type pm_flip_flop_node_t = pm_flip_flop_node;
#[doc = " FloatNode\n\n Represents a floating point number literal.\n\n     1.0\n     ^^^\n\n Type: ::PM_FLOAT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_float_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " FloatNode#value\n\n The value of the floating point number as a Float."]
    pub value: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_float_node"][::std::mem::size_of::<pm_float_node>() - 24usize];
    ["Alignment of pm_float_node"][::std::mem::align_of::<pm_float_node>() - 8usize];
    ["Offset of field: pm_float_node::base"][::std::mem::offset_of!(pm_float_node, base) - 0usize];
    ["Offset of field: pm_float_node::value"]
        [::std::mem::offset_of!(pm_float_node, value) - 16usize];
};
#[doc = " FloatNode\n\n Represents a floating point number literal.\n\n     1.0\n     ^^^\n\n Type: ::PM_FLOAT_NODE\n\n @extends pm_node_t"]
pub type pm_float_node_t = pm_float_node;
#[doc = " ForNode\n\n Represents the use of the `for` keyword.\n\n     for i in a end\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_FOR_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_for_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ForNode#index\n\n The index expression for `for` loops.\n\n     for i in a end\n         ^"]
    pub index: *mut pm_node,
    #[doc = " ForNode#collection\n\n The collection to iterate over.\n\n     for i in a end\n              ^"]
    pub collection: *mut pm_node,
    #[doc = " ForNode#statements\n\n Represents the body of statements to execute for each iteration of the loop.\n\n     for i in a\n       foo(i)\n       ^^^^^^\n     end"]
    pub statements: *mut pm_statements_node,
    #[doc = " ForNode#for_keyword_loc\n\n The location of the `for` keyword.\n\n     for i in a end\n     ^^^"]
    pub for_keyword_loc: pm_location_t,
    #[doc = " ForNode#in_keyword_loc\n\n The location of the `in` keyword.\n\n     for i in a end\n           ^^"]
    pub in_keyword_loc: pm_location_t,
    #[doc = " ForNode#do_keyword_loc\n\n The location of the `do` keyword, if present.\n\n     for i in a do end\n                ^^"]
    pub do_keyword_loc: pm_location_t,
    #[doc = " ForNode#end_keyword_loc\n\n The location of the `end` keyword.\n\n     for i in a end\n                ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_for_node"][::std::mem::size_of::<pm_for_node>() - 60usize];
    ["Alignment of pm_for_node"][::std::mem::align_of::<pm_for_node>() - 4usize];
    ["Offset of field: pm_for_node::base"][::std::mem::offset_of!(pm_for_node, base) - 0usize];
    ["Offset of field: pm_for_node::index"][::std::mem::offset_of!(pm_for_node, index) - 16usize];
    ["Offset of field: pm_for_node::collection"]
        [::std::mem::offset_of!(pm_for_node, collection) - 20usize];
    ["Offset of field: pm_for_node::statements"]
        [::std::mem::offset_of!(pm_for_node, statements) - 24usize];
    ["Offset of field: pm_for_node::for_keyword_loc"]
        [::std::mem::offset_of!(pm_for_node, for_keyword_loc) - 28usize];
    ["Offset of field: pm_for_node::in_keyword_loc"]
        [::std::mem::offset_of!(pm_for_node, in_keyword_loc) - 36usize];
    ["Offset of field: pm_for_node::do_keyword_loc"]
        [::std::mem::offset_of!(pm_for_node, do_keyword_loc) - 44usize];
    ["Offset of field: pm_for_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_for_node, end_keyword_loc) - 52usize];
};
#[doc = " ForNode\n\n Represents the use of the `for` keyword.\n\n     for i in a end\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_FOR_NODE\n\n @extends pm_node_t"]
pub type pm_for_node_t = pm_for_node;
#[doc = " ForwardingArgumentsNode\n\n Represents forwarding all arguments to this method to another method.\n\n     def foo(...)\n       bar(...)\n           ^^^\n     end\n\n Type: ::PM_FORWARDING_ARGUMENTS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_forwarding_arguments_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_forwarding_arguments_node"]
        [::std::mem::size_of::<pm_forwarding_arguments_node>() - 16usize];
    ["Alignment of pm_forwarding_arguments_node"]
        [::std::mem::align_of::<pm_forwarding_arguments_node>() - 4usize];
    ["Offset of field: pm_forwarding_arguments_node::base"]
        [::std::mem::offset_of!(pm_forwarding_arguments_node, base) - 0usize];
};
#[doc = " ForwardingArgumentsNode\n\n Represents forwarding all arguments to this method to another method.\n\n     def foo(...)\n       bar(...)\n           ^^^\n     end\n\n Type: ::PM_FORWARDING_ARGUMENTS_NODE\n\n @extends pm_node_t"]
pub type pm_forwarding_arguments_node_t = pm_forwarding_arguments_node;
#[doc = " ForwardingParameterNode\n\n Represents the use of the forwarding parameter in a method, block, or lambda declaration.\n\n     def foo(...)\n             ^^^\n     end\n\n Type: ::PM_FORWARDING_PARAMETER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_forwarding_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_forwarding_parameter_node"]
        [::std::mem::size_of::<pm_forwarding_parameter_node>() - 16usize];
    ["Alignment of pm_forwarding_parameter_node"]
        [::std::mem::align_of::<pm_forwarding_parameter_node>() - 4usize];
    ["Offset of field: pm_forwarding_parameter_node::base"]
        [::std::mem::offset_of!(pm_forwarding_parameter_node, base) - 0usize];
};
#[doc = " ForwardingParameterNode\n\n Represents the use of the forwarding parameter in a method, block, or lambda declaration.\n\n     def foo(...)\n             ^^^\n     end\n\n Type: ::PM_FORWARDING_PARAMETER_NODE\n\n @extends pm_node_t"]
pub type pm_forwarding_parameter_node_t = pm_forwarding_parameter_node;
#[doc = " ForwardingSuperNode\n\n Represents the use of the `super` keyword without parentheses or arguments.\n\n     super\n     ^^^^^\n\n Type: ::PM_FORWARDING_SUPER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_forwarding_super_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ForwardingSuperNode#block"]
    pub block: *mut pm_block_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_forwarding_super_node"]
        [::std::mem::size_of::<pm_forwarding_super_node>() - 20usize];
    ["Alignment of pm_forwarding_super_node"]
        [::std::mem::align_of::<pm_forwarding_super_node>() - 4usize];
    ["Offset of field: pm_forwarding_super_node::base"]
        [::std::mem::offset_of!(pm_forwarding_super_node, base) - 0usize];
    ["Offset of field: pm_forwarding_super_node::block"]
        [::std::mem::offset_of!(pm_forwarding_super_node, block) - 16usize];
};
#[doc = " ForwardingSuperNode\n\n Represents the use of the `super` keyword without parentheses or arguments.\n\n     super\n     ^^^^^\n\n Type: ::PM_FORWARDING_SUPER_NODE\n\n @extends pm_node_t"]
pub type pm_forwarding_super_node_t = pm_forwarding_super_node;
#[doc = " GlobalVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a global variable.\n\n     $target &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableAndWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " GlobalVariableAndWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " GlobalVariableAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " GlobalVariableAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_and_write_node"]
        [::std::mem::size_of::<pm_global_variable_and_write_node>() - 40usize];
    ["Alignment of pm_global_variable_and_write_node"]
        [::std::mem::align_of::<pm_global_variable_and_write_node>() - 4usize];
    ["Offset of field: pm_global_variable_and_write_node::base"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, base) - 0usize];
    ["Offset of field: pm_global_variable_and_write_node::name"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, name) - 16usize];
    ["Offset of field: pm_global_variable_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, name_loc) - 20usize];
    ["Offset of field: pm_global_variable_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, operator_loc) - 28usize];
    ["Offset of field: pm_global_variable_and_write_node::value"]
        [::std::mem::offset_of!(pm_global_variable_and_write_node, value) - 36usize];
};
#[doc = " GlobalVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a global variable.\n\n     $target &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_and_write_node_t = pm_global_variable_and_write_node;
#[doc = " GlobalVariableOperatorWriteNode\n\n Represents assigning to a global variable using an operator that isn't `=`.\n\n     $target += value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " GlobalVariableOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " GlobalVariableOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " GlobalVariableOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " GlobalVariableOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_operator_write_node"]
        [::std::mem::size_of::<pm_global_variable_operator_write_node>() - 44usize];
    ["Alignment of pm_global_variable_operator_write_node"]
        [::std::mem::align_of::<pm_global_variable_operator_write_node>() - 4usize];
    ["Offset of field: pm_global_variable_operator_write_node::base"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, base) - 0usize];
    ["Offset of field: pm_global_variable_operator_write_node::name"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, name) - 16usize];
    ["Offset of field: pm_global_variable_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, name_loc) - 20usize];
    ["Offset of field: pm_global_variable_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_global_variable_operator_write_node,
        binary_operator_loc
    ) - 28usize];
    ["Offset of field: pm_global_variable_operator_write_node::value"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, value) - 36usize];
    ["Offset of field: pm_global_variable_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_global_variable_operator_write_node, binary_operator) - 40usize];
};
#[doc = " GlobalVariableOperatorWriteNode\n\n Represents assigning to a global variable using an operator that isn't `=`.\n\n     $target += value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_operator_write_node_t = pm_global_variable_operator_write_node;
#[doc = " GlobalVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a global variable.\n\n     $target ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " GlobalVariableOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " GlobalVariableOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " GlobalVariableOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_or_write_node"]
        [::std::mem::size_of::<pm_global_variable_or_write_node>() - 40usize];
    ["Alignment of pm_global_variable_or_write_node"]
        [::std::mem::align_of::<pm_global_variable_or_write_node>() - 4usize];
    ["Offset of field: pm_global_variable_or_write_node::base"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, base) - 0usize];
    ["Offset of field: pm_global_variable_or_write_node::name"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, name) - 16usize];
    ["Offset of field: pm_global_variable_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, name_loc) - 20usize];
    ["Offset of field: pm_global_variable_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, operator_loc) - 28usize];
    ["Offset of field: pm_global_variable_or_write_node::value"]
        [::std::mem::offset_of!(pm_global_variable_or_write_node, value) - 36usize];
};
#[doc = " GlobalVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a global variable.\n\n     $target ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_or_write_node_t = pm_global_variable_or_write_node;
#[doc = " GlobalVariableReadNode\n\n Represents referencing a global variable.\n\n     $foo\n     ^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableReadNode#name\n\n The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.\n\n     $foo   # name `:$foo`\n\n     $_Test # name `:$_Test`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_read_node"]
        [::std::mem::size_of::<pm_global_variable_read_node>() - 20usize];
    ["Alignment of pm_global_variable_read_node"]
        [::std::mem::align_of::<pm_global_variable_read_node>() - 4usize];
    ["Offset of field: pm_global_variable_read_node::base"]
        [::std::mem::offset_of!(pm_global_variable_read_node, base) - 0usize];
    ["Offset of field: pm_global_variable_read_node::name"]
        [::std::mem::offset_of!(pm_global_variable_read_node, name) - 16usize];
};
#[doc = " GlobalVariableReadNode\n\n Represents referencing a global variable.\n\n     $foo\n     ^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_read_node_t = pm_global_variable_read_node;
#[doc = " GlobalVariableTargetNode\n\n Represents writing to a global variable in a context that doesn't have an explicit value.\n\n     $foo, $bar = baz\n     ^^^^  ^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableTargetNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_target_node"]
        [::std::mem::size_of::<pm_global_variable_target_node>() - 20usize];
    ["Alignment of pm_global_variable_target_node"]
        [::std::mem::align_of::<pm_global_variable_target_node>() - 4usize];
    ["Offset of field: pm_global_variable_target_node::base"]
        [::std::mem::offset_of!(pm_global_variable_target_node, base) - 0usize];
    ["Offset of field: pm_global_variable_target_node::name"]
        [::std::mem::offset_of!(pm_global_variable_target_node, name) - 16usize];
};
#[doc = " GlobalVariableTargetNode\n\n Represents writing to a global variable in a context that doesn't have an explicit value.\n\n     $foo, $bar = baz\n     ^^^^  ^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_target_node_t = pm_global_variable_target_node;
#[doc = " GlobalVariableWriteNode\n\n Represents writing to a global variable.\n\n     $foo = 1\n     ^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_global_variable_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " GlobalVariableWriteNode#name\n\n The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.\n\n     $foo = :bar  # name `:$foo`\n\n     $_Test = 123 # name `:$_Test`"]
    pub name: pm_constant_id_t,
    #[doc = " GlobalVariableWriteNode#name_loc\n\n The location of the global variable's name.\n\n     $foo = :bar\n     ^^^^"]
    pub name_loc: pm_location_t,
    #[doc = " GlobalVariableWriteNode#value\n\n The value to write to the global variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     $foo = :bar\n            ^^^^\n\n     $-xyz = 123\n             ^^^"]
    pub value: *mut pm_node,
    #[doc = " GlobalVariableWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     $foo = :bar\n          ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_global_variable_write_node"]
        [::std::mem::size_of::<pm_global_variable_write_node>() - 40usize];
    ["Alignment of pm_global_variable_write_node"]
        [::std::mem::align_of::<pm_global_variable_write_node>() - 4usize];
    ["Offset of field: pm_global_variable_write_node::base"]
        [::std::mem::offset_of!(pm_global_variable_write_node, base) - 0usize];
    ["Offset of field: pm_global_variable_write_node::name"]
        [::std::mem::offset_of!(pm_global_variable_write_node, name) - 16usize];
    ["Offset of field: pm_global_variable_write_node::name_loc"]
        [::std::mem::offset_of!(pm_global_variable_write_node, name_loc) - 20usize];
    ["Offset of field: pm_global_variable_write_node::value"]
        [::std::mem::offset_of!(pm_global_variable_write_node, value) - 28usize];
    ["Offset of field: pm_global_variable_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_global_variable_write_node, operator_loc) - 32usize];
};
#[doc = " GlobalVariableWriteNode\n\n Represents writing to a global variable.\n\n     $foo = 1\n     ^^^^^^^^\n\n Type: ::PM_GLOBAL_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_global_variable_write_node_t = pm_global_variable_write_node;
#[doc = " HashNode\n\n Represents a hash literal.\n\n     { a => b }\n     ^^^^^^^^^^\n\n Type: ::PM_HASH_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_hash_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " HashNode#opening_loc\n\n The location of the opening brace.\n\n     { a => b }\n     ^"]
    pub opening_loc: pm_location_t,
    #[doc = " HashNode#elements\n\n The elements of the hash. These can be either `AssocNode`s or `AssocSplatNode`s.\n\n     { a: b }\n       ^^^^\n\n     { **foo }\n       ^^^^^"]
    pub elements: pm_node_list,
    #[doc = " HashNode#closing_loc\n\n The location of the closing brace.\n\n     { a => b }\n              ^"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_hash_node"][::std::mem::size_of::<pm_hash_node>() - 44usize];
    ["Alignment of pm_hash_node"][::std::mem::align_of::<pm_hash_node>() - 4usize];
    ["Offset of field: pm_hash_node::base"][::std::mem::offset_of!(pm_hash_node, base) - 0usize];
    ["Offset of field: pm_hash_node::opening_loc"]
        [::std::mem::offset_of!(pm_hash_node, opening_loc) - 16usize];
    ["Offset of field: pm_hash_node::elements"]
        [::std::mem::offset_of!(pm_hash_node, elements) - 24usize];
    ["Offset of field: pm_hash_node::closing_loc"]
        [::std::mem::offset_of!(pm_hash_node, closing_loc) - 36usize];
};
#[doc = " HashNode\n\n Represents a hash literal.\n\n     { a => b }\n     ^^^^^^^^^^\n\n Type: ::PM_HASH_NODE\n\n @extends pm_node_t"]
pub type pm_hash_node_t = pm_hash_node;
#[doc = " HashPatternNode\n\n Represents a hash pattern in pattern matching.\n\n     foo => { a: 1, b: 2 }\n            ^^^^^^^^^^^^^^\n\n     foo => { a: 1, b: 2, **c }\n            ^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_HASH_PATTERN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_hash_pattern_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " HashPatternNode#constant"]
    pub constant: *mut pm_node,
    #[doc = " HashPatternNode#elements"]
    pub elements: pm_node_list,
    #[doc = " HashPatternNode#rest"]
    pub rest: *mut pm_node,
    #[doc = " HashPatternNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " HashPatternNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_hash_pattern_node"][::std::mem::size_of::<pm_hash_pattern_node>() - 52usize];
    ["Alignment of pm_hash_pattern_node"][::std::mem::align_of::<pm_hash_pattern_node>() - 4usize];
    ["Offset of field: pm_hash_pattern_node::base"]
        [::std::mem::offset_of!(pm_hash_pattern_node, base) - 0usize];
    ["Offset of field: pm_hash_pattern_node::constant"]
        [::std::mem::offset_of!(pm_hash_pattern_node, constant) - 16usize];
    ["Offset of field: pm_hash_pattern_node::elements"]
        [::std::mem::offset_of!(pm_hash_pattern_node, elements) - 20usize];
    ["Offset of field: pm_hash_pattern_node::rest"]
        [::std::mem::offset_of!(pm_hash_pattern_node, rest) - 32usize];
    ["Offset of field: pm_hash_pattern_node::opening_loc"]
        [::std::mem::offset_of!(pm_hash_pattern_node, opening_loc) - 36usize];
    ["Offset of field: pm_hash_pattern_node::closing_loc"]
        [::std::mem::offset_of!(pm_hash_pattern_node, closing_loc) - 44usize];
};
#[doc = " HashPatternNode\n\n Represents a hash pattern in pattern matching.\n\n     foo => { a: 1, b: 2 }\n            ^^^^^^^^^^^^^^\n\n     foo => { a: 1, b: 2, **c }\n            ^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_HASH_PATTERN_NODE\n\n @extends pm_node_t"]
pub type pm_hash_pattern_node_t = pm_hash_pattern_node;
#[doc = " IfNode\n\n Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.\n\n     bar if foo\n     ^^^^^^^^^^\n\n     if foo then bar end\n     ^^^^^^^^^^^^^^^^^^^\n\n     foo ? bar : baz\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_IF_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_if_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IfNode#if_keyword_loc\n\n The location of the `if` keyword if present.\n\n     bar if foo\n         ^^\n\n The `if_keyword_loc` field will be `nil` when the `IfNode` represents a ternary expression."]
    pub if_keyword_loc: pm_location_t,
    #[doc = " IfNode#predicate\n\n The node for the condition the `IfNode` is testing.\n\n     if foo\n        ^^^\n       bar\n     end\n\n     bar if foo\n            ^^^\n\n     foo ? bar : baz\n     ^^^"]
    pub predicate: *mut pm_node,
    #[doc = " IfNode#then_keyword_loc\n\n The location of the `then` keyword (if present) or the `?` in a ternary expression, `nil` otherwise.\n\n     if foo then bar end\n            ^^^^\n\n     a ? b : c\n       ^"]
    pub then_keyword_loc: pm_location_t,
    #[doc = " IfNode#statements\n\n Represents the body of statements that will be executed when the predicate is evaluated as truthy. Will be `nil` when no body is provided.\n\n     if foo\n       bar\n       ^^^\n       baz\n       ^^^\n     end"]
    pub statements: *mut pm_statements_node,
    #[doc = " IfNode#subsequent\n\n Represents an `ElseNode` or an `IfNode` when there is an `else` or an `elsif` in the `if` statement.\n\n     if foo\n       bar\n     elsif baz\n     ^^^^^^^^^\n       qux\n       ^^^\n     end\n     ^^^\n\n     if foo then bar else baz end\n                     ^^^^^^^^^^^^"]
    pub subsequent: *mut pm_node,
    #[doc = " IfNode#end_keyword_loc\n\n The location of the `end` keyword if present, `nil` otherwise.\n\n     if foo\n       bar\n     end\n     ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_if_node"][::std::mem::size_of::<pm_if_node>() - 52usize];
    ["Alignment of pm_if_node"][::std::mem::align_of::<pm_if_node>() - 4usize];
    ["Offset of field: pm_if_node::base"][::std::mem::offset_of!(pm_if_node, base) - 0usize];
    ["Offset of field: pm_if_node::if_keyword_loc"]
        [::std::mem::offset_of!(pm_if_node, if_keyword_loc) - 16usize];
    ["Offset of field: pm_if_node::predicate"]
        [::std::mem::offset_of!(pm_if_node, predicate) - 24usize];
    ["Offset of field: pm_if_node::then_keyword_loc"]
        [::std::mem::offset_of!(pm_if_node, then_keyword_loc) - 28usize];
    ["Offset of field: pm_if_node::statements"]
        [::std::mem::offset_of!(pm_if_node, statements) - 36usize];
    ["Offset of field: pm_if_node::subsequent"]
        [::std::mem::offset_of!(pm_if_node, subsequent) - 40usize];
    ["Offset of field: pm_if_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_if_node, end_keyword_loc) - 44usize];
};
#[doc = " IfNode\n\n Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.\n\n     bar if foo\n     ^^^^^^^^^^\n\n     if foo then bar end\n     ^^^^^^^^^^^^^^^^^^^\n\n     foo ? bar : baz\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_IF_NODE\n\n @extends pm_node_t"]
pub type pm_if_node_t = pm_if_node;
#[doc = " ImaginaryNode\n\n Represents an imaginary number literal.\n\n     1.0i\n     ^^^^\n\n Type: ::PM_IMAGINARY_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_imaginary_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ImaginaryNode#numeric"]
    pub numeric: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_imaginary_node"][::std::mem::size_of::<pm_imaginary_node>() - 20usize];
    ["Alignment of pm_imaginary_node"][::std::mem::align_of::<pm_imaginary_node>() - 4usize];
    ["Offset of field: pm_imaginary_node::base"]
        [::std::mem::offset_of!(pm_imaginary_node, base) - 0usize];
    ["Offset of field: pm_imaginary_node::numeric"]
        [::std::mem::offset_of!(pm_imaginary_node, numeric) - 16usize];
};
#[doc = " ImaginaryNode\n\n Represents an imaginary number literal.\n\n     1.0i\n     ^^^^\n\n Type: ::PM_IMAGINARY_NODE\n\n @extends pm_node_t"]
pub type pm_imaginary_node_t = pm_imaginary_node;
#[doc = " ImplicitNode\n\n Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.\n\n     { foo: }\n       ^^^^\n\n     { Foo: }\n       ^^^^\n\n     foo in { bar: }\n              ^^^^\n\n Type: ::PM_IMPLICIT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_implicit_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ImplicitNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_implicit_node"][::std::mem::size_of::<pm_implicit_node>() - 20usize];
    ["Alignment of pm_implicit_node"][::std::mem::align_of::<pm_implicit_node>() - 4usize];
    ["Offset of field: pm_implicit_node::base"]
        [::std::mem::offset_of!(pm_implicit_node, base) - 0usize];
    ["Offset of field: pm_implicit_node::value"]
        [::std::mem::offset_of!(pm_implicit_node, value) - 16usize];
};
#[doc = " ImplicitNode\n\n Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.\n\n     { foo: }\n       ^^^^\n\n     { Foo: }\n       ^^^^\n\n     foo in { bar: }\n              ^^^^\n\n Type: ::PM_IMPLICIT_NODE\n\n @extends pm_node_t"]
pub type pm_implicit_node_t = pm_implicit_node;
#[doc = " ImplicitRestNode\n\n Represents using a trailing comma to indicate an implicit rest parameter.\n\n     foo { |bar,| }\n               ^\n\n     foo in [bar,]\n                ^\n\n     for foo, in bar do end\n            ^\n\n     foo, = bar\n        ^\n\n Type: ::PM_IMPLICIT_REST_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_implicit_rest_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_implicit_rest_node"][::std::mem::size_of::<pm_implicit_rest_node>() - 16usize];
    ["Alignment of pm_implicit_rest_node"]
        [::std::mem::align_of::<pm_implicit_rest_node>() - 4usize];
    ["Offset of field: pm_implicit_rest_node::base"]
        [::std::mem::offset_of!(pm_implicit_rest_node, base) - 0usize];
};
#[doc = " ImplicitRestNode\n\n Represents using a trailing comma to indicate an implicit rest parameter.\n\n     foo { |bar,| }\n               ^\n\n     foo in [bar,]\n                ^\n\n     for foo, in bar do end\n            ^\n\n     foo, = bar\n        ^\n\n Type: ::PM_IMPLICIT_REST_NODE\n\n @extends pm_node_t"]
pub type pm_implicit_rest_node_t = pm_implicit_rest_node;
#[doc = " InNode\n\n Represents the use of the `in` keyword in a case statement.\n\n     case a; in b then c end\n             ^^^^^^^^^^^\n\n Type: ::PM_IN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_in_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InNode#pattern"]
    pub pattern: *mut pm_node,
    #[doc = " InNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " InNode#in_loc"]
    pub in_loc: pm_location_t,
    #[doc = " InNode#then_loc"]
    pub then_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_in_node"][::std::mem::size_of::<pm_in_node>() - 40usize];
    ["Alignment of pm_in_node"][::std::mem::align_of::<pm_in_node>() - 4usize];
    ["Offset of field: pm_in_node::base"][::std::mem::offset_of!(pm_in_node, base) - 0usize];
    ["Offset of field: pm_in_node::pattern"][::std::mem::offset_of!(pm_in_node, pattern) - 16usize];
    ["Offset of field: pm_in_node::statements"]
        [::std::mem::offset_of!(pm_in_node, statements) - 20usize];
    ["Offset of field: pm_in_node::in_loc"][::std::mem::offset_of!(pm_in_node, in_loc) - 24usize];
    ["Offset of field: pm_in_node::then_loc"]
        [::std::mem::offset_of!(pm_in_node, then_loc) - 32usize];
};
#[doc = " InNode\n\n Represents the use of the `in` keyword in a case statement.\n\n     case a; in b then c end\n             ^^^^^^^^^^^\n\n Type: ::PM_IN_NODE\n\n @extends pm_node_t"]
pub type pm_in_node_t = pm_in_node;
#[doc = " IndexAndWriteNode\n\n Represents the use of the `&&=` operator on a call to the `[]` method.\n\n     foo.bar[baz] &&= value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_AND_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_index_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IndexAndWriteNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " IndexAndWriteNode#call_operator_loc"]
    pub call_operator_loc: pm_location_t,
    #[doc = " IndexAndWriteNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " IndexAndWriteNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " IndexAndWriteNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " IndexAndWriteNode#block"]
    pub block: *mut pm_block_argument_node,
    #[doc = " IndexAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " IndexAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_index_and_write_node"][::std::mem::size_of::<pm_index_and_write_node>() - 64usize];
    ["Alignment of pm_index_and_write_node"]
        [::std::mem::align_of::<pm_index_and_write_node>() - 4usize];
    ["Offset of field: pm_index_and_write_node::base"]
        [::std::mem::offset_of!(pm_index_and_write_node, base) - 0usize];
    ["Offset of field: pm_index_and_write_node::receiver"]
        [::std::mem::offset_of!(pm_index_and_write_node, receiver) - 16usize];
    ["Offset of field: pm_index_and_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_index_and_write_node, call_operator_loc) - 20usize];
    ["Offset of field: pm_index_and_write_node::opening_loc"]
        [::std::mem::offset_of!(pm_index_and_write_node, opening_loc) - 28usize];
    ["Offset of field: pm_index_and_write_node::arguments"]
        [::std::mem::offset_of!(pm_index_and_write_node, arguments) - 36usize];
    ["Offset of field: pm_index_and_write_node::closing_loc"]
        [::std::mem::offset_of!(pm_index_and_write_node, closing_loc) - 40usize];
    ["Offset of field: pm_index_and_write_node::block"]
        [::std::mem::offset_of!(pm_index_and_write_node, block) - 48usize];
    ["Offset of field: pm_index_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_index_and_write_node, operator_loc) - 52usize];
    ["Offset of field: pm_index_and_write_node::value"]
        [::std::mem::offset_of!(pm_index_and_write_node, value) - 60usize];
};
#[doc = " IndexAndWriteNode\n\n Represents the use of the `&&=` operator on a call to the `[]` method.\n\n     foo.bar[baz] &&= value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_AND_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_index_and_write_node_t = pm_index_and_write_node;
#[doc = " IndexOperatorWriteNode\n\n Represents the use of an assignment operator on a call to `[]`.\n\n     foo.bar[baz] += value\n     ^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_OPERATOR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_index_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IndexOperatorWriteNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " IndexOperatorWriteNode#call_operator_loc"]
    pub call_operator_loc: pm_location_t,
    #[doc = " IndexOperatorWriteNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " IndexOperatorWriteNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " IndexOperatorWriteNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " IndexOperatorWriteNode#block"]
    pub block: *mut pm_block_argument_node,
    #[doc = " IndexOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
    #[doc = " IndexOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " IndexOperatorWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_index_operator_write_node"]
        [::std::mem::size_of::<pm_index_operator_write_node>() - 68usize];
    ["Alignment of pm_index_operator_write_node"]
        [::std::mem::align_of::<pm_index_operator_write_node>() - 4usize];
    ["Offset of field: pm_index_operator_write_node::base"]
        [::std::mem::offset_of!(pm_index_operator_write_node, base) - 0usize];
    ["Offset of field: pm_index_operator_write_node::receiver"]
        [::std::mem::offset_of!(pm_index_operator_write_node, receiver) - 16usize];
    ["Offset of field: pm_index_operator_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_index_operator_write_node, call_operator_loc) - 20usize];
    ["Offset of field: pm_index_operator_write_node::opening_loc"]
        [::std::mem::offset_of!(pm_index_operator_write_node, opening_loc) - 28usize];
    ["Offset of field: pm_index_operator_write_node::arguments"]
        [::std::mem::offset_of!(pm_index_operator_write_node, arguments) - 36usize];
    ["Offset of field: pm_index_operator_write_node::closing_loc"]
        [::std::mem::offset_of!(pm_index_operator_write_node, closing_loc) - 40usize];
    ["Offset of field: pm_index_operator_write_node::block"]
        [::std::mem::offset_of!(pm_index_operator_write_node, block) - 48usize];
    ["Offset of field: pm_index_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_index_operator_write_node, binary_operator) - 52usize];
    ["Offset of field: pm_index_operator_write_node::binary_operator_loc"]
        [::std::mem::offset_of!(pm_index_operator_write_node, binary_operator_loc) - 56usize];
    ["Offset of field: pm_index_operator_write_node::value"]
        [::std::mem::offset_of!(pm_index_operator_write_node, value) - 64usize];
};
#[doc = " IndexOperatorWriteNode\n\n Represents the use of an assignment operator on a call to `[]`.\n\n     foo.bar[baz] += value\n     ^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_OPERATOR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_index_operator_write_node_t = pm_index_operator_write_node;
#[doc = " IndexOrWriteNode\n\n Represents the use of the `||=` operator on a call to `[]`.\n\n     foo.bar[baz] ||= value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_OR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_index_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IndexOrWriteNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " IndexOrWriteNode#call_operator_loc"]
    pub call_operator_loc: pm_location_t,
    #[doc = " IndexOrWriteNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " IndexOrWriteNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " IndexOrWriteNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " IndexOrWriteNode#block"]
    pub block: *mut pm_block_argument_node,
    #[doc = " IndexOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " IndexOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_index_or_write_node"][::std::mem::size_of::<pm_index_or_write_node>() - 64usize];
    ["Alignment of pm_index_or_write_node"]
        [::std::mem::align_of::<pm_index_or_write_node>() - 4usize];
    ["Offset of field: pm_index_or_write_node::base"]
        [::std::mem::offset_of!(pm_index_or_write_node, base) - 0usize];
    ["Offset of field: pm_index_or_write_node::receiver"]
        [::std::mem::offset_of!(pm_index_or_write_node, receiver) - 16usize];
    ["Offset of field: pm_index_or_write_node::call_operator_loc"]
        [::std::mem::offset_of!(pm_index_or_write_node, call_operator_loc) - 20usize];
    ["Offset of field: pm_index_or_write_node::opening_loc"]
        [::std::mem::offset_of!(pm_index_or_write_node, opening_loc) - 28usize];
    ["Offset of field: pm_index_or_write_node::arguments"]
        [::std::mem::offset_of!(pm_index_or_write_node, arguments) - 36usize];
    ["Offset of field: pm_index_or_write_node::closing_loc"]
        [::std::mem::offset_of!(pm_index_or_write_node, closing_loc) - 40usize];
    ["Offset of field: pm_index_or_write_node::block"]
        [::std::mem::offset_of!(pm_index_or_write_node, block) - 48usize];
    ["Offset of field: pm_index_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_index_or_write_node, operator_loc) - 52usize];
    ["Offset of field: pm_index_or_write_node::value"]
        [::std::mem::offset_of!(pm_index_or_write_node, value) - 60usize];
};
#[doc = " IndexOrWriteNode\n\n Represents the use of the `||=` operator on a call to `[]`.\n\n     foo.bar[baz] ||= value\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INDEX_OR_WRITE_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_index_or_write_node_t = pm_index_or_write_node;
#[doc = " IndexTargetNode\n\n Represents assigning to an index.\n\n     foo[bar], = 1\n     ^^^^^^^^\n\n     begin\n     rescue => foo[bar]\n               ^^^^^^^^\n     end\n\n     for foo[bar] in baz do end\n         ^^^^^^^^\n\n Type: ::PM_INDEX_TARGET_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_index_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IndexTargetNode#receiver"]
    pub receiver: *mut pm_node,
    #[doc = " IndexTargetNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " IndexTargetNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " IndexTargetNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " IndexTargetNode#block"]
    pub block: *mut pm_block_argument_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_index_target_node"][::std::mem::size_of::<pm_index_target_node>() - 44usize];
    ["Alignment of pm_index_target_node"][::std::mem::align_of::<pm_index_target_node>() - 4usize];
    ["Offset of field: pm_index_target_node::base"]
        [::std::mem::offset_of!(pm_index_target_node, base) - 0usize];
    ["Offset of field: pm_index_target_node::receiver"]
        [::std::mem::offset_of!(pm_index_target_node, receiver) - 16usize];
    ["Offset of field: pm_index_target_node::opening_loc"]
        [::std::mem::offset_of!(pm_index_target_node, opening_loc) - 20usize];
    ["Offset of field: pm_index_target_node::arguments"]
        [::std::mem::offset_of!(pm_index_target_node, arguments) - 28usize];
    ["Offset of field: pm_index_target_node::closing_loc"]
        [::std::mem::offset_of!(pm_index_target_node, closing_loc) - 32usize];
    ["Offset of field: pm_index_target_node::block"]
        [::std::mem::offset_of!(pm_index_target_node, block) - 40usize];
};
#[doc = " IndexTargetNode\n\n Represents assigning to an index.\n\n     foo[bar], = 1\n     ^^^^^^^^\n\n     begin\n     rescue => foo[bar]\n               ^^^^^^^^\n     end\n\n     for foo[bar] in baz do end\n         ^^^^^^^^\n\n Type: ::PM_INDEX_TARGET_NODE\n\n Flags (#pm_call_node_flags):\n * ::PM_CALL_NODE_FLAGS_SAFE_NAVIGATION\n * ::PM_CALL_NODE_FLAGS_VARIABLE_CALL\n * ::PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE\n * ::PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY\n\n @extends pm_node_t"]
pub type pm_index_target_node_t = pm_index_target_node;
#[doc = " InstanceVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to an instance variable.\n\n     @target &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableAndWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " InstanceVariableAndWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " InstanceVariableAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " InstanceVariableAndWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_and_write_node"]
        [::std::mem::size_of::<pm_instance_variable_and_write_node>() - 40usize];
    ["Alignment of pm_instance_variable_and_write_node"]
        [::std::mem::align_of::<pm_instance_variable_and_write_node>() - 4usize];
    ["Offset of field: pm_instance_variable_and_write_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_and_write_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, name) - 16usize];
    ["Offset of field: pm_instance_variable_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, name_loc) - 20usize];
    ["Offset of field: pm_instance_variable_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, operator_loc) - 28usize];
    ["Offset of field: pm_instance_variable_and_write_node::value"]
        [::std::mem::offset_of!(pm_instance_variable_and_write_node, value) - 36usize];
};
#[doc = " InstanceVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to an instance variable.\n\n     @target &&= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_and_write_node_t = pm_instance_variable_and_write_node;
#[doc = " InstanceVariableOperatorWriteNode\n\n Represents assigning to an instance variable using an operator that isn't `=`.\n\n     @target += value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " InstanceVariableOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " InstanceVariableOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " InstanceVariableOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " InstanceVariableOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_operator_write_node"]
        [::std::mem::size_of::<pm_instance_variable_operator_write_node>() - 44usize];
    ["Alignment of pm_instance_variable_operator_write_node"]
        [::std::mem::align_of::<pm_instance_variable_operator_write_node>() - 4usize];
    ["Offset of field: pm_instance_variable_operator_write_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_operator_write_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_operator_write_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_operator_write_node, name) - 16usize];
    ["Offset of field: pm_instance_variable_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_instance_variable_operator_write_node, name_loc) - 20usize];
    ["Offset of field: pm_instance_variable_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_instance_variable_operator_write_node,
        binary_operator_loc
    ) - 28usize];
    ["Offset of field: pm_instance_variable_operator_write_node::value"]
        [::std::mem::offset_of!(pm_instance_variable_operator_write_node, value) - 36usize];
    ["Offset of field: pm_instance_variable_operator_write_node::binary_operator"][::std::mem::offset_of!(
        pm_instance_variable_operator_write_node,
        binary_operator
    ) - 40usize];
};
#[doc = " InstanceVariableOperatorWriteNode\n\n Represents assigning to an instance variable using an operator that isn't `=`.\n\n     @target += value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_operator_write_node_t = pm_instance_variable_operator_write_node;
#[doc = " InstanceVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to an instance variable.\n\n     @target ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " InstanceVariableOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " InstanceVariableOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " InstanceVariableOrWriteNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_or_write_node"]
        [::std::mem::size_of::<pm_instance_variable_or_write_node>() - 40usize];
    ["Alignment of pm_instance_variable_or_write_node"]
        [::std::mem::align_of::<pm_instance_variable_or_write_node>() - 4usize];
    ["Offset of field: pm_instance_variable_or_write_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_or_write_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, name) - 16usize];
    ["Offset of field: pm_instance_variable_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, name_loc) - 20usize];
    ["Offset of field: pm_instance_variable_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, operator_loc) - 28usize];
    ["Offset of field: pm_instance_variable_or_write_node::value"]
        [::std::mem::offset_of!(pm_instance_variable_or_write_node, value) - 36usize];
};
#[doc = " InstanceVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to an instance variable.\n\n     @target ||= value\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_or_write_node_t = pm_instance_variable_or_write_node;
#[doc = " InstanceVariableReadNode\n\n Represents referencing an instance variable.\n\n     @foo\n     ^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableReadNode#name\n\n The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @x     # name `:@x`\n\n     @_test # name `:@_test`"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_read_node"]
        [::std::mem::size_of::<pm_instance_variable_read_node>() - 20usize];
    ["Alignment of pm_instance_variable_read_node"]
        [::std::mem::align_of::<pm_instance_variable_read_node>() - 4usize];
    ["Offset of field: pm_instance_variable_read_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_read_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_read_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_read_node, name) - 16usize];
};
#[doc = " InstanceVariableReadNode\n\n Represents referencing an instance variable.\n\n     @foo\n     ^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_read_node_t = pm_instance_variable_read_node;
#[doc = " InstanceVariableTargetNode\n\n Represents writing to an instance variable in a context that doesn't have an explicit value.\n\n     @foo, @bar = baz\n     ^^^^  ^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableTargetNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_target_node"]
        [::std::mem::size_of::<pm_instance_variable_target_node>() - 20usize];
    ["Alignment of pm_instance_variable_target_node"]
        [::std::mem::align_of::<pm_instance_variable_target_node>() - 4usize];
    ["Offset of field: pm_instance_variable_target_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_target_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_target_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_target_node, name) - 16usize];
};
#[doc = " InstanceVariableTargetNode\n\n Represents writing to an instance variable in a context that doesn't have an explicit value.\n\n     @foo, @bar = baz\n     ^^^^  ^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_target_node_t = pm_instance_variable_target_node;
#[doc = " InstanceVariableWriteNode\n\n Represents writing to an instance variable.\n\n     @foo = 1\n     ^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_instance_variable_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InstanceVariableWriteNode#name\n\n The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     @x = :y       # name `:@x`\n\n     @_foo = \"bar\" # name `@_foo`"]
    pub name: pm_constant_id_t,
    #[doc = " InstanceVariableWriteNode#name_loc\n\n The location of the variable name.\n\n     @_x = 1\n     ^^^"]
    pub name_loc: pm_location_t,
    #[doc = " InstanceVariableWriteNode#value\n\n The value to write to the instance variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     @foo = :bar\n            ^^^^\n\n     @_x = 1234\n           ^^^^"]
    pub value: *mut pm_node,
    #[doc = " InstanceVariableWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     @x = y\n        ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_instance_variable_write_node"]
        [::std::mem::size_of::<pm_instance_variable_write_node>() - 40usize];
    ["Alignment of pm_instance_variable_write_node"]
        [::std::mem::align_of::<pm_instance_variable_write_node>() - 4usize];
    ["Offset of field: pm_instance_variable_write_node::base"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, base) - 0usize];
    ["Offset of field: pm_instance_variable_write_node::name"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, name) - 16usize];
    ["Offset of field: pm_instance_variable_write_node::name_loc"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, name_loc) - 20usize];
    ["Offset of field: pm_instance_variable_write_node::value"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, value) - 28usize];
    ["Offset of field: pm_instance_variable_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_instance_variable_write_node, operator_loc) - 32usize];
};
#[doc = " InstanceVariableWriteNode\n\n Represents writing to an instance variable.\n\n     @foo = 1\n     ^^^^^^^^\n\n Type: ::PM_INSTANCE_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_instance_variable_write_node_t = pm_instance_variable_write_node;
#[doc = " IntegerNode\n\n Represents an integer number literal.\n\n     1\n     ^\n\n Type: ::PM_INTEGER_NODE\n\n Flags (#pm_integer_base_flags):\n * ::PM_INTEGER_BASE_FLAGS_BINARY\n * ::PM_INTEGER_BASE_FLAGS_DECIMAL\n * ::PM_INTEGER_BASE_FLAGS_OCTAL\n * ::PM_INTEGER_BASE_FLAGS_HEXADECIMAL\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_integer_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " IntegerNode#value\n\n The value of the integer literal as a number."]
    pub value: pm_integer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_integer_node"][::std::mem::size_of::<pm_integer_node>() - 32usize];
    ["Alignment of pm_integer_node"][::std::mem::align_of::<pm_integer_node>() - 4usize];
    ["Offset of field: pm_integer_node::base"]
        [::std::mem::offset_of!(pm_integer_node, base) - 0usize];
    ["Offset of field: pm_integer_node::value"]
        [::std::mem::offset_of!(pm_integer_node, value) - 16usize];
};
#[doc = " IntegerNode\n\n Represents an integer number literal.\n\n     1\n     ^\n\n Type: ::PM_INTEGER_NODE\n\n Flags (#pm_integer_base_flags):\n * ::PM_INTEGER_BASE_FLAGS_BINARY\n * ::PM_INTEGER_BASE_FLAGS_DECIMAL\n * ::PM_INTEGER_BASE_FLAGS_OCTAL\n * ::PM_INTEGER_BASE_FLAGS_HEXADECIMAL\n\n @extends pm_node_t"]
pub type pm_integer_node_t = pm_integer_node;
#[doc = " InterpolatedMatchLastLineNode\n\n Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.\n\n     if /foo #{bar} baz/ then end\n        ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_MATCH_LAST_LINE_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_match_last_line_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedMatchLastLineNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedMatchLastLineNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedMatchLastLineNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_match_last_line_node"]
        [::std::mem::size_of::<pm_interpolated_match_last_line_node>() - 44usize];
    ["Alignment of pm_interpolated_match_last_line_node"]
        [::std::mem::align_of::<pm_interpolated_match_last_line_node>() - 4usize];
    ["Offset of field: pm_interpolated_match_last_line_node::base"]
        [::std::mem::offset_of!(pm_interpolated_match_last_line_node, base) - 0usize];
    ["Offset of field: pm_interpolated_match_last_line_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_match_last_line_node, opening_loc) - 16usize];
    ["Offset of field: pm_interpolated_match_last_line_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_match_last_line_node, parts) - 24usize];
    ["Offset of field: pm_interpolated_match_last_line_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_match_last_line_node, closing_loc) - 36usize];
};
#[doc = " InterpolatedMatchLastLineNode\n\n Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.\n\n     if /foo #{bar} baz/ then end\n        ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_MATCH_LAST_LINE_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_interpolated_match_last_line_node_t = pm_interpolated_match_last_line_node;
#[doc = " InterpolatedRegularExpressionNode\n\n Represents a regular expression literal that contains interpolation.\n\n     /foo #{bar} baz/\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_REGULAR_EXPRESSION_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_regular_expression_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedRegularExpressionNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedRegularExpressionNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedRegularExpressionNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_regular_expression_node"]
        [::std::mem::size_of::<pm_interpolated_regular_expression_node>() - 44usize];
    ["Alignment of pm_interpolated_regular_expression_node"]
        [::std::mem::align_of::<pm_interpolated_regular_expression_node>() - 4usize];
    ["Offset of field: pm_interpolated_regular_expression_node::base"]
        [::std::mem::offset_of!(pm_interpolated_regular_expression_node, base) - 0usize];
    ["Offset of field: pm_interpolated_regular_expression_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_regular_expression_node, opening_loc) - 16usize];
    ["Offset of field: pm_interpolated_regular_expression_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_regular_expression_node, parts) - 24usize];
    ["Offset of field: pm_interpolated_regular_expression_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_regular_expression_node, closing_loc) - 36usize];
};
#[doc = " InterpolatedRegularExpressionNode\n\n Represents a regular expression literal that contains interpolation.\n\n     /foo #{bar} baz/\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_REGULAR_EXPRESSION_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_interpolated_regular_expression_node_t = pm_interpolated_regular_expression_node;
#[doc = " InterpolatedStringNode\n\n Represents a string literal that contains interpolation.\n\n     \"foo #{bar} baz\"\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_STRING_NODE\n\n Flags (#pm_interpolated_string_node_flags):\n * ::PM_INTERPOLATED_STRING_NODE_FLAGS_FROZEN\n * ::PM_INTERPOLATED_STRING_NODE_FLAGS_MUTABLE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_string_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedStringNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedStringNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedStringNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_string_node"]
        [::std::mem::size_of::<pm_interpolated_string_node>() - 44usize];
    ["Alignment of pm_interpolated_string_node"]
        [::std::mem::align_of::<pm_interpolated_string_node>() - 4usize];
    ["Offset of field: pm_interpolated_string_node::base"]
        [::std::mem::offset_of!(pm_interpolated_string_node, base) - 0usize];
    ["Offset of field: pm_interpolated_string_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_string_node, opening_loc) - 16usize];
    ["Offset of field: pm_interpolated_string_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_string_node, parts) - 24usize];
    ["Offset of field: pm_interpolated_string_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_string_node, closing_loc) - 36usize];
};
#[doc = " InterpolatedStringNode\n\n Represents a string literal that contains interpolation.\n\n     \"foo #{bar} baz\"\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_STRING_NODE\n\n Flags (#pm_interpolated_string_node_flags):\n * ::PM_INTERPOLATED_STRING_NODE_FLAGS_FROZEN\n * ::PM_INTERPOLATED_STRING_NODE_FLAGS_MUTABLE\n\n @extends pm_node_t"]
pub type pm_interpolated_string_node_t = pm_interpolated_string_node;
#[doc = " InterpolatedSymbolNode\n\n Represents a symbol literal that contains interpolation.\n\n     :\"foo #{bar} baz\"\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_SYMBOL_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_symbol_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedSymbolNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedSymbolNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedSymbolNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_symbol_node"]
        [::std::mem::size_of::<pm_interpolated_symbol_node>() - 44usize];
    ["Alignment of pm_interpolated_symbol_node"]
        [::std::mem::align_of::<pm_interpolated_symbol_node>() - 4usize];
    ["Offset of field: pm_interpolated_symbol_node::base"]
        [::std::mem::offset_of!(pm_interpolated_symbol_node, base) - 0usize];
    ["Offset of field: pm_interpolated_symbol_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_symbol_node, opening_loc) - 16usize];
    ["Offset of field: pm_interpolated_symbol_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_symbol_node, parts) - 24usize];
    ["Offset of field: pm_interpolated_symbol_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_symbol_node, closing_loc) - 36usize];
};
#[doc = " InterpolatedSymbolNode\n\n Represents a symbol literal that contains interpolation.\n\n     :\"foo #{bar} baz\"\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_SYMBOL_NODE\n\n @extends pm_node_t"]
pub type pm_interpolated_symbol_node_t = pm_interpolated_symbol_node;
#[doc = " InterpolatedXStringNode\n\n Represents an xstring literal that contains interpolation.\n\n     `foo #{bar} baz`\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_X_STRING_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_interpolated_x_string_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " InterpolatedXStringNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " InterpolatedXStringNode#parts"]
    pub parts: pm_node_list,
    #[doc = " InterpolatedXStringNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_interpolated_x_string_node"]
        [::std::mem::size_of::<pm_interpolated_x_string_node>() - 44usize];
    ["Alignment of pm_interpolated_x_string_node"]
        [::std::mem::align_of::<pm_interpolated_x_string_node>() - 4usize];
    ["Offset of field: pm_interpolated_x_string_node::base"]
        [::std::mem::offset_of!(pm_interpolated_x_string_node, base) - 0usize];
    ["Offset of field: pm_interpolated_x_string_node::opening_loc"]
        [::std::mem::offset_of!(pm_interpolated_x_string_node, opening_loc) - 16usize];
    ["Offset of field: pm_interpolated_x_string_node::parts"]
        [::std::mem::offset_of!(pm_interpolated_x_string_node, parts) - 24usize];
    ["Offset of field: pm_interpolated_x_string_node::closing_loc"]
        [::std::mem::offset_of!(pm_interpolated_x_string_node, closing_loc) - 36usize];
};
#[doc = " InterpolatedXStringNode\n\n Represents an xstring literal that contains interpolation.\n\n     `foo #{bar} baz`\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_INTERPOLATED_X_STRING_NODE\n\n @extends pm_node_t"]
pub type pm_interpolated_x_string_node_t = pm_interpolated_x_string_node;
#[doc = " ItLocalVariableReadNode\n\n Represents reading from the implicit `it` local variable.\n\n     -> { it }\n          ^^\n\n Type: ::PM_IT_LOCAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_it_local_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_it_local_variable_read_node"]
        [::std::mem::size_of::<pm_it_local_variable_read_node>() - 16usize];
    ["Alignment of pm_it_local_variable_read_node"]
        [::std::mem::align_of::<pm_it_local_variable_read_node>() - 4usize];
    ["Offset of field: pm_it_local_variable_read_node::base"]
        [::std::mem::offset_of!(pm_it_local_variable_read_node, base) - 0usize];
};
#[doc = " ItLocalVariableReadNode\n\n Represents reading from the implicit `it` local variable.\n\n     -> { it }\n          ^^\n\n Type: ::PM_IT_LOCAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_it_local_variable_read_node_t = pm_it_local_variable_read_node;
#[doc = " ItParametersNode\n\n Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.\n\n     -> { it + it }\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_IT_PARAMETERS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_it_parameters_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_it_parameters_node"][::std::mem::size_of::<pm_it_parameters_node>() - 16usize];
    ["Alignment of pm_it_parameters_node"]
        [::std::mem::align_of::<pm_it_parameters_node>() - 4usize];
    ["Offset of field: pm_it_parameters_node::base"]
        [::std::mem::offset_of!(pm_it_parameters_node, base) - 0usize];
};
#[doc = " ItParametersNode\n\n Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.\n\n     -> { it + it }\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_IT_PARAMETERS_NODE\n\n @extends pm_node_t"]
pub type pm_it_parameters_node_t = pm_it_parameters_node;
#[doc = " KeywordHashNode\n\n Represents a hash literal without opening and closing braces.\n\n     foo(a: b)\n         ^^^^\n\n Type: ::PM_KEYWORD_HASH_NODE\n\n Flags (#pm_keyword_hash_node_flags):\n * ::PM_KEYWORD_HASH_NODE_FLAGS_SYMBOL_KEYS\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_keyword_hash_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " KeywordHashNode#elements"]
    pub elements: pm_node_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_keyword_hash_node"][::std::mem::size_of::<pm_keyword_hash_node>() - 28usize];
    ["Alignment of pm_keyword_hash_node"][::std::mem::align_of::<pm_keyword_hash_node>() - 4usize];
    ["Offset of field: pm_keyword_hash_node::base"]
        [::std::mem::offset_of!(pm_keyword_hash_node, base) - 0usize];
    ["Offset of field: pm_keyword_hash_node::elements"]
        [::std::mem::offset_of!(pm_keyword_hash_node, elements) - 16usize];
};
#[doc = " KeywordHashNode\n\n Represents a hash literal without opening and closing braces.\n\n     foo(a: b)\n         ^^^^\n\n Type: ::PM_KEYWORD_HASH_NODE\n\n Flags (#pm_keyword_hash_node_flags):\n * ::PM_KEYWORD_HASH_NODE_FLAGS_SYMBOL_KEYS\n\n @extends pm_node_t"]
pub type pm_keyword_hash_node_t = pm_keyword_hash_node;
#[doc = " KeywordRestParameterNode\n\n Represents a keyword rest parameter to a method, block, or lambda definition.\n\n     def a(**b)\n           ^^^\n     end\n\n Type: ::PM_KEYWORD_REST_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_keyword_rest_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " KeywordRestParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " KeywordRestParameterNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " KeywordRestParameterNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_keyword_rest_parameter_node"]
        [::std::mem::size_of::<pm_keyword_rest_parameter_node>() - 36usize];
    ["Alignment of pm_keyword_rest_parameter_node"]
        [::std::mem::align_of::<pm_keyword_rest_parameter_node>() - 4usize];
    ["Offset of field: pm_keyword_rest_parameter_node::base"]
        [::std::mem::offset_of!(pm_keyword_rest_parameter_node, base) - 0usize];
    ["Offset of field: pm_keyword_rest_parameter_node::name"]
        [::std::mem::offset_of!(pm_keyword_rest_parameter_node, name) - 16usize];
    ["Offset of field: pm_keyword_rest_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_keyword_rest_parameter_node, name_loc) - 20usize];
    ["Offset of field: pm_keyword_rest_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_keyword_rest_parameter_node, operator_loc) - 28usize];
};
#[doc = " KeywordRestParameterNode\n\n Represents a keyword rest parameter to a method, block, or lambda definition.\n\n     def a(**b)\n           ^^^\n     end\n\n Type: ::PM_KEYWORD_REST_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_keyword_rest_parameter_node_t = pm_keyword_rest_parameter_node;
#[doc = " LambdaNode\n\n Represents using a lambda literal (not the lambda method call).\n\n     ->(value) { value * 2 }\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_LAMBDA_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lambda_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LambdaNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " LambdaNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " LambdaNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " LambdaNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " LambdaNode#parameters"]
    pub parameters: *mut pm_node,
    #[doc = " LambdaNode#body"]
    pub body: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lambda_node"][::std::mem::size_of::<pm_lambda_node>() - 60usize];
    ["Alignment of pm_lambda_node"][::std::mem::align_of::<pm_lambda_node>() - 4usize];
    ["Offset of field: pm_lambda_node::base"]
        [::std::mem::offset_of!(pm_lambda_node, base) - 0usize];
    ["Offset of field: pm_lambda_node::locals"]
        [::std::mem::offset_of!(pm_lambda_node, locals) - 16usize];
    ["Offset of field: pm_lambda_node::operator_loc"]
        [::std::mem::offset_of!(pm_lambda_node, operator_loc) - 28usize];
    ["Offset of field: pm_lambda_node::opening_loc"]
        [::std::mem::offset_of!(pm_lambda_node, opening_loc) - 36usize];
    ["Offset of field: pm_lambda_node::closing_loc"]
        [::std::mem::offset_of!(pm_lambda_node, closing_loc) - 44usize];
    ["Offset of field: pm_lambda_node::parameters"]
        [::std::mem::offset_of!(pm_lambda_node, parameters) - 52usize];
    ["Offset of field: pm_lambda_node::body"]
        [::std::mem::offset_of!(pm_lambda_node, body) - 56usize];
};
#[doc = " LambdaNode\n\n Represents using a lambda literal (not the lambda method call).\n\n     ->(value) { value * 2 }\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_LAMBDA_NODE\n\n @extends pm_node_t"]
pub type pm_lambda_node_t = pm_lambda_node;
#[doc = " LocalVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a local variable.\n\n     target &&= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_and_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableAndWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " LocalVariableAndWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " LocalVariableAndWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " LocalVariableAndWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableAndWriteNode#depth"]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_and_write_node"]
        [::std::mem::size_of::<pm_local_variable_and_write_node>() - 44usize];
    ["Alignment of pm_local_variable_and_write_node"]
        [::std::mem::align_of::<pm_local_variable_and_write_node>() - 4usize];
    ["Offset of field: pm_local_variable_and_write_node::base"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, base) - 0usize];
    ["Offset of field: pm_local_variable_and_write_node::name_loc"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, name_loc) - 16usize];
    ["Offset of field: pm_local_variable_and_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, operator_loc) - 24usize];
    ["Offset of field: pm_local_variable_and_write_node::value"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, value) - 32usize];
    ["Offset of field: pm_local_variable_and_write_node::name"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, name) - 36usize];
    ["Offset of field: pm_local_variable_and_write_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_and_write_node, depth) - 40usize];
};
#[doc = " LocalVariableAndWriteNode\n\n Represents the use of the `&&=` operator for assignment to a local variable.\n\n     target &&= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_AND_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_and_write_node_t = pm_local_variable_and_write_node;
#[doc = " LocalVariableOperatorWriteNode\n\n Represents assigning to a local variable using an operator that isn't `=`.\n\n     target += value\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_operator_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableOperatorWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " LocalVariableOperatorWriteNode#binary_operator_loc"]
    pub binary_operator_loc: pm_location_t,
    #[doc = " LocalVariableOperatorWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " LocalVariableOperatorWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableOperatorWriteNode#binary_operator"]
    pub binary_operator: pm_constant_id_t,
    #[doc = " LocalVariableOperatorWriteNode#depth"]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_operator_write_node"]
        [::std::mem::size_of::<pm_local_variable_operator_write_node>() - 48usize];
    ["Alignment of pm_local_variable_operator_write_node"]
        [::std::mem::align_of::<pm_local_variable_operator_write_node>() - 4usize];
    ["Offset of field: pm_local_variable_operator_write_node::base"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, base) - 0usize];
    ["Offset of field: pm_local_variable_operator_write_node::name_loc"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, name_loc) - 16usize];
    ["Offset of field: pm_local_variable_operator_write_node::binary_operator_loc"][::std::mem::offset_of!(
        pm_local_variable_operator_write_node,
        binary_operator_loc
    ) - 24usize];
    ["Offset of field: pm_local_variable_operator_write_node::value"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, value) - 32usize];
    ["Offset of field: pm_local_variable_operator_write_node::name"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, name) - 36usize];
    ["Offset of field: pm_local_variable_operator_write_node::binary_operator"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, binary_operator) - 40usize];
    ["Offset of field: pm_local_variable_operator_write_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_operator_write_node, depth) - 44usize];
};
#[doc = " LocalVariableOperatorWriteNode\n\n Represents assigning to a local variable using an operator that isn't `=`.\n\n     target += value\n     ^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_OPERATOR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_operator_write_node_t = pm_local_variable_operator_write_node;
#[doc = " LocalVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a local variable.\n\n     target ||= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_or_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableOrWriteNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " LocalVariableOrWriteNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " LocalVariableOrWriteNode#value"]
    pub value: *mut pm_node,
    #[doc = " LocalVariableOrWriteNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableOrWriteNode#depth"]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_or_write_node"]
        [::std::mem::size_of::<pm_local_variable_or_write_node>() - 44usize];
    ["Alignment of pm_local_variable_or_write_node"]
        [::std::mem::align_of::<pm_local_variable_or_write_node>() - 4usize];
    ["Offset of field: pm_local_variable_or_write_node::base"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, base) - 0usize];
    ["Offset of field: pm_local_variable_or_write_node::name_loc"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, name_loc) - 16usize];
    ["Offset of field: pm_local_variable_or_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, operator_loc) - 24usize];
    ["Offset of field: pm_local_variable_or_write_node::value"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, value) - 32usize];
    ["Offset of field: pm_local_variable_or_write_node::name"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, name) - 36usize];
    ["Offset of field: pm_local_variable_or_write_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_or_write_node, depth) - 40usize];
};
#[doc = " LocalVariableOrWriteNode\n\n Represents the use of the `||=` operator for assignment to a local variable.\n\n     target ||= value\n     ^^^^^^^^^^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_OR_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_or_write_node_t = pm_local_variable_or_write_node;
#[doc = " LocalVariableReadNode\n\n Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.\n\n     foo\n     ^^^\n\n Type: ::PM_LOCAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableReadNode#name\n\n The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     x      # name `:x`\n\n     _Test  # name `:_Test`\n\n Note that this can also be an underscore followed by a number for the default block parameters.\n\n     _1     # name `:_1`"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableReadNode#depth\n\n The number of visible scopes that should be searched to find the origin of this local variable.\n\n     foo = 1; foo # depth 0\n\n     bar = 2; tap { bar } # depth 1\n\n The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md)."]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_read_node"]
        [::std::mem::size_of::<pm_local_variable_read_node>() - 24usize];
    ["Alignment of pm_local_variable_read_node"]
        [::std::mem::align_of::<pm_local_variable_read_node>() - 4usize];
    ["Offset of field: pm_local_variable_read_node::base"]
        [::std::mem::offset_of!(pm_local_variable_read_node, base) - 0usize];
    ["Offset of field: pm_local_variable_read_node::name"]
        [::std::mem::offset_of!(pm_local_variable_read_node, name) - 16usize];
    ["Offset of field: pm_local_variable_read_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_read_node, depth) - 20usize];
};
#[doc = " LocalVariableReadNode\n\n Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.\n\n     foo\n     ^^^\n\n Type: ::PM_LOCAL_VARIABLE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_read_node_t = pm_local_variable_read_node;
#[doc = " LocalVariableTargetNode\n\n Represents writing to a local variable in a context that doesn't have an explicit value.\n\n     foo, bar = baz\n     ^^^  ^^^\n\n Type: ::PM_LOCAL_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableTargetNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableTargetNode#depth"]
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_target_node"]
        [::std::mem::size_of::<pm_local_variable_target_node>() - 24usize];
    ["Alignment of pm_local_variable_target_node"]
        [::std::mem::align_of::<pm_local_variable_target_node>() - 4usize];
    ["Offset of field: pm_local_variable_target_node::base"]
        [::std::mem::offset_of!(pm_local_variable_target_node, base) - 0usize];
    ["Offset of field: pm_local_variable_target_node::name"]
        [::std::mem::offset_of!(pm_local_variable_target_node, name) - 16usize];
    ["Offset of field: pm_local_variable_target_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_target_node, depth) - 20usize];
};
#[doc = " LocalVariableTargetNode\n\n Represents writing to a local variable in a context that doesn't have an explicit value.\n\n     foo, bar = baz\n     ^^^  ^^^\n\n Type: ::PM_LOCAL_VARIABLE_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_target_node_t = pm_local_variable_target_node;
#[doc = " LocalVariableWriteNode\n\n Represents writing to a local variable.\n\n     foo = 1\n     ^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_variable_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " LocalVariableWriteNode#name\n\n The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).\n\n     foo = :bar # name `:foo`\n\n     abc = 123  # name `:abc`"]
    pub name: pm_constant_id_t,
    #[doc = " LocalVariableWriteNode#depth\n\n The number of semantic scopes we have to traverse to find the declaration of this variable.\n\n     foo = 1         # depth 0\n\n     tap { foo = 1 } # depth 1\n\n The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md)."]
    pub depth: u32,
    #[doc = " LocalVariableWriteNode#name_loc\n\n The location of the variable name.\n\n     foo = :bar\n     ^^^"]
    pub name_loc: pm_location_t,
    #[doc = " LocalVariableWriteNode#value\n\n The value to write to the local variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     foo = :bar\n           ^^^^\n\n     abc = 1234\n           ^^^^\n\n Note that since the name of a local variable is known before the value is parsed, it is valid for a local variable to appear within the value of its own write.\n\n     foo = foo"]
    pub value: *mut pm_node,
    #[doc = " LocalVariableWriteNode#operator_loc\n\n The location of the `=` operator.\n\n     x = :y\n       ^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_variable_write_node"]
        [::std::mem::size_of::<pm_local_variable_write_node>() - 44usize];
    ["Alignment of pm_local_variable_write_node"]
        [::std::mem::align_of::<pm_local_variable_write_node>() - 4usize];
    ["Offset of field: pm_local_variable_write_node::base"]
        [::std::mem::offset_of!(pm_local_variable_write_node, base) - 0usize];
    ["Offset of field: pm_local_variable_write_node::name"]
        [::std::mem::offset_of!(pm_local_variable_write_node, name) - 16usize];
    ["Offset of field: pm_local_variable_write_node::depth"]
        [::std::mem::offset_of!(pm_local_variable_write_node, depth) - 20usize];
    ["Offset of field: pm_local_variable_write_node::name_loc"]
        [::std::mem::offset_of!(pm_local_variable_write_node, name_loc) - 24usize];
    ["Offset of field: pm_local_variable_write_node::value"]
        [::std::mem::offset_of!(pm_local_variable_write_node, value) - 32usize];
    ["Offset of field: pm_local_variable_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_local_variable_write_node, operator_loc) - 36usize];
};
#[doc = " LocalVariableWriteNode\n\n Represents writing to a local variable.\n\n     foo = 1\n     ^^^^^^^\n\n Type: ::PM_LOCAL_VARIABLE_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_local_variable_write_node_t = pm_local_variable_write_node;
#[doc = " MatchLastLineNode\n\n Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.\n\n     if /foo/i then end\n        ^^^^^^\n\n Type: ::PM_MATCH_LAST_LINE_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_match_last_line_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MatchLastLineNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " MatchLastLineNode#content_loc"]
    pub content_loc: pm_location_t,
    #[doc = " MatchLastLineNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " MatchLastLineNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_match_last_line_node"][::std::mem::size_of::<pm_match_last_line_node>() - 52usize];
    ["Alignment of pm_match_last_line_node"]
        [::std::mem::align_of::<pm_match_last_line_node>() - 4usize];
    ["Offset of field: pm_match_last_line_node::base"]
        [::std::mem::offset_of!(pm_match_last_line_node, base) - 0usize];
    ["Offset of field: pm_match_last_line_node::opening_loc"]
        [::std::mem::offset_of!(pm_match_last_line_node, opening_loc) - 16usize];
    ["Offset of field: pm_match_last_line_node::content_loc"]
        [::std::mem::offset_of!(pm_match_last_line_node, content_loc) - 24usize];
    ["Offset of field: pm_match_last_line_node::closing_loc"]
        [::std::mem::offset_of!(pm_match_last_line_node, closing_loc) - 32usize];
    ["Offset of field: pm_match_last_line_node::unescaped"]
        [::std::mem::offset_of!(pm_match_last_line_node, unescaped) - 40usize];
};
#[doc = " MatchLastLineNode\n\n Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.\n\n     if /foo/i then end\n        ^^^^^^\n\n Type: ::PM_MATCH_LAST_LINE_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_match_last_line_node_t = pm_match_last_line_node;
#[doc = " MatchPredicateNode\n\n Represents the use of the modifier `in` operator.\n\n     foo in bar\n     ^^^^^^^^^^\n\n Type: ::PM_MATCH_PREDICATE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_match_predicate_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MatchPredicateNode#value"]
    pub value: *mut pm_node,
    #[doc = " MatchPredicateNode#pattern"]
    pub pattern: *mut pm_node,
    #[doc = " MatchPredicateNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_match_predicate_node"][::std::mem::size_of::<pm_match_predicate_node>() - 32usize];
    ["Alignment of pm_match_predicate_node"]
        [::std::mem::align_of::<pm_match_predicate_node>() - 4usize];
    ["Offset of field: pm_match_predicate_node::base"]
        [::std::mem::offset_of!(pm_match_predicate_node, base) - 0usize];
    ["Offset of field: pm_match_predicate_node::value"]
        [::std::mem::offset_of!(pm_match_predicate_node, value) - 16usize];
    ["Offset of field: pm_match_predicate_node::pattern"]
        [::std::mem::offset_of!(pm_match_predicate_node, pattern) - 20usize];
    ["Offset of field: pm_match_predicate_node::operator_loc"]
        [::std::mem::offset_of!(pm_match_predicate_node, operator_loc) - 24usize];
};
#[doc = " MatchPredicateNode\n\n Represents the use of the modifier `in` operator.\n\n     foo in bar\n     ^^^^^^^^^^\n\n Type: ::PM_MATCH_PREDICATE_NODE\n\n @extends pm_node_t"]
pub type pm_match_predicate_node_t = pm_match_predicate_node;
#[doc = " MatchRequiredNode\n\n Represents the use of the `=>` operator.\n\n     foo => bar\n     ^^^^^^^^^^\n\n Type: ::PM_MATCH_REQUIRED_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_match_required_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MatchRequiredNode#value"]
    pub value: *mut pm_node,
    #[doc = " MatchRequiredNode#pattern"]
    pub pattern: *mut pm_node,
    #[doc = " MatchRequiredNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_match_required_node"][::std::mem::size_of::<pm_match_required_node>() - 32usize];
    ["Alignment of pm_match_required_node"]
        [::std::mem::align_of::<pm_match_required_node>() - 4usize];
    ["Offset of field: pm_match_required_node::base"]
        [::std::mem::offset_of!(pm_match_required_node, base) - 0usize];
    ["Offset of field: pm_match_required_node::value"]
        [::std::mem::offset_of!(pm_match_required_node, value) - 16usize];
    ["Offset of field: pm_match_required_node::pattern"]
        [::std::mem::offset_of!(pm_match_required_node, pattern) - 20usize];
    ["Offset of field: pm_match_required_node::operator_loc"]
        [::std::mem::offset_of!(pm_match_required_node, operator_loc) - 24usize];
};
#[doc = " MatchRequiredNode\n\n Represents the use of the `=>` operator.\n\n     foo => bar\n     ^^^^^^^^^^\n\n Type: ::PM_MATCH_REQUIRED_NODE\n\n @extends pm_node_t"]
pub type pm_match_required_node_t = pm_match_required_node;
#[doc = " MatchWriteNode\n\n Represents writing local variables using a regular expression match with named capture groups.\n\n     /(?<foo>bar)/ =~ baz\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_MATCH_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_match_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MatchWriteNode#call"]
    pub call: *mut pm_call_node,
    #[doc = " MatchWriteNode#targets"]
    pub targets: pm_node_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_match_write_node"][::std::mem::size_of::<pm_match_write_node>() - 32usize];
    ["Alignment of pm_match_write_node"][::std::mem::align_of::<pm_match_write_node>() - 4usize];
    ["Offset of field: pm_match_write_node::base"]
        [::std::mem::offset_of!(pm_match_write_node, base) - 0usize];
    ["Offset of field: pm_match_write_node::call"]
        [::std::mem::offset_of!(pm_match_write_node, call) - 16usize];
    ["Offset of field: pm_match_write_node::targets"]
        [::std::mem::offset_of!(pm_match_write_node, targets) - 20usize];
};
#[doc = " MatchWriteNode\n\n Represents writing local variables using a regular expression match with named capture groups.\n\n     /(?<foo>bar)/ =~ baz\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_MATCH_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_match_write_node_t = pm_match_write_node;
#[doc = " MissingNode\n\n Represents a node that is missing from the source and results in a syntax error.\n\n Type: ::PM_MISSING_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_missing_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_missing_node"][::std::mem::size_of::<pm_missing_node>() - 16usize];
    ["Alignment of pm_missing_node"][::std::mem::align_of::<pm_missing_node>() - 4usize];
    ["Offset of field: pm_missing_node::base"]
        [::std::mem::offset_of!(pm_missing_node, base) - 0usize];
};
#[doc = " MissingNode\n\n Represents a node that is missing from the source and results in a syntax error.\n\n Type: ::PM_MISSING_NODE\n\n @extends pm_node_t"]
pub type pm_missing_node_t = pm_missing_node;
#[doc = " ModuleNode\n\n Represents a module declaration involving the `module` keyword.\n\n     module Foo end\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_MODULE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_module_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ModuleNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " ModuleNode#module_keyword_loc"]
    pub module_keyword_loc: pm_location_t,
    #[doc = " ModuleNode#constant_path"]
    pub constant_path: *mut pm_node,
    #[doc = " ModuleNode#body"]
    pub body: *mut pm_node,
    #[doc = " ModuleNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
    #[doc = " ModuleNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_module_node"][::std::mem::size_of::<pm_module_node>() - 56usize];
    ["Alignment of pm_module_node"][::std::mem::align_of::<pm_module_node>() - 4usize];
    ["Offset of field: pm_module_node::base"]
        [::std::mem::offset_of!(pm_module_node, base) - 0usize];
    ["Offset of field: pm_module_node::locals"]
        [::std::mem::offset_of!(pm_module_node, locals) - 16usize];
    ["Offset of field: pm_module_node::module_keyword_loc"]
        [::std::mem::offset_of!(pm_module_node, module_keyword_loc) - 28usize];
    ["Offset of field: pm_module_node::constant_path"]
        [::std::mem::offset_of!(pm_module_node, constant_path) - 36usize];
    ["Offset of field: pm_module_node::body"]
        [::std::mem::offset_of!(pm_module_node, body) - 40usize];
    ["Offset of field: pm_module_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_module_node, end_keyword_loc) - 44usize];
    ["Offset of field: pm_module_node::name"]
        [::std::mem::offset_of!(pm_module_node, name) - 52usize];
};
#[doc = " ModuleNode\n\n Represents a module declaration involving the `module` keyword.\n\n     module Foo end\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_MODULE_NODE\n\n @extends pm_node_t"]
pub type pm_module_node_t = pm_module_node;
#[doc = " MultiTargetNode\n\n Represents a multi-target expression.\n\n     a, (b, c) = 1, 2, 3\n        ^^^^^^\n\n This can be a part of `MultiWriteNode` as above, or the target of a `for` loop\n\n     for a, b in [[1, 2], [3, 4]]\n         ^^^^\n\n Type: ::PM_MULTI_TARGET_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_multi_target_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MultiTargetNode#lefts\n\n Represents the targets expressions before a splat node.\n\n     a, (b, c, *) = 1, 2, 3, 4, 5\n         ^^^^\n\n The splat node can be absent, in that case all target expressions are in the left field.\n\n     a, (b, c) = 1, 2, 3, 4, 5\n         ^^^^"]
    pub lefts: pm_node_list,
    #[doc = " MultiTargetNode#rest\n\n Represents a splat node in the target expression.\n\n     a, (b, *c) = 1, 2, 3, 4\n            ^^\n\n The variable can be empty, this results in a `SplatNode` with a `nil` expression field.\n\n     a, (b, *) = 1, 2, 3, 4\n            ^\n\n If the `*` is omitted, this field will contain an `ImplicitRestNode`\n\n     a, (b,) = 1, 2, 3, 4\n          ^"]
    pub rest: *mut pm_node,
    #[doc = " MultiTargetNode#rights\n\n Represents the targets expressions after a splat node.\n\n     a, (*, b, c) = 1, 2, 3, 4, 5\n            ^^^^"]
    pub rights: pm_node_list,
    #[doc = " MultiTargetNode#lparen_loc\n\n The location of the opening parenthesis.\n\n     a, (b, c) = 1, 2, 3\n        ^"]
    pub lparen_loc: pm_location_t,
    #[doc = " MultiTargetNode#rparen_loc\n\n The location of the closing parenthesis.\n\n     a, (b, c) = 1, 2, 3\n             ^"]
    pub rparen_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_multi_target_node"][::std::mem::size_of::<pm_multi_target_node>() - 60usize];
    ["Alignment of pm_multi_target_node"][::std::mem::align_of::<pm_multi_target_node>() - 4usize];
    ["Offset of field: pm_multi_target_node::base"]
        [::std::mem::offset_of!(pm_multi_target_node, base) - 0usize];
    ["Offset of field: pm_multi_target_node::lefts"]
        [::std::mem::offset_of!(pm_multi_target_node, lefts) - 16usize];
    ["Offset of field: pm_multi_target_node::rest"]
        [::std::mem::offset_of!(pm_multi_target_node, rest) - 28usize];
    ["Offset of field: pm_multi_target_node::rights"]
        [::std::mem::offset_of!(pm_multi_target_node, rights) - 32usize];
    ["Offset of field: pm_multi_target_node::lparen_loc"]
        [::std::mem::offset_of!(pm_multi_target_node, lparen_loc) - 44usize];
    ["Offset of field: pm_multi_target_node::rparen_loc"]
        [::std::mem::offset_of!(pm_multi_target_node, rparen_loc) - 52usize];
};
#[doc = " MultiTargetNode\n\n Represents a multi-target expression.\n\n     a, (b, c) = 1, 2, 3\n        ^^^^^^\n\n This can be a part of `MultiWriteNode` as above, or the target of a `for` loop\n\n     for a, b in [[1, 2], [3, 4]]\n         ^^^^\n\n Type: ::PM_MULTI_TARGET_NODE\n\n @extends pm_node_t"]
pub type pm_multi_target_node_t = pm_multi_target_node;
#[doc = " MultiWriteNode\n\n Represents a write to a multi-target expression.\n\n     a, b, c = 1, 2, 3\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_MULTI_WRITE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_multi_write_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " MultiWriteNode#lefts\n\n Represents the targets expressions before a splat node.\n\n     a, b, * = 1, 2, 3, 4, 5\n     ^^^^\n\n The splat node can be absent, in that case all target expressions are in the left field.\n\n     a, b, c = 1, 2, 3, 4, 5\n     ^^^^^^^"]
    pub lefts: pm_node_list,
    #[doc = " MultiWriteNode#rest\n\n Represents a splat node in the target expression.\n\n     a, b, *c = 1, 2, 3, 4\n           ^^\n\n The variable can be empty, this results in a `SplatNode` with a `nil` expression field.\n\n     a, b, * = 1, 2, 3, 4\n           ^\n\n If the `*` is omitted, this field will contain an `ImplicitRestNode`\n\n     a, b, = 1, 2, 3, 4\n         ^"]
    pub rest: *mut pm_node,
    #[doc = " MultiWriteNode#rights\n\n Represents the targets expressions after a splat node.\n\n     a, *, b, c = 1, 2, 3, 4, 5\n           ^^^^"]
    pub rights: pm_node_list,
    #[doc = " MultiWriteNode#lparen_loc\n\n The location of the opening parenthesis.\n\n     (a, b, c) = 1, 2, 3\n     ^"]
    pub lparen_loc: pm_location_t,
    #[doc = " MultiWriteNode#rparen_loc\n\n The location of the closing parenthesis.\n\n     (a, b, c) = 1, 2, 3\n             ^"]
    pub rparen_loc: pm_location_t,
    #[doc = " MultiWriteNode#operator_loc\n\n The location of the operator.\n\n     a, b, c = 1, 2, 3\n             ^"]
    pub operator_loc: pm_location_t,
    #[doc = " MultiWriteNode#value\n\n The value to write to the targets. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     a, b, c = 1, 2, 3\n               ^^^^^^^"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_multi_write_node"][::std::mem::size_of::<pm_multi_write_node>() - 72usize];
    ["Alignment of pm_multi_write_node"][::std::mem::align_of::<pm_multi_write_node>() - 4usize];
    ["Offset of field: pm_multi_write_node::base"]
        [::std::mem::offset_of!(pm_multi_write_node, base) - 0usize];
    ["Offset of field: pm_multi_write_node::lefts"]
        [::std::mem::offset_of!(pm_multi_write_node, lefts) - 16usize];
    ["Offset of field: pm_multi_write_node::rest"]
        [::std::mem::offset_of!(pm_multi_write_node, rest) - 28usize];
    ["Offset of field: pm_multi_write_node::rights"]
        [::std::mem::offset_of!(pm_multi_write_node, rights) - 32usize];
    ["Offset of field: pm_multi_write_node::lparen_loc"]
        [::std::mem::offset_of!(pm_multi_write_node, lparen_loc) - 44usize];
    ["Offset of field: pm_multi_write_node::rparen_loc"]
        [::std::mem::offset_of!(pm_multi_write_node, rparen_loc) - 52usize];
    ["Offset of field: pm_multi_write_node::operator_loc"]
        [::std::mem::offset_of!(pm_multi_write_node, operator_loc) - 60usize];
    ["Offset of field: pm_multi_write_node::value"]
        [::std::mem::offset_of!(pm_multi_write_node, value) - 68usize];
};
#[doc = " MultiWriteNode\n\n Represents a write to a multi-target expression.\n\n     a, b, c = 1, 2, 3\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_MULTI_WRITE_NODE\n\n @extends pm_node_t"]
pub type pm_multi_write_node_t = pm_multi_write_node;
#[doc = " NextNode\n\n Represents the use of the `next` keyword.\n\n     next 1\n     ^^^^^^\n\n Type: ::PM_NEXT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_next_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " NextNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " NextNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_next_node"][::std::mem::size_of::<pm_next_node>() - 28usize];
    ["Alignment of pm_next_node"][::std::mem::align_of::<pm_next_node>() - 4usize];
    ["Offset of field: pm_next_node::base"][::std::mem::offset_of!(pm_next_node, base) - 0usize];
    ["Offset of field: pm_next_node::arguments"]
        [::std::mem::offset_of!(pm_next_node, arguments) - 16usize];
    ["Offset of field: pm_next_node::keyword_loc"]
        [::std::mem::offset_of!(pm_next_node, keyword_loc) - 20usize];
};
#[doc = " NextNode\n\n Represents the use of the `next` keyword.\n\n     next 1\n     ^^^^^^\n\n Type: ::PM_NEXT_NODE\n\n @extends pm_node_t"]
pub type pm_next_node_t = pm_next_node;
#[doc = " NilNode\n\n Represents the use of the `nil` keyword.\n\n     nil\n     ^^^\n\n Type: ::PM_NIL_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_nil_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_nil_node"][::std::mem::size_of::<pm_nil_node>() - 16usize];
    ["Alignment of pm_nil_node"][::std::mem::align_of::<pm_nil_node>() - 4usize];
    ["Offset of field: pm_nil_node::base"][::std::mem::offset_of!(pm_nil_node, base) - 0usize];
};
#[doc = " NilNode\n\n Represents the use of the `nil` keyword.\n\n     nil\n     ^^^\n\n Type: ::PM_NIL_NODE\n\n @extends pm_node_t"]
pub type pm_nil_node_t = pm_nil_node;
#[doc = " NoKeywordsParameterNode\n\n Represents the use of `**nil` inside method arguments.\n\n     def a(**nil)\n           ^^^^^\n     end\n\n Type: ::PM_NO_KEYWORDS_PARAMETER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_no_keywords_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " NoKeywordsParameterNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " NoKeywordsParameterNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_no_keywords_parameter_node"]
        [::std::mem::size_of::<pm_no_keywords_parameter_node>() - 32usize];
    ["Alignment of pm_no_keywords_parameter_node"]
        [::std::mem::align_of::<pm_no_keywords_parameter_node>() - 4usize];
    ["Offset of field: pm_no_keywords_parameter_node::base"]
        [::std::mem::offset_of!(pm_no_keywords_parameter_node, base) - 0usize];
    ["Offset of field: pm_no_keywords_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_no_keywords_parameter_node, operator_loc) - 16usize];
    ["Offset of field: pm_no_keywords_parameter_node::keyword_loc"]
        [::std::mem::offset_of!(pm_no_keywords_parameter_node, keyword_loc) - 24usize];
};
#[doc = " NoKeywordsParameterNode\n\n Represents the use of `**nil` inside method arguments.\n\n     def a(**nil)\n           ^^^^^\n     end\n\n Type: ::PM_NO_KEYWORDS_PARAMETER_NODE\n\n @extends pm_node_t"]
pub type pm_no_keywords_parameter_node_t = pm_no_keywords_parameter_node;
#[doc = " NumberedParametersNode\n\n Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.\n\n     -> { _1 + _2 }\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_NUMBERED_PARAMETERS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_numbered_parameters_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " NumberedParametersNode#maximum"]
    pub maximum: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_numbered_parameters_node"]
        [::std::mem::size_of::<pm_numbered_parameters_node>() - 20usize];
    ["Alignment of pm_numbered_parameters_node"]
        [::std::mem::align_of::<pm_numbered_parameters_node>() - 4usize];
    ["Offset of field: pm_numbered_parameters_node::base"]
        [::std::mem::offset_of!(pm_numbered_parameters_node, base) - 0usize];
    ["Offset of field: pm_numbered_parameters_node::maximum"]
        [::std::mem::offset_of!(pm_numbered_parameters_node, maximum) - 16usize];
};
#[doc = " NumberedParametersNode\n\n Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.\n\n     -> { _1 + _2 }\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_NUMBERED_PARAMETERS_NODE\n\n @extends pm_node_t"]
pub type pm_numbered_parameters_node_t = pm_numbered_parameters_node;
#[doc = " NumberedReferenceReadNode\n\n Represents reading a numbered reference to a capture in the previous match.\n\n     $1\n     ^^\n\n Type: ::PM_NUMBERED_REFERENCE_READ_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_numbered_reference_read_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " NumberedReferenceReadNode#number\n\n The (1-indexed, from the left) number of the capture group. Numbered references that are too large result in this value being `0`.\n\n     $1          # number `1`\n\n     $5432       # number `5432`\n\n     $4294967296 # number `0`"]
    pub number: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_numbered_reference_read_node"]
        [::std::mem::size_of::<pm_numbered_reference_read_node>() - 20usize];
    ["Alignment of pm_numbered_reference_read_node"]
        [::std::mem::align_of::<pm_numbered_reference_read_node>() - 4usize];
    ["Offset of field: pm_numbered_reference_read_node::base"]
        [::std::mem::offset_of!(pm_numbered_reference_read_node, base) - 0usize];
    ["Offset of field: pm_numbered_reference_read_node::number"]
        [::std::mem::offset_of!(pm_numbered_reference_read_node, number) - 16usize];
};
#[doc = " NumberedReferenceReadNode\n\n Represents reading a numbered reference to a capture in the previous match.\n\n     $1\n     ^^\n\n Type: ::PM_NUMBERED_REFERENCE_READ_NODE\n\n @extends pm_node_t"]
pub type pm_numbered_reference_read_node_t = pm_numbered_reference_read_node;
#[doc = " OptionalKeywordParameterNode\n\n Represents an optional keyword parameter to a method, block, or lambda definition.\n\n     def a(b: 1)\n           ^^^^\n     end\n\n Type: ::PM_OPTIONAL_KEYWORD_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_optional_keyword_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " OptionalKeywordParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " OptionalKeywordParameterNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " OptionalKeywordParameterNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_optional_keyword_parameter_node"]
        [::std::mem::size_of::<pm_optional_keyword_parameter_node>() - 32usize];
    ["Alignment of pm_optional_keyword_parameter_node"]
        [::std::mem::align_of::<pm_optional_keyword_parameter_node>() - 4usize];
    ["Offset of field: pm_optional_keyword_parameter_node::base"]
        [::std::mem::offset_of!(pm_optional_keyword_parameter_node, base) - 0usize];
    ["Offset of field: pm_optional_keyword_parameter_node::name"]
        [::std::mem::offset_of!(pm_optional_keyword_parameter_node, name) - 16usize];
    ["Offset of field: pm_optional_keyword_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_optional_keyword_parameter_node, name_loc) - 20usize];
    ["Offset of field: pm_optional_keyword_parameter_node::value"]
        [::std::mem::offset_of!(pm_optional_keyword_parameter_node, value) - 28usize];
};
#[doc = " OptionalKeywordParameterNode\n\n Represents an optional keyword parameter to a method, block, or lambda definition.\n\n     def a(b: 1)\n           ^^^^\n     end\n\n Type: ::PM_OPTIONAL_KEYWORD_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_optional_keyword_parameter_node_t = pm_optional_keyword_parameter_node;
#[doc = " OptionalParameterNode\n\n Represents an optional parameter to a method, block, or lambda definition.\n\n     def a(b = 1)\n           ^^^^^\n     end\n\n Type: ::PM_OPTIONAL_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_optional_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " OptionalParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " OptionalParameterNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " OptionalParameterNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " OptionalParameterNode#value"]
    pub value: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_optional_parameter_node"]
        [::std::mem::size_of::<pm_optional_parameter_node>() - 40usize];
    ["Alignment of pm_optional_parameter_node"]
        [::std::mem::align_of::<pm_optional_parameter_node>() - 4usize];
    ["Offset of field: pm_optional_parameter_node::base"]
        [::std::mem::offset_of!(pm_optional_parameter_node, base) - 0usize];
    ["Offset of field: pm_optional_parameter_node::name"]
        [::std::mem::offset_of!(pm_optional_parameter_node, name) - 16usize];
    ["Offset of field: pm_optional_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_optional_parameter_node, name_loc) - 20usize];
    ["Offset of field: pm_optional_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_optional_parameter_node, operator_loc) - 28usize];
    ["Offset of field: pm_optional_parameter_node::value"]
        [::std::mem::offset_of!(pm_optional_parameter_node, value) - 36usize];
};
#[doc = " OptionalParameterNode\n\n Represents an optional parameter to a method, block, or lambda definition.\n\n     def a(b = 1)\n           ^^^^^\n     end\n\n Type: ::PM_OPTIONAL_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_optional_parameter_node_t = pm_optional_parameter_node;
#[doc = " OrNode\n\n Represents the use of the `||` operator or the `or` keyword.\n\n     left or right\n     ^^^^^^^^^^^^^\n\n Type: ::PM_OR_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_or_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " OrNode#left\n\n Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     left or right\n     ^^^^\n\n     1 || 2\n     ^"]
    pub left: *mut pm_node,
    #[doc = " OrNode#right\n\n Represents the right side of the expression.\n\n     left || right\n             ^^^^^\n\n     1 or 2\n          ^"]
    pub right: *mut pm_node,
    #[doc = " OrNode#operator_loc\n\n The location of the `or` keyword or the `||` operator.\n\n     left or right\n          ^^"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_or_node"][::std::mem::size_of::<pm_or_node>() - 32usize];
    ["Alignment of pm_or_node"][::std::mem::align_of::<pm_or_node>() - 4usize];
    ["Offset of field: pm_or_node::base"][::std::mem::offset_of!(pm_or_node, base) - 0usize];
    ["Offset of field: pm_or_node::left"][::std::mem::offset_of!(pm_or_node, left) - 16usize];
    ["Offset of field: pm_or_node::right"][::std::mem::offset_of!(pm_or_node, right) - 20usize];
    ["Offset of field: pm_or_node::operator_loc"]
        [::std::mem::offset_of!(pm_or_node, operator_loc) - 24usize];
};
#[doc = " OrNode\n\n Represents the use of the `||` operator or the `or` keyword.\n\n     left or right\n     ^^^^^^^^^^^^^\n\n Type: ::PM_OR_NODE\n\n @extends pm_node_t"]
pub type pm_or_node_t = pm_or_node;
#[doc = " ParametersNode\n\n Represents the list of parameters on a method, block, or lambda definition.\n\n     def a(b, c, d)\n           ^^^^^^^\n     end\n\n Type: ::PM_PARAMETERS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_parameters_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ParametersNode#requireds"]
    pub requireds: pm_node_list,
    #[doc = " ParametersNode#optionals"]
    pub optionals: pm_node_list,
    #[doc = " ParametersNode#rest"]
    pub rest: *mut pm_node,
    #[doc = " ParametersNode#posts"]
    pub posts: pm_node_list,
    #[doc = " ParametersNode#keywords"]
    pub keywords: pm_node_list,
    #[doc = " ParametersNode#keyword_rest"]
    pub keyword_rest: *mut pm_node,
    #[doc = " ParametersNode#block"]
    pub block: *mut pm_block_parameter_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parameters_node"][::std::mem::size_of::<pm_parameters_node>() - 76usize];
    ["Alignment of pm_parameters_node"][::std::mem::align_of::<pm_parameters_node>() - 4usize];
    ["Offset of field: pm_parameters_node::base"]
        [::std::mem::offset_of!(pm_parameters_node, base) - 0usize];
    ["Offset of field: pm_parameters_node::requireds"]
        [::std::mem::offset_of!(pm_parameters_node, requireds) - 16usize];
    ["Offset of field: pm_parameters_node::optionals"]
        [::std::mem::offset_of!(pm_parameters_node, optionals) - 28usize];
    ["Offset of field: pm_parameters_node::rest"]
        [::std::mem::offset_of!(pm_parameters_node, rest) - 40usize];
    ["Offset of field: pm_parameters_node::posts"]
        [::std::mem::offset_of!(pm_parameters_node, posts) - 44usize];
    ["Offset of field: pm_parameters_node::keywords"]
        [::std::mem::offset_of!(pm_parameters_node, keywords) - 56usize];
    ["Offset of field: pm_parameters_node::keyword_rest"]
        [::std::mem::offset_of!(pm_parameters_node, keyword_rest) - 68usize];
    ["Offset of field: pm_parameters_node::block"]
        [::std::mem::offset_of!(pm_parameters_node, block) - 72usize];
};
#[doc = " ParametersNode\n\n Represents the list of parameters on a method, block, or lambda definition.\n\n     def a(b, c, d)\n           ^^^^^^^\n     end\n\n Type: ::PM_PARAMETERS_NODE\n\n @extends pm_node_t"]
pub type pm_parameters_node_t = pm_parameters_node;
#[doc = " ParenthesesNode\n\n Represents a parenthesized expression\n\n     (10 + 34)\n     ^^^^^^^^^\n\n Type: ::PM_PARENTHESES_NODE\n\n Flags (#pm_parentheses_node_flags):\n * ::PM_PARENTHESES_NODE_FLAGS_MULTIPLE_STATEMENTS\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_parentheses_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ParenthesesNode#body"]
    pub body: *mut pm_node,
    #[doc = " ParenthesesNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " ParenthesesNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parentheses_node"][::std::mem::size_of::<pm_parentheses_node>() - 36usize];
    ["Alignment of pm_parentheses_node"][::std::mem::align_of::<pm_parentheses_node>() - 4usize];
    ["Offset of field: pm_parentheses_node::base"]
        [::std::mem::offset_of!(pm_parentheses_node, base) - 0usize];
    ["Offset of field: pm_parentheses_node::body"]
        [::std::mem::offset_of!(pm_parentheses_node, body) - 16usize];
    ["Offset of field: pm_parentheses_node::opening_loc"]
        [::std::mem::offset_of!(pm_parentheses_node, opening_loc) - 20usize];
    ["Offset of field: pm_parentheses_node::closing_loc"]
        [::std::mem::offset_of!(pm_parentheses_node, closing_loc) - 28usize];
};
#[doc = " ParenthesesNode\n\n Represents a parenthesized expression\n\n     (10 + 34)\n     ^^^^^^^^^\n\n Type: ::PM_PARENTHESES_NODE\n\n Flags (#pm_parentheses_node_flags):\n * ::PM_PARENTHESES_NODE_FLAGS_MULTIPLE_STATEMENTS\n\n @extends pm_node_t"]
pub type pm_parentheses_node_t = pm_parentheses_node;
#[doc = " PinnedExpressionNode\n\n Represents the use of the `^` operator for pinning an expression in a pattern matching expression.\n\n     foo in ^(bar)\n            ^^^^^^\n\n Type: ::PM_PINNED_EXPRESSION_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_pinned_expression_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " PinnedExpressionNode#expression"]
    pub expression: *mut pm_node,
    #[doc = " PinnedExpressionNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " PinnedExpressionNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " PinnedExpressionNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_pinned_expression_node"]
        [::std::mem::size_of::<pm_pinned_expression_node>() - 44usize];
    ["Alignment of pm_pinned_expression_node"]
        [::std::mem::align_of::<pm_pinned_expression_node>() - 4usize];
    ["Offset of field: pm_pinned_expression_node::base"]
        [::std::mem::offset_of!(pm_pinned_expression_node, base) - 0usize];
    ["Offset of field: pm_pinned_expression_node::expression"]
        [::std::mem::offset_of!(pm_pinned_expression_node, expression) - 16usize];
    ["Offset of field: pm_pinned_expression_node::operator_loc"]
        [::std::mem::offset_of!(pm_pinned_expression_node, operator_loc) - 20usize];
    ["Offset of field: pm_pinned_expression_node::lparen_loc"]
        [::std::mem::offset_of!(pm_pinned_expression_node, lparen_loc) - 28usize];
    ["Offset of field: pm_pinned_expression_node::rparen_loc"]
        [::std::mem::offset_of!(pm_pinned_expression_node, rparen_loc) - 36usize];
};
#[doc = " PinnedExpressionNode\n\n Represents the use of the `^` operator for pinning an expression in a pattern matching expression.\n\n     foo in ^(bar)\n            ^^^^^^\n\n Type: ::PM_PINNED_EXPRESSION_NODE\n\n @extends pm_node_t"]
pub type pm_pinned_expression_node_t = pm_pinned_expression_node;
#[doc = " PinnedVariableNode\n\n Represents the use of the `^` operator for pinning a variable in a pattern matching expression.\n\n     foo in ^bar\n            ^^^^\n\n Type: ::PM_PINNED_VARIABLE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_pinned_variable_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " PinnedVariableNode#variable"]
    pub variable: *mut pm_node,
    #[doc = " PinnedVariableNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_pinned_variable_node"][::std::mem::size_of::<pm_pinned_variable_node>() - 28usize];
    ["Alignment of pm_pinned_variable_node"]
        [::std::mem::align_of::<pm_pinned_variable_node>() - 4usize];
    ["Offset of field: pm_pinned_variable_node::base"]
        [::std::mem::offset_of!(pm_pinned_variable_node, base) - 0usize];
    ["Offset of field: pm_pinned_variable_node::variable"]
        [::std::mem::offset_of!(pm_pinned_variable_node, variable) - 16usize];
    ["Offset of field: pm_pinned_variable_node::operator_loc"]
        [::std::mem::offset_of!(pm_pinned_variable_node, operator_loc) - 20usize];
};
#[doc = " PinnedVariableNode\n\n Represents the use of the `^` operator for pinning a variable in a pattern matching expression.\n\n     foo in ^bar\n            ^^^^\n\n Type: ::PM_PINNED_VARIABLE_NODE\n\n @extends pm_node_t"]
pub type pm_pinned_variable_node_t = pm_pinned_variable_node;
#[doc = " PostExecutionNode\n\n Represents the use of the `END` keyword.\n\n     END { foo }\n     ^^^^^^^^^^^\n\n Type: ::PM_POST_EXECUTION_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_post_execution_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " PostExecutionNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " PostExecutionNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " PostExecutionNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " PostExecutionNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_post_execution_node"][::std::mem::size_of::<pm_post_execution_node>() - 44usize];
    ["Alignment of pm_post_execution_node"]
        [::std::mem::align_of::<pm_post_execution_node>() - 4usize];
    ["Offset of field: pm_post_execution_node::base"]
        [::std::mem::offset_of!(pm_post_execution_node, base) - 0usize];
    ["Offset of field: pm_post_execution_node::statements"]
        [::std::mem::offset_of!(pm_post_execution_node, statements) - 16usize];
    ["Offset of field: pm_post_execution_node::keyword_loc"]
        [::std::mem::offset_of!(pm_post_execution_node, keyword_loc) - 20usize];
    ["Offset of field: pm_post_execution_node::opening_loc"]
        [::std::mem::offset_of!(pm_post_execution_node, opening_loc) - 28usize];
    ["Offset of field: pm_post_execution_node::closing_loc"]
        [::std::mem::offset_of!(pm_post_execution_node, closing_loc) - 36usize];
};
#[doc = " PostExecutionNode\n\n Represents the use of the `END` keyword.\n\n     END { foo }\n     ^^^^^^^^^^^\n\n Type: ::PM_POST_EXECUTION_NODE\n\n @extends pm_node_t"]
pub type pm_post_execution_node_t = pm_post_execution_node;
#[doc = " PreExecutionNode\n\n Represents the use of the `BEGIN` keyword.\n\n     BEGIN { foo }\n     ^^^^^^^^^^^^^\n\n Type: ::PM_PRE_EXECUTION_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_pre_execution_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " PreExecutionNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " PreExecutionNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " PreExecutionNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " PreExecutionNode#closing_loc"]
    pub closing_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_pre_execution_node"][::std::mem::size_of::<pm_pre_execution_node>() - 44usize];
    ["Alignment of pm_pre_execution_node"]
        [::std::mem::align_of::<pm_pre_execution_node>() - 4usize];
    ["Offset of field: pm_pre_execution_node::base"]
        [::std::mem::offset_of!(pm_pre_execution_node, base) - 0usize];
    ["Offset of field: pm_pre_execution_node::statements"]
        [::std::mem::offset_of!(pm_pre_execution_node, statements) - 16usize];
    ["Offset of field: pm_pre_execution_node::keyword_loc"]
        [::std::mem::offset_of!(pm_pre_execution_node, keyword_loc) - 20usize];
    ["Offset of field: pm_pre_execution_node::opening_loc"]
        [::std::mem::offset_of!(pm_pre_execution_node, opening_loc) - 28usize];
    ["Offset of field: pm_pre_execution_node::closing_loc"]
        [::std::mem::offset_of!(pm_pre_execution_node, closing_loc) - 36usize];
};
#[doc = " PreExecutionNode\n\n Represents the use of the `BEGIN` keyword.\n\n     BEGIN { foo }\n     ^^^^^^^^^^^^^\n\n Type: ::PM_PRE_EXECUTION_NODE\n\n @extends pm_node_t"]
pub type pm_pre_execution_node_t = pm_pre_execution_node;
#[doc = " ProgramNode\n\n The top level node of any parse tree.\n\n Type: ::PM_PROGRAM_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_program_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ProgramNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " ProgramNode#statements"]
    pub statements: *mut pm_statements_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_program_node"][::std::mem::size_of::<pm_program_node>() - 32usize];
    ["Alignment of pm_program_node"][::std::mem::align_of::<pm_program_node>() - 4usize];
    ["Offset of field: pm_program_node::base"]
        [::std::mem::offset_of!(pm_program_node, base) - 0usize];
    ["Offset of field: pm_program_node::locals"]
        [::std::mem::offset_of!(pm_program_node, locals) - 16usize];
    ["Offset of field: pm_program_node::statements"]
        [::std::mem::offset_of!(pm_program_node, statements) - 28usize];
};
#[doc = " ProgramNode\n\n The top level node of any parse tree.\n\n Type: ::PM_PROGRAM_NODE\n\n @extends pm_node_t"]
pub type pm_program_node_t = pm_program_node;
#[doc = " RangeNode\n\n Represents the use of the `..` or `...` operators.\n\n     1..2\n     ^^^^\n\n     c if a =~ /left/ ... b =~ /right/\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_RANGE_NODE\n\n Flags (#pm_range_flags):\n * ::PM_RANGE_FLAGS_EXCLUDE_END\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_range_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RangeNode#left\n\n The left-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     1...\n     ^\n\n     hello...goodbye\n     ^^^^^"]
    pub left: *mut pm_node,
    #[doc = " RangeNode#right\n\n The right-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     ..5\n       ^\n\n     1...foo\n         ^^^\n If neither right-hand or left-hand side was included, this will be a MissingNode."]
    pub right: *mut pm_node,
    #[doc = " RangeNode#operator_loc\n\n The location of the `..` or `...` operator."]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_range_node"][::std::mem::size_of::<pm_range_node>() - 32usize];
    ["Alignment of pm_range_node"][::std::mem::align_of::<pm_range_node>() - 4usize];
    ["Offset of field: pm_range_node::base"][::std::mem::offset_of!(pm_range_node, base) - 0usize];
    ["Offset of field: pm_range_node::left"][::std::mem::offset_of!(pm_range_node, left) - 16usize];
    ["Offset of field: pm_range_node::right"]
        [::std::mem::offset_of!(pm_range_node, right) - 20usize];
    ["Offset of field: pm_range_node::operator_loc"]
        [::std::mem::offset_of!(pm_range_node, operator_loc) - 24usize];
};
#[doc = " RangeNode\n\n Represents the use of the `..` or `...` operators.\n\n     1..2\n     ^^^^\n\n     c if a =~ /left/ ... b =~ /right/\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_RANGE_NODE\n\n Flags (#pm_range_flags):\n * ::PM_RANGE_FLAGS_EXCLUDE_END\n\n @extends pm_node_t"]
pub type pm_range_node_t = pm_range_node;
#[doc = " RationalNode\n\n Represents a rational number literal.\n\n     1.0r\n     ^^^^\n\n Type: ::PM_RATIONAL_NODE\n\n Flags (#pm_integer_base_flags):\n * ::PM_INTEGER_BASE_FLAGS_BINARY\n * ::PM_INTEGER_BASE_FLAGS_DECIMAL\n * ::PM_INTEGER_BASE_FLAGS_OCTAL\n * ::PM_INTEGER_BASE_FLAGS_HEXADECIMAL\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_rational_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RationalNode#numerator\n\n The numerator of the rational number.\n\n     1.5r # numerator 3"]
    pub numerator: pm_integer_t,
    #[doc = " RationalNode#denominator\n\n The denominator of the rational number.\n\n     1.5r # denominator 2"]
    pub denominator: pm_integer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_rational_node"][::std::mem::size_of::<pm_rational_node>() - 48usize];
    ["Alignment of pm_rational_node"][::std::mem::align_of::<pm_rational_node>() - 4usize];
    ["Offset of field: pm_rational_node::base"]
        [::std::mem::offset_of!(pm_rational_node, base) - 0usize];
    ["Offset of field: pm_rational_node::numerator"]
        [::std::mem::offset_of!(pm_rational_node, numerator) - 16usize];
    ["Offset of field: pm_rational_node::denominator"]
        [::std::mem::offset_of!(pm_rational_node, denominator) - 32usize];
};
#[doc = " RationalNode\n\n Represents a rational number literal.\n\n     1.0r\n     ^^^^\n\n Type: ::PM_RATIONAL_NODE\n\n Flags (#pm_integer_base_flags):\n * ::PM_INTEGER_BASE_FLAGS_BINARY\n * ::PM_INTEGER_BASE_FLAGS_DECIMAL\n * ::PM_INTEGER_BASE_FLAGS_OCTAL\n * ::PM_INTEGER_BASE_FLAGS_HEXADECIMAL\n\n @extends pm_node_t"]
pub type pm_rational_node_t = pm_rational_node;
#[doc = " RedoNode\n\n Represents the use of the `redo` keyword.\n\n     redo\n     ^^^^\n\n Type: ::PM_REDO_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_redo_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_redo_node"][::std::mem::size_of::<pm_redo_node>() - 16usize];
    ["Alignment of pm_redo_node"][::std::mem::align_of::<pm_redo_node>() - 4usize];
    ["Offset of field: pm_redo_node::base"][::std::mem::offset_of!(pm_redo_node, base) - 0usize];
};
#[doc = " RedoNode\n\n Represents the use of the `redo` keyword.\n\n     redo\n     ^^^^\n\n Type: ::PM_REDO_NODE\n\n @extends pm_node_t"]
pub type pm_redo_node_t = pm_redo_node;
#[doc = " RegularExpressionNode\n\n Represents a regular expression literal with no interpolation.\n\n     /foo/i\n     ^^^^^^\n\n Type: ::PM_REGULAR_EXPRESSION_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_regular_expression_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RegularExpressionNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " RegularExpressionNode#content_loc"]
    pub content_loc: pm_location_t,
    #[doc = " RegularExpressionNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " RegularExpressionNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_regular_expression_node"]
        [::std::mem::size_of::<pm_regular_expression_node>() - 52usize];
    ["Alignment of pm_regular_expression_node"]
        [::std::mem::align_of::<pm_regular_expression_node>() - 4usize];
    ["Offset of field: pm_regular_expression_node::base"]
        [::std::mem::offset_of!(pm_regular_expression_node, base) - 0usize];
    ["Offset of field: pm_regular_expression_node::opening_loc"]
        [::std::mem::offset_of!(pm_regular_expression_node, opening_loc) - 16usize];
    ["Offset of field: pm_regular_expression_node::content_loc"]
        [::std::mem::offset_of!(pm_regular_expression_node, content_loc) - 24usize];
    ["Offset of field: pm_regular_expression_node::closing_loc"]
        [::std::mem::offset_of!(pm_regular_expression_node, closing_loc) - 32usize];
    ["Offset of field: pm_regular_expression_node::unescaped"]
        [::std::mem::offset_of!(pm_regular_expression_node, unescaped) - 40usize];
};
#[doc = " RegularExpressionNode\n\n Represents a regular expression literal with no interpolation.\n\n     /foo/i\n     ^^^^^^\n\n Type: ::PM_REGULAR_EXPRESSION_NODE\n\n Flags (#pm_regular_expression_flags):\n * ::PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EXTENDED\n * ::PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE\n * ::PM_REGULAR_EXPRESSION_FLAGS_ONCE\n * ::PM_REGULAR_EXPRESSION_FLAGS_EUC_JP\n * ::PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT\n * ::PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J\n * ::PM_REGULAR_EXPRESSION_FLAGS_UTF_8\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_regular_expression_node_t = pm_regular_expression_node;
#[doc = " RequiredKeywordParameterNode\n\n Represents a required keyword parameter to a method, block, or lambda definition.\n\n     def a(b: )\n           ^^\n     end\n\n Type: ::PM_REQUIRED_KEYWORD_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_required_keyword_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RequiredKeywordParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " RequiredKeywordParameterNode#name_loc"]
    pub name_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_required_keyword_parameter_node"]
        [::std::mem::size_of::<pm_required_keyword_parameter_node>() - 28usize];
    ["Alignment of pm_required_keyword_parameter_node"]
        [::std::mem::align_of::<pm_required_keyword_parameter_node>() - 4usize];
    ["Offset of field: pm_required_keyword_parameter_node::base"]
        [::std::mem::offset_of!(pm_required_keyword_parameter_node, base) - 0usize];
    ["Offset of field: pm_required_keyword_parameter_node::name"]
        [::std::mem::offset_of!(pm_required_keyword_parameter_node, name) - 16usize];
    ["Offset of field: pm_required_keyword_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_required_keyword_parameter_node, name_loc) - 20usize];
};
#[doc = " RequiredKeywordParameterNode\n\n Represents a required keyword parameter to a method, block, or lambda definition.\n\n     def a(b: )\n           ^^\n     end\n\n Type: ::PM_REQUIRED_KEYWORD_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_required_keyword_parameter_node_t = pm_required_keyword_parameter_node;
#[doc = " RequiredParameterNode\n\n Represents a required parameter to a method, block, or lambda definition.\n\n     def a(b)\n           ^\n     end\n\n Type: ::PM_REQUIRED_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_required_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RequiredParameterNode#name"]
    pub name: pm_constant_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_required_parameter_node"]
        [::std::mem::size_of::<pm_required_parameter_node>() - 20usize];
    ["Alignment of pm_required_parameter_node"]
        [::std::mem::align_of::<pm_required_parameter_node>() - 4usize];
    ["Offset of field: pm_required_parameter_node::base"]
        [::std::mem::offset_of!(pm_required_parameter_node, base) - 0usize];
    ["Offset of field: pm_required_parameter_node::name"]
        [::std::mem::offset_of!(pm_required_parameter_node, name) - 16usize];
};
#[doc = " RequiredParameterNode\n\n Represents a required parameter to a method, block, or lambda definition.\n\n     def a(b)\n           ^\n     end\n\n Type: ::PM_REQUIRED_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_required_parameter_node_t = pm_required_parameter_node;
#[doc = " RescueModifierNode\n\n Represents an expression modified with a rescue.\n\n     foo rescue nil\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_RESCUE_MODIFIER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_rescue_modifier_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RescueModifierNode#expression"]
    pub expression: *mut pm_node,
    #[doc = " RescueModifierNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " RescueModifierNode#rescue_expression"]
    pub rescue_expression: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_rescue_modifier_node"][::std::mem::size_of::<pm_rescue_modifier_node>() - 32usize];
    ["Alignment of pm_rescue_modifier_node"]
        [::std::mem::align_of::<pm_rescue_modifier_node>() - 4usize];
    ["Offset of field: pm_rescue_modifier_node::base"]
        [::std::mem::offset_of!(pm_rescue_modifier_node, base) - 0usize];
    ["Offset of field: pm_rescue_modifier_node::expression"]
        [::std::mem::offset_of!(pm_rescue_modifier_node, expression) - 16usize];
    ["Offset of field: pm_rescue_modifier_node::keyword_loc"]
        [::std::mem::offset_of!(pm_rescue_modifier_node, keyword_loc) - 20usize];
    ["Offset of field: pm_rescue_modifier_node::rescue_expression"]
        [::std::mem::offset_of!(pm_rescue_modifier_node, rescue_expression) - 28usize];
};
#[doc = " RescueModifierNode\n\n Represents an expression modified with a rescue.\n\n     foo rescue nil\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_RESCUE_MODIFIER_NODE\n\n @extends pm_node_t"]
pub type pm_rescue_modifier_node_t = pm_rescue_modifier_node;
#[doc = " RescueNode\n\n Represents a rescue statement.\n\n     begin\n     rescue Foo, *splat, Bar => ex\n       foo\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     end\n\n `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `reference` field.\n\n Type: ::PM_RESCUE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_rescue_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RescueNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " RescueNode#exceptions"]
    pub exceptions: pm_node_list,
    #[doc = " RescueNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " RescueNode#reference"]
    pub reference: *mut pm_node,
    #[doc = " RescueNode#then_keyword_loc"]
    pub then_keyword_loc: pm_location_t,
    #[doc = " RescueNode#statements"]
    pub statements: *mut pm_statements_node,
    #[doc = " RescueNode#subsequent"]
    pub subsequent: *mut pm_rescue_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_rescue_node"][::std::mem::size_of::<pm_rescue_node>() - 64usize];
    ["Alignment of pm_rescue_node"][::std::mem::align_of::<pm_rescue_node>() - 4usize];
    ["Offset of field: pm_rescue_node::base"]
        [::std::mem::offset_of!(pm_rescue_node, base) - 0usize];
    ["Offset of field: pm_rescue_node::keyword_loc"]
        [::std::mem::offset_of!(pm_rescue_node, keyword_loc) - 16usize];
    ["Offset of field: pm_rescue_node::exceptions"]
        [::std::mem::offset_of!(pm_rescue_node, exceptions) - 24usize];
    ["Offset of field: pm_rescue_node::operator_loc"]
        [::std::mem::offset_of!(pm_rescue_node, operator_loc) - 36usize];
    ["Offset of field: pm_rescue_node::reference"]
        [::std::mem::offset_of!(pm_rescue_node, reference) - 44usize];
    ["Offset of field: pm_rescue_node::then_keyword_loc"]
        [::std::mem::offset_of!(pm_rescue_node, then_keyword_loc) - 48usize];
    ["Offset of field: pm_rescue_node::statements"]
        [::std::mem::offset_of!(pm_rescue_node, statements) - 56usize];
    ["Offset of field: pm_rescue_node::subsequent"]
        [::std::mem::offset_of!(pm_rescue_node, subsequent) - 60usize];
};
#[doc = " RescueNode\n\n Represents a rescue statement.\n\n     begin\n     rescue Foo, *splat, Bar => ex\n       foo\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     end\n\n `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `reference` field.\n\n Type: ::PM_RESCUE_NODE\n\n @extends pm_node_t"]
pub type pm_rescue_node_t = pm_rescue_node;
#[doc = " RestParameterNode\n\n Represents a rest parameter to a method, block, or lambda definition.\n\n     def a(*b)\n           ^^\n     end\n\n Type: ::PM_REST_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_rest_parameter_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " RestParameterNode#name"]
    pub name: pm_constant_id_t,
    #[doc = " RestParameterNode#name_loc"]
    pub name_loc: pm_location_t,
    #[doc = " RestParameterNode#operator_loc"]
    pub operator_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_rest_parameter_node"][::std::mem::size_of::<pm_rest_parameter_node>() - 36usize];
    ["Alignment of pm_rest_parameter_node"]
        [::std::mem::align_of::<pm_rest_parameter_node>() - 4usize];
    ["Offset of field: pm_rest_parameter_node::base"]
        [::std::mem::offset_of!(pm_rest_parameter_node, base) - 0usize];
    ["Offset of field: pm_rest_parameter_node::name"]
        [::std::mem::offset_of!(pm_rest_parameter_node, name) - 16usize];
    ["Offset of field: pm_rest_parameter_node::name_loc"]
        [::std::mem::offset_of!(pm_rest_parameter_node, name_loc) - 20usize];
    ["Offset of field: pm_rest_parameter_node::operator_loc"]
        [::std::mem::offset_of!(pm_rest_parameter_node, operator_loc) - 28usize];
};
#[doc = " RestParameterNode\n\n Represents a rest parameter to a method, block, or lambda definition.\n\n     def a(*b)\n           ^^\n     end\n\n Type: ::PM_REST_PARAMETER_NODE\n\n Flags (#pm_parameter_flags):\n * ::PM_PARAMETER_FLAGS_REPEATED_PARAMETER\n\n @extends pm_node_t"]
pub type pm_rest_parameter_node_t = pm_rest_parameter_node;
#[doc = " RetryNode\n\n Represents the use of the `retry` keyword.\n\n     retry\n     ^^^^^\n\n Type: ::PM_RETRY_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_retry_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_retry_node"][::std::mem::size_of::<pm_retry_node>() - 16usize];
    ["Alignment of pm_retry_node"][::std::mem::align_of::<pm_retry_node>() - 4usize];
    ["Offset of field: pm_retry_node::base"][::std::mem::offset_of!(pm_retry_node, base) - 0usize];
};
#[doc = " RetryNode\n\n Represents the use of the `retry` keyword.\n\n     retry\n     ^^^^^\n\n Type: ::PM_RETRY_NODE\n\n @extends pm_node_t"]
pub type pm_retry_node_t = pm_retry_node;
#[doc = " ReturnNode\n\n Represents the use of the `return` keyword.\n\n     return 1\n     ^^^^^^^^\n\n Type: ::PM_RETURN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_return_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ReturnNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " ReturnNode#arguments"]
    pub arguments: *mut pm_arguments_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_return_node"][::std::mem::size_of::<pm_return_node>() - 28usize];
    ["Alignment of pm_return_node"][::std::mem::align_of::<pm_return_node>() - 4usize];
    ["Offset of field: pm_return_node::base"]
        [::std::mem::offset_of!(pm_return_node, base) - 0usize];
    ["Offset of field: pm_return_node::keyword_loc"]
        [::std::mem::offset_of!(pm_return_node, keyword_loc) - 16usize];
    ["Offset of field: pm_return_node::arguments"]
        [::std::mem::offset_of!(pm_return_node, arguments) - 24usize];
};
#[doc = " ReturnNode\n\n Represents the use of the `return` keyword.\n\n     return 1\n     ^^^^^^^^\n\n Type: ::PM_RETURN_NODE\n\n @extends pm_node_t"]
pub type pm_return_node_t = pm_return_node;
#[doc = " SelfNode\n\n Represents the `self` keyword.\n\n     self\n     ^^^^\n\n Type: ::PM_SELF_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_self_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_self_node"][::std::mem::size_of::<pm_self_node>() - 16usize];
    ["Alignment of pm_self_node"][::std::mem::align_of::<pm_self_node>() - 4usize];
    ["Offset of field: pm_self_node::base"][::std::mem::offset_of!(pm_self_node, base) - 0usize];
};
#[doc = " SelfNode\n\n Represents the `self` keyword.\n\n     self\n     ^^^^\n\n Type: ::PM_SELF_NODE\n\n @extends pm_node_t"]
pub type pm_self_node_t = pm_self_node;
#[doc = " ShareableConstantNode\n\n This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.\n\n     # shareable_constant_value: literal\n     C = { a: 1 }\n     ^^^^^^^^^^^^\n\n Type: ::PM_SHAREABLE_CONSTANT_NODE\n\n Flags (#pm_shareable_constant_node_flags):\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_LITERAL\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_EVERYTHING\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_COPY\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_shareable_constant_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " ShareableConstantNode#write\n\n The constant write that should be modified with the shareability state."]
    pub write: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_shareable_constant_node"]
        [::std::mem::size_of::<pm_shareable_constant_node>() - 20usize];
    ["Alignment of pm_shareable_constant_node"]
        [::std::mem::align_of::<pm_shareable_constant_node>() - 4usize];
    ["Offset of field: pm_shareable_constant_node::base"]
        [::std::mem::offset_of!(pm_shareable_constant_node, base) - 0usize];
    ["Offset of field: pm_shareable_constant_node::write"]
        [::std::mem::offset_of!(pm_shareable_constant_node, write) - 16usize];
};
#[doc = " ShareableConstantNode\n\n This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.\n\n     # shareable_constant_value: literal\n     C = { a: 1 }\n     ^^^^^^^^^^^^\n\n Type: ::PM_SHAREABLE_CONSTANT_NODE\n\n Flags (#pm_shareable_constant_node_flags):\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_LITERAL\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_EVERYTHING\n * ::PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_COPY\n\n @extends pm_node_t"]
pub type pm_shareable_constant_node_t = pm_shareable_constant_node;
#[doc = " SingletonClassNode\n\n Represents a singleton class declaration involving the `class` keyword.\n\n     class << self end\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_SINGLETON_CLASS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_singleton_class_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SingletonClassNode#locals"]
    pub locals: pm_constant_id_list_t,
    #[doc = " SingletonClassNode#class_keyword_loc"]
    pub class_keyword_loc: pm_location_t,
    #[doc = " SingletonClassNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " SingletonClassNode#expression"]
    pub expression: *mut pm_node,
    #[doc = " SingletonClassNode#body"]
    pub body: *mut pm_node,
    #[doc = " SingletonClassNode#end_keyword_loc"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_singleton_class_node"][::std::mem::size_of::<pm_singleton_class_node>() - 60usize];
    ["Alignment of pm_singleton_class_node"]
        [::std::mem::align_of::<pm_singleton_class_node>() - 4usize];
    ["Offset of field: pm_singleton_class_node::base"]
        [::std::mem::offset_of!(pm_singleton_class_node, base) - 0usize];
    ["Offset of field: pm_singleton_class_node::locals"]
        [::std::mem::offset_of!(pm_singleton_class_node, locals) - 16usize];
    ["Offset of field: pm_singleton_class_node::class_keyword_loc"]
        [::std::mem::offset_of!(pm_singleton_class_node, class_keyword_loc) - 28usize];
    ["Offset of field: pm_singleton_class_node::operator_loc"]
        [::std::mem::offset_of!(pm_singleton_class_node, operator_loc) - 36usize];
    ["Offset of field: pm_singleton_class_node::expression"]
        [::std::mem::offset_of!(pm_singleton_class_node, expression) - 44usize];
    ["Offset of field: pm_singleton_class_node::body"]
        [::std::mem::offset_of!(pm_singleton_class_node, body) - 48usize];
    ["Offset of field: pm_singleton_class_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_singleton_class_node, end_keyword_loc) - 52usize];
};
#[doc = " SingletonClassNode\n\n Represents a singleton class declaration involving the `class` keyword.\n\n     class << self end\n     ^^^^^^^^^^^^^^^^^\n\n Type: ::PM_SINGLETON_CLASS_NODE\n\n @extends pm_node_t"]
pub type pm_singleton_class_node_t = pm_singleton_class_node;
#[doc = " SourceEncodingNode\n\n Represents the use of the `__ENCODING__` keyword.\n\n     __ENCODING__\n     ^^^^^^^^^^^^\n\n Type: ::PM_SOURCE_ENCODING_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_source_encoding_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_source_encoding_node"][::std::mem::size_of::<pm_source_encoding_node>() - 16usize];
    ["Alignment of pm_source_encoding_node"]
        [::std::mem::align_of::<pm_source_encoding_node>() - 4usize];
    ["Offset of field: pm_source_encoding_node::base"]
        [::std::mem::offset_of!(pm_source_encoding_node, base) - 0usize];
};
#[doc = " SourceEncodingNode\n\n Represents the use of the `__ENCODING__` keyword.\n\n     __ENCODING__\n     ^^^^^^^^^^^^\n\n Type: ::PM_SOURCE_ENCODING_NODE\n\n @extends pm_node_t"]
pub type pm_source_encoding_node_t = pm_source_encoding_node;
#[doc = " SourceFileNode\n\n Represents the use of the `__FILE__` keyword.\n\n     __FILE__\n     ^^^^^^^^\n\n Type: ::PM_SOURCE_FILE_NODE\n\n Flags (#pm_string_flags):\n * ::PM_STRING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_STRING_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_STRING_FLAGS_FROZEN\n * ::PM_STRING_FLAGS_MUTABLE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_source_file_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SourceFileNode#filepath\n\n Represents the file path being parsed. This corresponds directly to the `filepath` option given to the various `Prism::parse*` APIs."]
    pub filepath: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_source_file_node"][::std::mem::size_of::<pm_source_file_node>() - 28usize];
    ["Alignment of pm_source_file_node"][::std::mem::align_of::<pm_source_file_node>() - 4usize];
    ["Offset of field: pm_source_file_node::base"]
        [::std::mem::offset_of!(pm_source_file_node, base) - 0usize];
    ["Offset of field: pm_source_file_node::filepath"]
        [::std::mem::offset_of!(pm_source_file_node, filepath) - 16usize];
};
#[doc = " SourceFileNode\n\n Represents the use of the `__FILE__` keyword.\n\n     __FILE__\n     ^^^^^^^^\n\n Type: ::PM_SOURCE_FILE_NODE\n\n Flags (#pm_string_flags):\n * ::PM_STRING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_STRING_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_STRING_FLAGS_FROZEN\n * ::PM_STRING_FLAGS_MUTABLE\n\n @extends pm_node_t"]
pub type pm_source_file_node_t = pm_source_file_node;
#[doc = " SourceLineNode\n\n Represents the use of the `__LINE__` keyword.\n\n     __LINE__\n     ^^^^^^^^\n\n Type: ::PM_SOURCE_LINE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_source_line_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_source_line_node"][::std::mem::size_of::<pm_source_line_node>() - 16usize];
    ["Alignment of pm_source_line_node"][::std::mem::align_of::<pm_source_line_node>() - 4usize];
    ["Offset of field: pm_source_line_node::base"]
        [::std::mem::offset_of!(pm_source_line_node, base) - 0usize];
};
#[doc = " SourceLineNode\n\n Represents the use of the `__LINE__` keyword.\n\n     __LINE__\n     ^^^^^^^^\n\n Type: ::PM_SOURCE_LINE_NODE\n\n @extends pm_node_t"]
pub type pm_source_line_node_t = pm_source_line_node;
#[doc = " SplatNode\n\n Represents the use of the splat operator.\n\n     [*a]\n      ^^\n\n Type: ::PM_SPLAT_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_splat_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SplatNode#operator_loc"]
    pub operator_loc: pm_location_t,
    #[doc = " SplatNode#expression"]
    pub expression: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_splat_node"][::std::mem::size_of::<pm_splat_node>() - 28usize];
    ["Alignment of pm_splat_node"][::std::mem::align_of::<pm_splat_node>() - 4usize];
    ["Offset of field: pm_splat_node::base"][::std::mem::offset_of!(pm_splat_node, base) - 0usize];
    ["Offset of field: pm_splat_node::operator_loc"]
        [::std::mem::offset_of!(pm_splat_node, operator_loc) - 16usize];
    ["Offset of field: pm_splat_node::expression"]
        [::std::mem::offset_of!(pm_splat_node, expression) - 24usize];
};
#[doc = " SplatNode\n\n Represents the use of the splat operator.\n\n     [*a]\n      ^^\n\n Type: ::PM_SPLAT_NODE\n\n @extends pm_node_t"]
pub type pm_splat_node_t = pm_splat_node;
#[doc = " StatementsNode\n\n Represents a set of statements contained within some scope.\n\n     foo; bar; baz\n     ^^^^^^^^^^^^^\n\n Type: ::PM_STATEMENTS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_statements_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " StatementsNode#body"]
    pub body: pm_node_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_statements_node"][::std::mem::size_of::<pm_statements_node>() - 28usize];
    ["Alignment of pm_statements_node"][::std::mem::align_of::<pm_statements_node>() - 4usize];
    ["Offset of field: pm_statements_node::base"]
        [::std::mem::offset_of!(pm_statements_node, base) - 0usize];
    ["Offset of field: pm_statements_node::body"]
        [::std::mem::offset_of!(pm_statements_node, body) - 16usize];
};
#[doc = " StatementsNode\n\n Represents a set of statements contained within some scope.\n\n     foo; bar; baz\n     ^^^^^^^^^^^^^\n\n Type: ::PM_STATEMENTS_NODE\n\n @extends pm_node_t"]
pub type pm_statements_node_t = pm_statements_node;
#[doc = " StringNode\n\n Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.\n\n     \"foo\"\n     ^^^^^\n\n     %w[foo]\n        ^^^\n\n     \"foo #{bar} baz\"\n      ^^^^      ^^^^\n\n Type: ::PM_STRING_NODE\n\n Flags (#pm_string_flags):\n * ::PM_STRING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_STRING_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_STRING_FLAGS_FROZEN\n * ::PM_STRING_FLAGS_MUTABLE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_string_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " StringNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " StringNode#content_loc"]
    pub content_loc: pm_location_t,
    #[doc = " StringNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " StringNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_string_node"][::std::mem::size_of::<pm_string_node>() - 52usize];
    ["Alignment of pm_string_node"][::std::mem::align_of::<pm_string_node>() - 4usize];
    ["Offset of field: pm_string_node::base"]
        [::std::mem::offset_of!(pm_string_node, base) - 0usize];
    ["Offset of field: pm_string_node::opening_loc"]
        [::std::mem::offset_of!(pm_string_node, opening_loc) - 16usize];
    ["Offset of field: pm_string_node::content_loc"]
        [::std::mem::offset_of!(pm_string_node, content_loc) - 24usize];
    ["Offset of field: pm_string_node::closing_loc"]
        [::std::mem::offset_of!(pm_string_node, closing_loc) - 32usize];
    ["Offset of field: pm_string_node::unescaped"]
        [::std::mem::offset_of!(pm_string_node, unescaped) - 40usize];
};
#[doc = " StringNode\n\n Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.\n\n     \"foo\"\n     ^^^^^\n\n     %w[foo]\n        ^^^\n\n     \"foo #{bar} baz\"\n      ^^^^      ^^^^\n\n Type: ::PM_STRING_NODE\n\n Flags (#pm_string_flags):\n * ::PM_STRING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_STRING_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_STRING_FLAGS_FROZEN\n * ::PM_STRING_FLAGS_MUTABLE\n\n @extends pm_node_t"]
pub type pm_string_node_t = pm_string_node;
#[doc = " SuperNode\n\n Represents the use of the `super` keyword with parentheses or arguments.\n\n     super()\n     ^^^^^^^\n\n     super foo, bar\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_SUPER_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_super_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SuperNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " SuperNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " SuperNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " SuperNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
    #[doc = " SuperNode#block"]
    pub block: *mut pm_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_super_node"][::std::mem::size_of::<pm_super_node>() - 48usize];
    ["Alignment of pm_super_node"][::std::mem::align_of::<pm_super_node>() - 4usize];
    ["Offset of field: pm_super_node::base"][::std::mem::offset_of!(pm_super_node, base) - 0usize];
    ["Offset of field: pm_super_node::keyword_loc"]
        [::std::mem::offset_of!(pm_super_node, keyword_loc) - 16usize];
    ["Offset of field: pm_super_node::lparen_loc"]
        [::std::mem::offset_of!(pm_super_node, lparen_loc) - 24usize];
    ["Offset of field: pm_super_node::arguments"]
        [::std::mem::offset_of!(pm_super_node, arguments) - 32usize];
    ["Offset of field: pm_super_node::rparen_loc"]
        [::std::mem::offset_of!(pm_super_node, rparen_loc) - 36usize];
    ["Offset of field: pm_super_node::block"]
        [::std::mem::offset_of!(pm_super_node, block) - 44usize];
};
#[doc = " SuperNode\n\n Represents the use of the `super` keyword with parentheses or arguments.\n\n     super()\n     ^^^^^^^\n\n     super foo, bar\n     ^^^^^^^^^^^^^^\n\n Type: ::PM_SUPER_NODE\n\n @extends pm_node_t"]
pub type pm_super_node_t = pm_super_node;
#[doc = " SymbolNode\n\n Represents a symbol literal or a symbol contained within a `%i` list.\n\n     :foo\n     ^^^^\n\n     %i[foo]\n        ^^^\n\n Type: ::PM_SYMBOL_NODE\n\n Flags (#pm_symbol_flags):\n * ::PM_SYMBOL_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_SYMBOL_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_SYMBOL_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_symbol_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " SymbolNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " SymbolNode#value_loc"]
    pub value_loc: pm_location_t,
    #[doc = " SymbolNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " SymbolNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_symbol_node"][::std::mem::size_of::<pm_symbol_node>() - 52usize];
    ["Alignment of pm_symbol_node"][::std::mem::align_of::<pm_symbol_node>() - 4usize];
    ["Offset of field: pm_symbol_node::base"]
        [::std::mem::offset_of!(pm_symbol_node, base) - 0usize];
    ["Offset of field: pm_symbol_node::opening_loc"]
        [::std::mem::offset_of!(pm_symbol_node, opening_loc) - 16usize];
    ["Offset of field: pm_symbol_node::value_loc"]
        [::std::mem::offset_of!(pm_symbol_node, value_loc) - 24usize];
    ["Offset of field: pm_symbol_node::closing_loc"]
        [::std::mem::offset_of!(pm_symbol_node, closing_loc) - 32usize];
    ["Offset of field: pm_symbol_node::unescaped"]
        [::std::mem::offset_of!(pm_symbol_node, unescaped) - 40usize];
};
#[doc = " SymbolNode\n\n Represents a symbol literal or a symbol contained within a `%i` list.\n\n     :foo\n     ^^^^\n\n     %i[foo]\n        ^^^\n\n Type: ::PM_SYMBOL_NODE\n\n Flags (#pm_symbol_flags):\n * ::PM_SYMBOL_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_SYMBOL_FLAGS_FORCED_BINARY_ENCODING\n * ::PM_SYMBOL_FLAGS_FORCED_US_ASCII_ENCODING\n\n @extends pm_node_t"]
pub type pm_symbol_node_t = pm_symbol_node;
#[doc = " TrueNode\n\n Represents the use of the literal `true` keyword.\n\n     true\n     ^^^^\n\n Type: ::PM_TRUE_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_true_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_true_node"][::std::mem::size_of::<pm_true_node>() - 16usize];
    ["Alignment of pm_true_node"][::std::mem::align_of::<pm_true_node>() - 4usize];
    ["Offset of field: pm_true_node::base"][::std::mem::offset_of!(pm_true_node, base) - 0usize];
};
#[doc = " TrueNode\n\n Represents the use of the literal `true` keyword.\n\n     true\n     ^^^^\n\n Type: ::PM_TRUE_NODE\n\n @extends pm_node_t"]
pub type pm_true_node_t = pm_true_node;
#[doc = " UndefNode\n\n Represents the use of the `undef` keyword.\n\n     undef :foo, :bar, :baz\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNDEF_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_undef_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " UndefNode#names"]
    pub names: pm_node_list,
    #[doc = " UndefNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_undef_node"][::std::mem::size_of::<pm_undef_node>() - 36usize];
    ["Alignment of pm_undef_node"][::std::mem::align_of::<pm_undef_node>() - 4usize];
    ["Offset of field: pm_undef_node::base"][::std::mem::offset_of!(pm_undef_node, base) - 0usize];
    ["Offset of field: pm_undef_node::names"]
        [::std::mem::offset_of!(pm_undef_node, names) - 16usize];
    ["Offset of field: pm_undef_node::keyword_loc"]
        [::std::mem::offset_of!(pm_undef_node, keyword_loc) - 28usize];
};
#[doc = " UndefNode\n\n Represents the use of the `undef` keyword.\n\n     undef :foo, :bar, :baz\n     ^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNDEF_NODE\n\n @extends pm_node_t"]
pub type pm_undef_node_t = pm_undef_node;
#[doc = " UnlessNode\n\n Represents the use of the `unless` keyword, either in the block form or the modifier form.\n\n     bar unless foo\n     ^^^^^^^^^^^^^^\n\n     unless foo then bar end\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNLESS_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_unless_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " UnlessNode#keyword_loc\n\n The location of the `unless` keyword.\n\n     unless cond then bar end\n     ^^^^^^\n\n     bar unless cond\n         ^^^^^^"]
    pub keyword_loc: pm_location_t,
    #[doc = " UnlessNode#predicate\n\n The condition to be evaluated for the unless expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).\n\n     unless cond then bar end\n            ^^^^\n\n     bar unless cond\n                ^^^^"]
    pub predicate: *mut pm_node,
    #[doc = " UnlessNode#then_keyword_loc\n\n The location of the `then` keyword, if present.\n\n     unless cond then bar end\n                 ^^^^"]
    pub then_keyword_loc: pm_location_t,
    #[doc = " UnlessNode#statements\n\n The body of statements that will executed if the unless condition is\n falsey. Will be `nil` if no body is provided.\n\n     unless cond then bar end\n                      ^^^"]
    pub statements: *mut pm_statements_node,
    #[doc = " UnlessNode#else_clause\n\n The else clause of the unless expression, if present.\n\n     unless cond then bar else baz end\n                          ^^^^^^^^"]
    pub else_clause: *mut pm_else_node,
    #[doc = " UnlessNode#end_keyword_loc\n\n The location of the `end` keyword, if present.\n\n     unless cond then bar end\n                          ^^^"]
    pub end_keyword_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_unless_node"][::std::mem::size_of::<pm_unless_node>() - 52usize];
    ["Alignment of pm_unless_node"][::std::mem::align_of::<pm_unless_node>() - 4usize];
    ["Offset of field: pm_unless_node::base"]
        [::std::mem::offset_of!(pm_unless_node, base) - 0usize];
    ["Offset of field: pm_unless_node::keyword_loc"]
        [::std::mem::offset_of!(pm_unless_node, keyword_loc) - 16usize];
    ["Offset of field: pm_unless_node::predicate"]
        [::std::mem::offset_of!(pm_unless_node, predicate) - 24usize];
    ["Offset of field: pm_unless_node::then_keyword_loc"]
        [::std::mem::offset_of!(pm_unless_node, then_keyword_loc) - 28usize];
    ["Offset of field: pm_unless_node::statements"]
        [::std::mem::offset_of!(pm_unless_node, statements) - 36usize];
    ["Offset of field: pm_unless_node::else_clause"]
        [::std::mem::offset_of!(pm_unless_node, else_clause) - 40usize];
    ["Offset of field: pm_unless_node::end_keyword_loc"]
        [::std::mem::offset_of!(pm_unless_node, end_keyword_loc) - 44usize];
};
#[doc = " UnlessNode\n\n Represents the use of the `unless` keyword, either in the block form or the modifier form.\n\n     bar unless foo\n     ^^^^^^^^^^^^^^\n\n     unless foo then bar end\n     ^^^^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNLESS_NODE\n\n @extends pm_node_t"]
pub type pm_unless_node_t = pm_unless_node;
#[doc = " UntilNode\n\n Represents the use of the `until` keyword, either in the block form or the modifier form.\n\n     bar until foo\n     ^^^^^^^^^^^^^\n\n     until foo do bar end\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNTIL_NODE\n\n Flags (#pm_loop_flags):\n * ::PM_LOOP_FLAGS_BEGIN_MODIFIER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_until_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " UntilNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " UntilNode#do_keyword_loc"]
    pub do_keyword_loc: pm_location_t,
    #[doc = " UntilNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " UntilNode#predicate"]
    pub predicate: *mut pm_node,
    #[doc = " UntilNode#statements"]
    pub statements: *mut pm_statements_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_until_node"][::std::mem::size_of::<pm_until_node>() - 48usize];
    ["Alignment of pm_until_node"][::std::mem::align_of::<pm_until_node>() - 4usize];
    ["Offset of field: pm_until_node::base"][::std::mem::offset_of!(pm_until_node, base) - 0usize];
    ["Offset of field: pm_until_node::keyword_loc"]
        [::std::mem::offset_of!(pm_until_node, keyword_loc) - 16usize];
    ["Offset of field: pm_until_node::do_keyword_loc"]
        [::std::mem::offset_of!(pm_until_node, do_keyword_loc) - 24usize];
    ["Offset of field: pm_until_node::closing_loc"]
        [::std::mem::offset_of!(pm_until_node, closing_loc) - 32usize];
    ["Offset of field: pm_until_node::predicate"]
        [::std::mem::offset_of!(pm_until_node, predicate) - 40usize];
    ["Offset of field: pm_until_node::statements"]
        [::std::mem::offset_of!(pm_until_node, statements) - 44usize];
};
#[doc = " UntilNode\n\n Represents the use of the `until` keyword, either in the block form or the modifier form.\n\n     bar until foo\n     ^^^^^^^^^^^^^\n\n     until foo do bar end\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_UNTIL_NODE\n\n Flags (#pm_loop_flags):\n * ::PM_LOOP_FLAGS_BEGIN_MODIFIER\n\n @extends pm_node_t"]
pub type pm_until_node_t = pm_until_node;
#[doc = " WhenNode\n\n Represents the use of the `when` keyword within a case statement.\n\n     case true\n     when true\n     ^^^^^^^^^\n     end\n\n Type: ::PM_WHEN_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_when_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " WhenNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " WhenNode#conditions"]
    pub conditions: pm_node_list,
    #[doc = " WhenNode#then_keyword_loc"]
    pub then_keyword_loc: pm_location_t,
    #[doc = " WhenNode#statements"]
    pub statements: *mut pm_statements_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_when_node"][::std::mem::size_of::<pm_when_node>() - 48usize];
    ["Alignment of pm_when_node"][::std::mem::align_of::<pm_when_node>() - 4usize];
    ["Offset of field: pm_when_node::base"][::std::mem::offset_of!(pm_when_node, base) - 0usize];
    ["Offset of field: pm_when_node::keyword_loc"]
        [::std::mem::offset_of!(pm_when_node, keyword_loc) - 16usize];
    ["Offset of field: pm_when_node::conditions"]
        [::std::mem::offset_of!(pm_when_node, conditions) - 24usize];
    ["Offset of field: pm_when_node::then_keyword_loc"]
        [::std::mem::offset_of!(pm_when_node, then_keyword_loc) - 36usize];
    ["Offset of field: pm_when_node::statements"]
        [::std::mem::offset_of!(pm_when_node, statements) - 44usize];
};
#[doc = " WhenNode\n\n Represents the use of the `when` keyword within a case statement.\n\n     case true\n     when true\n     ^^^^^^^^^\n     end\n\n Type: ::PM_WHEN_NODE\n\n @extends pm_node_t"]
pub type pm_when_node_t = pm_when_node;
#[doc = " WhileNode\n\n Represents the use of the `while` keyword, either in the block form or the modifier form.\n\n     bar while foo\n     ^^^^^^^^^^^^^\n\n     while foo do bar end\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_WHILE_NODE\n\n Flags (#pm_loop_flags):\n * ::PM_LOOP_FLAGS_BEGIN_MODIFIER\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_while_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " WhileNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " WhileNode#do_keyword_loc"]
    pub do_keyword_loc: pm_location_t,
    #[doc = " WhileNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " WhileNode#predicate"]
    pub predicate: *mut pm_node,
    #[doc = " WhileNode#statements"]
    pub statements: *mut pm_statements_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_while_node"][::std::mem::size_of::<pm_while_node>() - 48usize];
    ["Alignment of pm_while_node"][::std::mem::align_of::<pm_while_node>() - 4usize];
    ["Offset of field: pm_while_node::base"][::std::mem::offset_of!(pm_while_node, base) - 0usize];
    ["Offset of field: pm_while_node::keyword_loc"]
        [::std::mem::offset_of!(pm_while_node, keyword_loc) - 16usize];
    ["Offset of field: pm_while_node::do_keyword_loc"]
        [::std::mem::offset_of!(pm_while_node, do_keyword_loc) - 24usize];
    ["Offset of field: pm_while_node::closing_loc"]
        [::std::mem::offset_of!(pm_while_node, closing_loc) - 32usize];
    ["Offset of field: pm_while_node::predicate"]
        [::std::mem::offset_of!(pm_while_node, predicate) - 40usize];
    ["Offset of field: pm_while_node::statements"]
        [::std::mem::offset_of!(pm_while_node, statements) - 44usize];
};
#[doc = " WhileNode\n\n Represents the use of the `while` keyword, either in the block form or the modifier form.\n\n     bar while foo\n     ^^^^^^^^^^^^^\n\n     while foo do bar end\n     ^^^^^^^^^^^^^^^^^^^^\n\n Type: ::PM_WHILE_NODE\n\n Flags (#pm_loop_flags):\n * ::PM_LOOP_FLAGS_BEGIN_MODIFIER\n\n @extends pm_node_t"]
pub type pm_while_node_t = pm_while_node;
#[doc = " XStringNode\n\n Represents an xstring literal with no interpolation.\n\n     `foo`\n     ^^^^^\n\n Type: ::PM_X_STRING_NODE\n\n Flags (#pm_encoding_flags):\n * ::PM_ENCODING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_ENCODING_FLAGS_FORCED_BINARY_ENCODING\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_x_string_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " XStringNode#opening_loc"]
    pub opening_loc: pm_location_t,
    #[doc = " XStringNode#content_loc"]
    pub content_loc: pm_location_t,
    #[doc = " XStringNode#closing_loc"]
    pub closing_loc: pm_location_t,
    #[doc = " XStringNode#unescaped"]
    pub unescaped: pm_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_x_string_node"][::std::mem::size_of::<pm_x_string_node>() - 52usize];
    ["Alignment of pm_x_string_node"][::std::mem::align_of::<pm_x_string_node>() - 4usize];
    ["Offset of field: pm_x_string_node::base"]
        [::std::mem::offset_of!(pm_x_string_node, base) - 0usize];
    ["Offset of field: pm_x_string_node::opening_loc"]
        [::std::mem::offset_of!(pm_x_string_node, opening_loc) - 16usize];
    ["Offset of field: pm_x_string_node::content_loc"]
        [::std::mem::offset_of!(pm_x_string_node, content_loc) - 24usize];
    ["Offset of field: pm_x_string_node::closing_loc"]
        [::std::mem::offset_of!(pm_x_string_node, closing_loc) - 32usize];
    ["Offset of field: pm_x_string_node::unescaped"]
        [::std::mem::offset_of!(pm_x_string_node, unescaped) - 40usize];
};
#[doc = " XStringNode\n\n Represents an xstring literal with no interpolation.\n\n     `foo`\n     ^^^^^\n\n Type: ::PM_X_STRING_NODE\n\n Flags (#pm_encoding_flags):\n * ::PM_ENCODING_FLAGS_FORCED_UTF8_ENCODING\n * ::PM_ENCODING_FLAGS_FORCED_BINARY_ENCODING\n\n @extends pm_node_t"]
pub type pm_x_string_node_t = pm_x_string_node;
#[doc = " YieldNode\n\n Represents the use of the `yield` keyword.\n\n     yield 1\n     ^^^^^^^\n\n Type: ::PM_YIELD_NODE\n\n @extends pm_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_yield_node {
    #[doc = " The embedded base node."]
    pub base: pm_node_t,
    #[doc = " YieldNode#keyword_loc"]
    pub keyword_loc: pm_location_t,
    #[doc = " YieldNode#lparen_loc"]
    pub lparen_loc: pm_location_t,
    #[doc = " YieldNode#arguments"]
    pub arguments: *mut pm_arguments_node,
    #[doc = " YieldNode#rparen_loc"]
    pub rparen_loc: pm_location_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_yield_node"][::std::mem::size_of::<pm_yield_node>() - 44usize];
    ["Alignment of pm_yield_node"][::std::mem::align_of::<pm_yield_node>() - 4usize];
    ["Offset of field: pm_yield_node::base"][::std::mem::offset_of!(pm_yield_node, base) - 0usize];
    ["Offset of field: pm_yield_node::keyword_loc"]
        [::std::mem::offset_of!(pm_yield_node, keyword_loc) - 16usize];
    ["Offset of field: pm_yield_node::lparen_loc"]
        [::std::mem::offset_of!(pm_yield_node, lparen_loc) - 24usize];
    ["Offset of field: pm_yield_node::arguments"]
        [::std::mem::offset_of!(pm_yield_node, arguments) - 32usize];
    ["Offset of field: pm_yield_node::rparen_loc"]
        [::std::mem::offset_of!(pm_yield_node, rparen_loc) - 36usize];
};
#[doc = " YieldNode\n\n Represents the use of the `yield` keyword.\n\n     yield 1\n     ^^^^^^^\n\n Type: ::PM_YIELD_NODE\n\n @extends pm_node_t"]
pub type pm_yield_node_t = pm_yield_node;
#[doc = " if the arguments contain forwarding"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_FORWARDING:
    pm_arguments_node_flags = 4;
#[doc = " if the arguments contain keywords"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORDS:
    pm_arguments_node_flags = 8;
#[doc = " if the arguments contain a keyword splat"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_KEYWORD_SPLAT:
    pm_arguments_node_flags = 16;
#[doc = " if the arguments contain a splat"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_SPLAT: pm_arguments_node_flags =
    32;
#[doc = " if the arguments contain multiple splats"]
pub const pm_arguments_node_flags_PM_ARGUMENTS_NODE_FLAGS_CONTAINS_MULTIPLE_SPLATS:
    pm_arguments_node_flags = 64;
#[doc = " Flags for arguments nodes."]
pub type pm_arguments_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for arguments nodes."]
pub use self::pm_arguments_node_flags as pm_arguments_node_flags_t;
#[doc = " if array contains splat nodes"]
pub const pm_array_node_flags_PM_ARRAY_NODE_FLAGS_CONTAINS_SPLAT: pm_array_node_flags = 4;
#[doc = " Flags for array nodes."]
pub type pm_array_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for array nodes."]
pub use self::pm_array_node_flags as pm_array_node_flags_t;
#[doc = " &. operator"]
pub const pm_call_node_flags_PM_CALL_NODE_FLAGS_SAFE_NAVIGATION: pm_call_node_flags = 4;
#[doc = " a call that could have been a local variable"]
pub const pm_call_node_flags_PM_CALL_NODE_FLAGS_VARIABLE_CALL: pm_call_node_flags = 8;
#[doc = " a call that is an attribute write, so the value being written should be returned"]
pub const pm_call_node_flags_PM_CALL_NODE_FLAGS_ATTRIBUTE_WRITE: pm_call_node_flags = 16;
#[doc = " a call that ignores method visibility"]
pub const pm_call_node_flags_PM_CALL_NODE_FLAGS_IGNORE_VISIBILITY: pm_call_node_flags = 32;
#[doc = " Flags for call nodes."]
pub type pm_call_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for call nodes."]
pub use self::pm_call_node_flags as pm_call_node_flags_t;
#[doc = " internal bytes forced the encoding to UTF-8"]
pub const pm_encoding_flags_PM_ENCODING_FLAGS_FORCED_UTF8_ENCODING: pm_encoding_flags = 4;
#[doc = " internal bytes forced the encoding to binary"]
pub const pm_encoding_flags_PM_ENCODING_FLAGS_FORCED_BINARY_ENCODING: pm_encoding_flags = 8;
#[doc = " Flags for nodes that have unescaped content."]
pub type pm_encoding_flags = ::std::os::raw::c_uint;
#[doc = " Flags for nodes that have unescaped content."]
pub use self::pm_encoding_flags as pm_encoding_flags_t;
#[doc = " 0b prefix"]
pub const pm_integer_base_flags_PM_INTEGER_BASE_FLAGS_BINARY: pm_integer_base_flags = 4;
#[doc = " 0d or no prefix"]
pub const pm_integer_base_flags_PM_INTEGER_BASE_FLAGS_DECIMAL: pm_integer_base_flags = 8;
#[doc = " 0o or 0 prefix"]
pub const pm_integer_base_flags_PM_INTEGER_BASE_FLAGS_OCTAL: pm_integer_base_flags = 16;
#[doc = " 0x prefix"]
pub const pm_integer_base_flags_PM_INTEGER_BASE_FLAGS_HEXADECIMAL: pm_integer_base_flags = 32;
#[doc = " Flags for integer nodes that correspond to the base of the integer."]
pub type pm_integer_base_flags = ::std::os::raw::c_uint;
#[doc = " Flags for integer nodes that correspond to the base of the integer."]
pub use self::pm_integer_base_flags as pm_integer_base_flags_t;
#[doc = " frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`"]
pub const pm_interpolated_string_node_flags_PM_INTERPOLATED_STRING_NODE_FLAGS_FROZEN:
    pm_interpolated_string_node_flags = 4;
#[doc = " mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`"]
pub const pm_interpolated_string_node_flags_PM_INTERPOLATED_STRING_NODE_FLAGS_MUTABLE:
    pm_interpolated_string_node_flags = 8;
#[doc = " Flags for interpolated string nodes that indicated mutability if they are also marked as literals."]
pub type pm_interpolated_string_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for interpolated string nodes that indicated mutability if they are also marked as literals."]
pub use self::pm_interpolated_string_node_flags as pm_interpolated_string_node_flags_t;
#[doc = " a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments"]
pub const pm_keyword_hash_node_flags_PM_KEYWORD_HASH_NODE_FLAGS_SYMBOL_KEYS:
    pm_keyword_hash_node_flags = 4;
#[doc = " Flags for keyword hash nodes."]
pub type pm_keyword_hash_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for keyword hash nodes."]
pub use self::pm_keyword_hash_node_flags as pm_keyword_hash_node_flags_t;
#[doc = " a loop after a begin statement, so the body is executed first before the condition"]
pub const pm_loop_flags_PM_LOOP_FLAGS_BEGIN_MODIFIER: pm_loop_flags = 4;
#[doc = " Flags for while and until loop nodes."]
pub type pm_loop_flags = ::std::os::raw::c_uint;
#[doc = " Flags for while and until loop nodes."]
pub use self::pm_loop_flags as pm_loop_flags_t;
#[doc = " a parameter name that has been repeated in the method signature"]
pub const pm_parameter_flags_PM_PARAMETER_FLAGS_REPEATED_PARAMETER: pm_parameter_flags = 4;
#[doc = " Flags for parameter nodes."]
pub type pm_parameter_flags = ::std::os::raw::c_uint;
#[doc = " Flags for parameter nodes."]
pub use self::pm_parameter_flags as pm_parameter_flags_t;
#[doc = " parentheses that contain multiple potentially void statements"]
pub const pm_parentheses_node_flags_PM_PARENTHESES_NODE_FLAGS_MULTIPLE_STATEMENTS:
    pm_parentheses_node_flags = 4;
#[doc = " Flags for parentheses nodes."]
pub type pm_parentheses_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for parentheses nodes."]
pub use self::pm_parentheses_node_flags as pm_parentheses_node_flags_t;
#[doc = " ... operator"]
pub const pm_range_flags_PM_RANGE_FLAGS_EXCLUDE_END: pm_range_flags = 4;
#[doc = " Flags for range and flip-flop nodes."]
pub type pm_range_flags = ::std::os::raw::c_uint;
#[doc = " Flags for range and flip-flop nodes."]
pub use self::pm_range_flags as pm_range_flags_t;
#[doc = " i - ignores the case of characters when matching"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_IGNORE_CASE:
    pm_regular_expression_flags = 4;
#[doc = " x - ignores whitespace and allows comments in regular expressions"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_EXTENDED:
    pm_regular_expression_flags = 8;
#[doc = " m - allows $ to match the end of lines within strings"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_MULTI_LINE:
    pm_regular_expression_flags = 16;
#[doc = " o - only interpolates values into the regular expression once"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_ONCE:
    pm_regular_expression_flags = 32;
#[doc = " e - forces the EUC-JP encoding"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_EUC_JP:
    pm_regular_expression_flags = 64;
#[doc = " n - forces the ASCII-8BIT encoding"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_ASCII_8BIT:
    pm_regular_expression_flags = 128;
#[doc = " s - forces the Windows-31J encoding"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_WINDOWS_31J:
    pm_regular_expression_flags = 256;
#[doc = " u - forces the UTF-8 encoding"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_UTF_8:
    pm_regular_expression_flags = 512;
#[doc = " internal bytes forced the encoding to UTF-8"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_FORCED_UTF8_ENCODING:
    pm_regular_expression_flags = 1024;
#[doc = " internal bytes forced the encoding to binary"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_FORCED_BINARY_ENCODING:
    pm_regular_expression_flags = 2048;
#[doc = " internal bytes forced the encoding to US-ASCII"]
pub const pm_regular_expression_flags_PM_REGULAR_EXPRESSION_FLAGS_FORCED_US_ASCII_ENCODING:
    pm_regular_expression_flags = 4096;
#[doc = " Flags for regular expression and match last line nodes."]
pub type pm_regular_expression_flags = ::std::os::raw::c_uint;
#[doc = " Flags for regular expression and match last line nodes."]
pub use self::pm_regular_expression_flags as pm_regular_expression_flags_t;
#[doc = " constant writes that should be modified with shareable constant value literal"]
pub const pm_shareable_constant_node_flags_PM_SHAREABLE_CONSTANT_NODE_FLAGS_LITERAL:
    pm_shareable_constant_node_flags = 4;
#[doc = " constant writes that should be modified with shareable constant value experimental everything"]
pub const pm_shareable_constant_node_flags_PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_EVERYTHING : pm_shareable_constant_node_flags = 8 ;
#[doc = " constant writes that should be modified with shareable constant value experimental copy"]
pub const pm_shareable_constant_node_flags_PM_SHAREABLE_CONSTANT_NODE_FLAGS_EXPERIMENTAL_COPY:
    pm_shareable_constant_node_flags = 16;
#[doc = " Flags for shareable constant nodes."]
pub type pm_shareable_constant_node_flags = ::std::os::raw::c_uint;
#[doc = " Flags for shareable constant nodes."]
pub use self::pm_shareable_constant_node_flags as pm_shareable_constant_node_flags_t;
#[doc = " internal bytes forced the encoding to UTF-8"]
pub const pm_string_flags_PM_STRING_FLAGS_FORCED_UTF8_ENCODING: pm_string_flags = 4;
#[doc = " internal bytes forced the encoding to binary"]
pub const pm_string_flags_PM_STRING_FLAGS_FORCED_BINARY_ENCODING: pm_string_flags = 8;
#[doc = " frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`"]
pub const pm_string_flags_PM_STRING_FLAGS_FROZEN: pm_string_flags = 16;
#[doc = " mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`"]
pub const pm_string_flags_PM_STRING_FLAGS_MUTABLE: pm_string_flags = 32;
#[doc = " Flags for string nodes."]
pub type pm_string_flags = ::std::os::raw::c_uint;
#[doc = " Flags for string nodes."]
pub use self::pm_string_flags as pm_string_flags_t;
#[doc = " internal bytes forced the encoding to UTF-8"]
pub const pm_symbol_flags_PM_SYMBOL_FLAGS_FORCED_UTF8_ENCODING: pm_symbol_flags = 4;
#[doc = " internal bytes forced the encoding to binary"]
pub const pm_symbol_flags_PM_SYMBOL_FLAGS_FORCED_BINARY_ENCODING: pm_symbol_flags = 8;
#[doc = " internal bytes forced the encoding to US-ASCII"]
pub const pm_symbol_flags_PM_SYMBOL_FLAGS_FORCED_US_ASCII_ENCODING: pm_symbol_flags = 16;
#[doc = " Flags for symbol nodes."]
pub type pm_symbol_flags = ::std::os::raw::c_uint;
#[doc = " Flags for symbol nodes."]
pub use self::pm_symbol_flags as pm_symbol_flags_t;
#[doc = " This struct represents an abstract linked list that provides common\n functionality. It is meant to be used any time a linked list is necessary to\n store data.\n\n The linked list itself operates off a set of pointers. Because the pointers\n are not necessarily sequential, they can be of any size. We use this fact to\n allow the consumer of this linked list to extend the node struct to include\n any data they want. This is done by using the pm_list_node_t as the first\n member of the struct.\n\n For example, if we want to store a list of integers, we can do the following:\n\n ```c\n typedef struct {\n     pm_list_node_t node;\n     int value;\n } pm_int_node_t;\n\n pm_list_t list = { 0 };\n pm_int_node_t *node = xmalloc(sizeof(pm_int_node_t));\n node->value = 5;\n\n pm_list_append(&list, &node->node);\n ```\n\n The pm_list_t struct is used to represent the overall linked list. It\n contains a pointer to the head and tail of the list. This allows for easy\n iteration and appending of new nodes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_list_node {
    #[doc = " A pointer to the next node in the list."]
    pub next: *mut pm_list_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_list_node"][::std::mem::size_of::<pm_list_node>() - 4usize];
    ["Alignment of pm_list_node"][::std::mem::align_of::<pm_list_node>() - 4usize];
    ["Offset of field: pm_list_node::next"][::std::mem::offset_of!(pm_list_node, next) - 0usize];
};
#[doc = " This struct represents an abstract linked list that provides common\n functionality. It is meant to be used any time a linked list is necessary to\n store data.\n\n The linked list itself operates off a set of pointers. Because the pointers\n are not necessarily sequential, they can be of any size. We use this fact to\n allow the consumer of this linked list to extend the node struct to include\n any data they want. This is done by using the pm_list_node_t as the first\n member of the struct.\n\n For example, if we want to store a list of integers, we can do the following:\n\n ```c\n typedef struct {\n     pm_list_node_t node;\n     int value;\n } pm_int_node_t;\n\n pm_list_t list = { 0 };\n pm_int_node_t *node = xmalloc(sizeof(pm_int_node_t));\n node->value = 5;\n\n pm_list_append(&list, &node->node);\n ```\n\n The pm_list_t struct is used to represent the overall linked list. It\n contains a pointer to the head and tail of the list. This allows for easy\n iteration and appending of new nodes."]
pub type pm_list_node_t = pm_list_node;
#[doc = " This represents the overall linked list. It keeps a pointer to the head and\n tail so that iteration is easy and pushing new nodes is easy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_list_t {
    #[doc = " The size of the list."]
    pub size: usize,
    #[doc = " A pointer to the head of the list."]
    pub head: *mut pm_list_node_t,
    #[doc = " A pointer to the tail of the list."]
    pub tail: *mut pm_list_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_list_t"][::std::mem::size_of::<pm_list_t>() - 12usize];
    ["Alignment of pm_list_t"][::std::mem::align_of::<pm_list_t>() - 4usize];
    ["Offset of field: pm_list_t::size"][::std::mem::offset_of!(pm_list_t, size) - 0usize];
    ["Offset of field: pm_list_t::head"][::std::mem::offset_of!(pm_list_t, head) - 4usize];
    ["Offset of field: pm_list_t::tail"][::std::mem::offset_of!(pm_list_t, tail) - 8usize];
};
pub const pm_diagnostic_id_t_PM_ERR_ALIAS_ARGUMENT: pm_diagnostic_id_t = 0;
pub const pm_diagnostic_id_t_PM_ERR_ALIAS_ARGUMENT_NUMBERED_REFERENCE: pm_diagnostic_id_t = 1;
pub const pm_diagnostic_id_t_PM_ERR_AMPAMPEQ_MULTI_ASSIGN: pm_diagnostic_id_t = 2;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_AFTER_BLOCK: pm_diagnostic_id_t = 3;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_AFTER_FORWARDING_ELLIPSES: pm_diagnostic_id_t = 4;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_BARE_HASH: pm_diagnostic_id_t = 5;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_BLOCK_FORWARDING: pm_diagnostic_id_t = 6;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_BLOCK_MULTI: pm_diagnostic_id_t = 7;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_CONFLICT_AMPERSAND: pm_diagnostic_id_t = 8;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_CONFLICT_STAR: pm_diagnostic_id_t = 9;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_CONFLICT_STAR_STAR: pm_diagnostic_id_t = 10;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORMAL_CLASS: pm_diagnostic_id_t = 11;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORMAL_CONSTANT: pm_diagnostic_id_t = 12;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORMAL_GLOBAL: pm_diagnostic_id_t = 13;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORMAL_IVAR: pm_diagnostic_id_t = 14;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_FORWARDING_UNBOUND: pm_diagnostic_id_t = 15;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_NO_FORWARDING_AMPERSAND: pm_diagnostic_id_t = 16;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_NO_FORWARDING_ELLIPSES: pm_diagnostic_id_t = 17;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_NO_FORWARDING_STAR: pm_diagnostic_id_t = 18;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_NO_FORWARDING_STAR_STAR: pm_diagnostic_id_t = 19;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_SPLAT_AFTER_ASSOC_SPLAT: pm_diagnostic_id_t = 20;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_SPLAT_AFTER_SPLAT: pm_diagnostic_id_t = 21;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_TERM_PAREN: pm_diagnostic_id_t = 22;
pub const pm_diagnostic_id_t_PM_ERR_ARGUMENT_UNEXPECTED_BLOCK: pm_diagnostic_id_t = 23;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_ELEMENT: pm_diagnostic_id_t = 24;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_EXPRESSION: pm_diagnostic_id_t = 25;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_EXPRESSION_AFTER_STAR: pm_diagnostic_id_t = 26;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_SEPARATOR: pm_diagnostic_id_t = 27;
pub const pm_diagnostic_id_t_PM_ERR_ARRAY_TERM: pm_diagnostic_id_t = 28;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_LONELY_ELSE: pm_diagnostic_id_t = 29;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_TERM: pm_diagnostic_id_t = 30;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_UPCASE_BRACE: pm_diagnostic_id_t = 31;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_UPCASE_TERM: pm_diagnostic_id_t = 32;
pub const pm_diagnostic_id_t_PM_ERR_BEGIN_UPCASE_TOPLEVEL: pm_diagnostic_id_t = 33;
pub const pm_diagnostic_id_t_PM_ERR_BLOCK_PARAM_LOCAL_VARIABLE: pm_diagnostic_id_t = 34;
pub const pm_diagnostic_id_t_PM_ERR_BLOCK_PARAM_PIPE_TERM: pm_diagnostic_id_t = 35;
pub const pm_diagnostic_id_t_PM_ERR_BLOCK_TERM_BRACE: pm_diagnostic_id_t = 36;
pub const pm_diagnostic_id_t_PM_ERR_BLOCK_TERM_END: pm_diagnostic_id_t = 37;
pub const pm_diagnostic_id_t_PM_ERR_CANNOT_PARSE_EXPRESSION: pm_diagnostic_id_t = 38;
pub const pm_diagnostic_id_t_PM_ERR_CANNOT_PARSE_STRING_PART: pm_diagnostic_id_t = 39;
pub const pm_diagnostic_id_t_PM_ERR_CASE_EXPRESSION_AFTER_CASE: pm_diagnostic_id_t = 40;
pub const pm_diagnostic_id_t_PM_ERR_CASE_EXPRESSION_AFTER_WHEN: pm_diagnostic_id_t = 41;
pub const pm_diagnostic_id_t_PM_ERR_CASE_MATCH_MISSING_PREDICATE: pm_diagnostic_id_t = 42;
pub const pm_diagnostic_id_t_PM_ERR_CASE_MISSING_CONDITIONS: pm_diagnostic_id_t = 43;
pub const pm_diagnostic_id_t_PM_ERR_CASE_TERM: pm_diagnostic_id_t = 44;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_IN_METHOD: pm_diagnostic_id_t = 45;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_NAME: pm_diagnostic_id_t = 46;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_SUPERCLASS: pm_diagnostic_id_t = 47;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_TERM: pm_diagnostic_id_t = 48;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_UNEXPECTED_END: pm_diagnostic_id_t = 49;
pub const pm_diagnostic_id_t_PM_ERR_CLASS_VARIABLE_BARE: pm_diagnostic_id_t = 50;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_ELSIF_PREDICATE: pm_diagnostic_id_t = 51;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_IF_PREDICATE: pm_diagnostic_id_t = 52;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_PREDICATE_TERM: pm_diagnostic_id_t = 53;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_TERM: pm_diagnostic_id_t = 54;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_TERM_ELSE: pm_diagnostic_id_t = 55;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_UNLESS_PREDICATE: pm_diagnostic_id_t = 56;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_UNTIL_PREDICATE: pm_diagnostic_id_t = 57;
pub const pm_diagnostic_id_t_PM_ERR_CONDITIONAL_WHILE_PREDICATE: pm_diagnostic_id_t = 58;
pub const pm_diagnostic_id_t_PM_ERR_CONSTANT_PATH_COLON_COLON_CONSTANT: pm_diagnostic_id_t = 59;
pub const pm_diagnostic_id_t_PM_ERR_DEF_ENDLESS: pm_diagnostic_id_t = 60;
pub const pm_diagnostic_id_t_PM_ERR_DEF_ENDLESS_SETTER: pm_diagnostic_id_t = 61;
pub const pm_diagnostic_id_t_PM_ERR_DEF_NAME: pm_diagnostic_id_t = 62;
pub const pm_diagnostic_id_t_PM_ERR_DEF_PARAMS_TERM: pm_diagnostic_id_t = 63;
pub const pm_diagnostic_id_t_PM_ERR_DEF_PARAMS_TERM_PAREN: pm_diagnostic_id_t = 64;
pub const pm_diagnostic_id_t_PM_ERR_DEF_RECEIVER: pm_diagnostic_id_t = 65;
pub const pm_diagnostic_id_t_PM_ERR_DEF_RECEIVER_TERM: pm_diagnostic_id_t = 66;
pub const pm_diagnostic_id_t_PM_ERR_DEF_TERM: pm_diagnostic_id_t = 67;
pub const pm_diagnostic_id_t_PM_ERR_DEFINED_EXPRESSION: pm_diagnostic_id_t = 68;
pub const pm_diagnostic_id_t_PM_ERR_EMBDOC_TERM: pm_diagnostic_id_t = 69;
pub const pm_diagnostic_id_t_PM_ERR_EMBEXPR_END: pm_diagnostic_id_t = 70;
pub const pm_diagnostic_id_t_PM_ERR_EMBVAR_INVALID: pm_diagnostic_id_t = 71;
pub const pm_diagnostic_id_t_PM_ERR_END_UPCASE_BRACE: pm_diagnostic_id_t = 72;
pub const pm_diagnostic_id_t_PM_ERR_END_UPCASE_TERM: pm_diagnostic_id_t = 73;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_CONTROL: pm_diagnostic_id_t = 74;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_CONTROL_REPEAT: pm_diagnostic_id_t = 75;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_HEXADECIMAL: pm_diagnostic_id_t = 76;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_META: pm_diagnostic_id_t = 77;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_META_REPEAT: pm_diagnostic_id_t = 78;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE: pm_diagnostic_id_t = 79;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_CM_FLAGS: pm_diagnostic_id_t = 80;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_LIST: pm_diagnostic_id_t = 81;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_LITERAL: pm_diagnostic_id_t = 82;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_LONG: pm_diagnostic_id_t = 83;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_SHORT: pm_diagnostic_id_t = 84;
pub const pm_diagnostic_id_t_PM_ERR_ESCAPE_INVALID_UNICODE_TERM: pm_diagnostic_id_t = 85;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_ARGUMENT: pm_diagnostic_id_t = 86;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EOL_AFTER_STATEMENT: pm_diagnostic_id_t = 87;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_AMPAMPEQ: pm_diagnostic_id_t = 88;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_COMMA: pm_diagnostic_id_t = 89;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_EQUAL: pm_diagnostic_id_t = 90;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_LESS_LESS: pm_diagnostic_id_t = 91;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_LPAREN: pm_diagnostic_id_t = 92;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_OPERATOR: pm_diagnostic_id_t = 93;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_PIPEPIPEEQ: pm_diagnostic_id_t = 94;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_QUESTION: pm_diagnostic_id_t = 95;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_SPLAT: pm_diagnostic_id_t = 96;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_SPLAT_HASH: pm_diagnostic_id_t = 97;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_EXPRESSION_AFTER_STAR: pm_diagnostic_id_t = 98;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_FOR_DELIMITER: pm_diagnostic_id_t = 99;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_IDENT_REQ_PARAMETER: pm_diagnostic_id_t = 100;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_IN_DELIMITER: pm_diagnostic_id_t = 101;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_LPAREN_REQ_PARAMETER: pm_diagnostic_id_t = 102;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_MESSAGE: pm_diagnostic_id_t = 103;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_RBRACKET: pm_diagnostic_id_t = 104;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_RPAREN: pm_diagnostic_id_t = 105;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_RPAREN_AFTER_MULTI: pm_diagnostic_id_t = 106;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_RPAREN_REQ_PARAMETER: pm_diagnostic_id_t = 107;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_SINGLETON_CLASS_DELIMITER: pm_diagnostic_id_t = 108;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_STRING_CONTENT: pm_diagnostic_id_t = 109;
pub const pm_diagnostic_id_t_PM_ERR_EXPECT_WHEN_DELIMITER: pm_diagnostic_id_t = 110;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_BARE_HASH: pm_diagnostic_id_t = 111;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE: pm_diagnostic_id_t = 112;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_ENCODING: pm_diagnostic_id_t = 113;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_FALSE: pm_diagnostic_id_t = 114;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_FILE: pm_diagnostic_id_t = 115;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_LINE: pm_diagnostic_id_t = 116;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_NIL: pm_diagnostic_id_t = 117;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_NUMBERED: pm_diagnostic_id_t = 118;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_SELF: pm_diagnostic_id_t = 119;
pub const pm_diagnostic_id_t_PM_ERR_EXPRESSION_NOT_WRITABLE_TRUE: pm_diagnostic_id_t = 120;
pub const pm_diagnostic_id_t_PM_ERR_FLOAT_PARSE: pm_diagnostic_id_t = 121;
pub const pm_diagnostic_id_t_PM_ERR_FOR_COLLECTION: pm_diagnostic_id_t = 122;
pub const pm_diagnostic_id_t_PM_ERR_FOR_IN: pm_diagnostic_id_t = 123;
pub const pm_diagnostic_id_t_PM_ERR_FOR_INDEX: pm_diagnostic_id_t = 124;
pub const pm_diagnostic_id_t_PM_ERR_FOR_TERM: pm_diagnostic_id_t = 125;
pub const pm_diagnostic_id_t_PM_ERR_GLOBAL_VARIABLE_BARE: pm_diagnostic_id_t = 126;
pub const pm_diagnostic_id_t_PM_ERR_HASH_EXPRESSION_AFTER_LABEL: pm_diagnostic_id_t = 127;
pub const pm_diagnostic_id_t_PM_ERR_HASH_KEY: pm_diagnostic_id_t = 128;
pub const pm_diagnostic_id_t_PM_ERR_HASH_ROCKET: pm_diagnostic_id_t = 129;
pub const pm_diagnostic_id_t_PM_ERR_HASH_TERM: pm_diagnostic_id_t = 130;
pub const pm_diagnostic_id_t_PM_ERR_HASH_VALUE: pm_diagnostic_id_t = 131;
pub const pm_diagnostic_id_t_PM_ERR_HEREDOC_IDENTIFIER: pm_diagnostic_id_t = 132;
pub const pm_diagnostic_id_t_PM_ERR_HEREDOC_TERM: pm_diagnostic_id_t = 133;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_QUESTION_MARK: pm_diagnostic_id_t = 134;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_VARIABLE_CLASS: pm_diagnostic_id_t = 135;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_VARIABLE_CLASS_3_3: pm_diagnostic_id_t = 136;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_VARIABLE_INSTANCE: pm_diagnostic_id_t = 137;
pub const pm_diagnostic_id_t_PM_ERR_INCOMPLETE_VARIABLE_INSTANCE_3_3: pm_diagnostic_id_t = 138;
pub const pm_diagnostic_id_t_PM_ERR_INSTANCE_VARIABLE_BARE: pm_diagnostic_id_t = 139;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_BLOCK_EXIT: pm_diagnostic_id_t = 140;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_CHARACTER: pm_diagnostic_id_t = 141;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_COMMA: pm_diagnostic_id_t = 142;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_ENCODING_MAGIC_COMMENT: pm_diagnostic_id_t = 143;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_ESCAPE_CHARACTER: pm_diagnostic_id_t = 144;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_FLOAT_EXPONENT: pm_diagnostic_id_t = 145;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_LOCAL_VARIABLE_READ: pm_diagnostic_id_t = 146;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_LOCAL_VARIABLE_WRITE: pm_diagnostic_id_t = 147;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_MULTIBYTE_CHAR: pm_diagnostic_id_t = 148;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_MULTIBYTE_CHARACTER: pm_diagnostic_id_t = 149;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_MULTIBYTE_ESCAPE: pm_diagnostic_id_t = 150;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_BINARY: pm_diagnostic_id_t = 151;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_DECIMAL: pm_diagnostic_id_t = 152;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_FRACTION: pm_diagnostic_id_t = 153;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_HEXADECIMAL: pm_diagnostic_id_t = 154;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_OCTAL: pm_diagnostic_id_t = 155;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_UNDERSCORE_INNER: pm_diagnostic_id_t = 156;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_NUMBER_UNDERSCORE_TRAILING: pm_diagnostic_id_t = 157;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_PERCENT: pm_diagnostic_id_t = 158;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_PERCENT_EOF: pm_diagnostic_id_t = 159;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_PRINTABLE_CHARACTER: pm_diagnostic_id_t = 160;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_RETRY_AFTER_ELSE: pm_diagnostic_id_t = 161;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_RETRY_AFTER_ENSURE: pm_diagnostic_id_t = 162;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_RETRY_WITHOUT_RESCUE: pm_diagnostic_id_t = 163;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_SYMBOL: pm_diagnostic_id_t = 164;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_VARIABLE_GLOBAL: pm_diagnostic_id_t = 165;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_VARIABLE_GLOBAL_3_3: pm_diagnostic_id_t = 166;
pub const pm_diagnostic_id_t_PM_ERR_INVALID_YIELD: pm_diagnostic_id_t = 167;
pub const pm_diagnostic_id_t_PM_ERR_IT_NOT_ALLOWED_NUMBERED: pm_diagnostic_id_t = 168;
pub const pm_diagnostic_id_t_PM_ERR_IT_NOT_ALLOWED_ORDINARY: pm_diagnostic_id_t = 169;
pub const pm_diagnostic_id_t_PM_ERR_LAMBDA_OPEN: pm_diagnostic_id_t = 170;
pub const pm_diagnostic_id_t_PM_ERR_LAMBDA_TERM_BRACE: pm_diagnostic_id_t = 171;
pub const pm_diagnostic_id_t_PM_ERR_LAMBDA_TERM_END: pm_diagnostic_id_t = 172;
pub const pm_diagnostic_id_t_PM_ERR_LIST_I_LOWER_ELEMENT: pm_diagnostic_id_t = 173;
pub const pm_diagnostic_id_t_PM_ERR_LIST_I_LOWER_TERM: pm_diagnostic_id_t = 174;
pub const pm_diagnostic_id_t_PM_ERR_LIST_I_UPPER_ELEMENT: pm_diagnostic_id_t = 175;
pub const pm_diagnostic_id_t_PM_ERR_LIST_I_UPPER_TERM: pm_diagnostic_id_t = 176;
pub const pm_diagnostic_id_t_PM_ERR_LIST_W_LOWER_ELEMENT: pm_diagnostic_id_t = 177;
pub const pm_diagnostic_id_t_PM_ERR_LIST_W_LOWER_TERM: pm_diagnostic_id_t = 178;
pub const pm_diagnostic_id_t_PM_ERR_LIST_W_UPPER_ELEMENT: pm_diagnostic_id_t = 179;
pub const pm_diagnostic_id_t_PM_ERR_LIST_W_UPPER_TERM: pm_diagnostic_id_t = 180;
pub const pm_diagnostic_id_t_PM_ERR_MALLOC_FAILED: pm_diagnostic_id_t = 181;
pub const pm_diagnostic_id_t_PM_ERR_MIXED_ENCODING: pm_diagnostic_id_t = 182;
pub const pm_diagnostic_id_t_PM_ERR_MODULE_IN_METHOD: pm_diagnostic_id_t = 183;
pub const pm_diagnostic_id_t_PM_ERR_MODULE_NAME: pm_diagnostic_id_t = 184;
pub const pm_diagnostic_id_t_PM_ERR_MODULE_TERM: pm_diagnostic_id_t = 185;
pub const pm_diagnostic_id_t_PM_ERR_MULTI_ASSIGN_MULTI_SPLATS: pm_diagnostic_id_t = 186;
pub const pm_diagnostic_id_t_PM_ERR_MULTI_ASSIGN_UNEXPECTED_REST: pm_diagnostic_id_t = 187;
pub const pm_diagnostic_id_t_PM_ERR_NESTING_TOO_DEEP: pm_diagnostic_id_t = 188;
pub const pm_diagnostic_id_t_PM_ERR_NO_LOCAL_VARIABLE: pm_diagnostic_id_t = 189;
pub const pm_diagnostic_id_t_PM_ERR_NON_ASSOCIATIVE_OPERATOR: pm_diagnostic_id_t = 190;
pub const pm_diagnostic_id_t_PM_ERR_NOT_EXPRESSION: pm_diagnostic_id_t = 191;
pub const pm_diagnostic_id_t_PM_ERR_NUMBER_LITERAL_UNDERSCORE: pm_diagnostic_id_t = 192;
pub const pm_diagnostic_id_t_PM_ERR_NUMBERED_PARAMETER_INNER_BLOCK: pm_diagnostic_id_t = 193;
pub const pm_diagnostic_id_t_PM_ERR_NUMBERED_PARAMETER_IT: pm_diagnostic_id_t = 194;
pub const pm_diagnostic_id_t_PM_ERR_NUMBERED_PARAMETER_ORDINARY: pm_diagnostic_id_t = 195;
pub const pm_diagnostic_id_t_PM_ERR_NUMBERED_PARAMETER_OUTER_BLOCK: pm_diagnostic_id_t = 196;
pub const pm_diagnostic_id_t_PM_ERR_OPERATOR_MULTI_ASSIGN: pm_diagnostic_id_t = 197;
pub const pm_diagnostic_id_t_PM_ERR_OPERATOR_WRITE_ARGUMENTS: pm_diagnostic_id_t = 198;
pub const pm_diagnostic_id_t_PM_ERR_OPERATOR_WRITE_BLOCK: pm_diagnostic_id_t = 199;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_ASSOC_SPLAT_MULTI: pm_diagnostic_id_t = 200;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_BLOCK_MULTI: pm_diagnostic_id_t = 201;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_CIRCULAR: pm_diagnostic_id_t = 202;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_FORWARDING_AFTER_REST: pm_diagnostic_id_t = 203;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_METHOD_NAME: pm_diagnostic_id_t = 204;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_NAME_DUPLICATED: pm_diagnostic_id_t = 205;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_NO_DEFAULT: pm_diagnostic_id_t = 206;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_NO_DEFAULT_KW: pm_diagnostic_id_t = 207;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_NUMBERED_RESERVED: pm_diagnostic_id_t = 208;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_ORDER: pm_diagnostic_id_t = 209;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_SPLAT_MULTI: pm_diagnostic_id_t = 210;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_STAR: pm_diagnostic_id_t = 211;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_UNEXPECTED_FWD: pm_diagnostic_id_t = 212;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_UNEXPECTED_NO_KW: pm_diagnostic_id_t = 213;
pub const pm_diagnostic_id_t_PM_ERR_PARAMETER_WILD_LOOSE_COMMA: pm_diagnostic_id_t = 214;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_ARRAY_MULTIPLE_RESTS: pm_diagnostic_id_t = 215;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_CAPTURE_DUPLICATE: pm_diagnostic_id_t = 216;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_BRACKET: pm_diagnostic_id_t = 217;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_COMMA: pm_diagnostic_id_t = 218;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_HROCKET: pm_diagnostic_id_t = 219;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_IN: pm_diagnostic_id_t = 220;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_KEY: pm_diagnostic_id_t = 221;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_PAREN: pm_diagnostic_id_t = 222;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_PIN: pm_diagnostic_id_t = 223;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_PIPE: pm_diagnostic_id_t = 224;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_RANGE: pm_diagnostic_id_t = 225;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_EXPRESSION_AFTER_REST: pm_diagnostic_id_t = 226;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_FIND_MISSING_INNER: pm_diagnostic_id_t = 227;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_IMPLICIT: pm_diagnostic_id_t = 228;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY: pm_diagnostic_id_t = 229;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY_DUPLICATE: pm_diagnostic_id_t = 230;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY_INTERPOLATED: pm_diagnostic_id_t = 231;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY_LABEL: pm_diagnostic_id_t = 232;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_HASH_KEY_LOCALS: pm_diagnostic_id_t = 233;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_IDENT_AFTER_HROCKET: pm_diagnostic_id_t = 234;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_LABEL_AFTER_COMMA: pm_diagnostic_id_t = 235;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_REST: pm_diagnostic_id_t = 236;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_TERM_BRACE: pm_diagnostic_id_t = 237;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_TERM_BRACKET: pm_diagnostic_id_t = 238;
pub const pm_diagnostic_id_t_PM_ERR_PATTERN_TERM_PAREN: pm_diagnostic_id_t = 239;
pub const pm_diagnostic_id_t_PM_ERR_PIPEPIPEEQ_MULTI_ASSIGN: pm_diagnostic_id_t = 240;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_ENCODING_OPTION_MISMATCH: pm_diagnostic_id_t = 241;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_INCOMPAT_CHAR_ENCODING: pm_diagnostic_id_t = 242;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_INVALID_UNICODE_RANGE: pm_diagnostic_id_t = 243;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_NON_ESCAPED_MBC: pm_diagnostic_id_t = 244;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_PARSE_ERROR: pm_diagnostic_id_t = 245;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_TERM: pm_diagnostic_id_t = 246;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_UNKNOWN_OPTIONS: pm_diagnostic_id_t = 247;
pub const pm_diagnostic_id_t_PM_ERR_REGEXP_UTF8_CHAR_NON_UTF8_REGEXP: pm_diagnostic_id_t = 248;
pub const pm_diagnostic_id_t_PM_ERR_RESCUE_EXPRESSION: pm_diagnostic_id_t = 249;
pub const pm_diagnostic_id_t_PM_ERR_RESCUE_MODIFIER_VALUE: pm_diagnostic_id_t = 250;
pub const pm_diagnostic_id_t_PM_ERR_RESCUE_TERM: pm_diagnostic_id_t = 251;
pub const pm_diagnostic_id_t_PM_ERR_RESCUE_VARIABLE: pm_diagnostic_id_t = 252;
pub const pm_diagnostic_id_t_PM_ERR_RETURN_INVALID: pm_diagnostic_id_t = 253;
pub const pm_diagnostic_id_t_PM_ERR_SCRIPT_NOT_FOUND: pm_diagnostic_id_t = 254;
pub const pm_diagnostic_id_t_PM_ERR_SINGLETON_FOR_LITERALS: pm_diagnostic_id_t = 255;
pub const pm_diagnostic_id_t_PM_ERR_STATEMENT_ALIAS: pm_diagnostic_id_t = 256;
pub const pm_diagnostic_id_t_PM_ERR_STATEMENT_POSTEXE_END: pm_diagnostic_id_t = 257;
pub const pm_diagnostic_id_t_PM_ERR_STATEMENT_PREEXE_BEGIN: pm_diagnostic_id_t = 258;
pub const pm_diagnostic_id_t_PM_ERR_STATEMENT_UNDEF: pm_diagnostic_id_t = 259;
pub const pm_diagnostic_id_t_PM_ERR_STRING_CONCATENATION: pm_diagnostic_id_t = 260;
pub const pm_diagnostic_id_t_PM_ERR_STRING_INTERPOLATED_TERM: pm_diagnostic_id_t = 261;
pub const pm_diagnostic_id_t_PM_ERR_STRING_LITERAL_EOF: pm_diagnostic_id_t = 262;
pub const pm_diagnostic_id_t_PM_ERR_STRING_LITERAL_TERM: pm_diagnostic_id_t = 263;
pub const pm_diagnostic_id_t_PM_ERR_SYMBOL_INVALID: pm_diagnostic_id_t = 264;
pub const pm_diagnostic_id_t_PM_ERR_SYMBOL_TERM_DYNAMIC: pm_diagnostic_id_t = 265;
pub const pm_diagnostic_id_t_PM_ERR_SYMBOL_TERM_INTERPOLATED: pm_diagnostic_id_t = 266;
pub const pm_diagnostic_id_t_PM_ERR_TERNARY_COLON: pm_diagnostic_id_t = 267;
pub const pm_diagnostic_id_t_PM_ERR_TERNARY_EXPRESSION_FALSE: pm_diagnostic_id_t = 268;
pub const pm_diagnostic_id_t_PM_ERR_TERNARY_EXPRESSION_TRUE: pm_diagnostic_id_t = 269;
pub const pm_diagnostic_id_t_PM_ERR_UNARY_DISALLOWED: pm_diagnostic_id_t = 270;
pub const pm_diagnostic_id_t_PM_ERR_UNARY_RECEIVER: pm_diagnostic_id_t = 271;
pub const pm_diagnostic_id_t_PM_ERR_UNDEF_ARGUMENT: pm_diagnostic_id_t = 272;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_BLOCK_ARGUMENT: pm_diagnostic_id_t = 273;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_INDEX_BLOCK: pm_diagnostic_id_t = 274;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_INDEX_KEYWORDS: pm_diagnostic_id_t = 275;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_LABEL: pm_diagnostic_id_t = 276;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_MULTI_WRITE: pm_diagnostic_id_t = 277;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_RANGE_OPERATOR: pm_diagnostic_id_t = 278;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_SAFE_NAVIGATION: pm_diagnostic_id_t = 279;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_TOKEN_CLOSE_CONTEXT: pm_diagnostic_id_t = 280;
pub const pm_diagnostic_id_t_PM_ERR_UNEXPECTED_TOKEN_IGNORE: pm_diagnostic_id_t = 281;
pub const pm_diagnostic_id_t_PM_ERR_UNTIL_TERM: pm_diagnostic_id_t = 282;
pub const pm_diagnostic_id_t_PM_ERR_VOID_EXPRESSION: pm_diagnostic_id_t = 283;
pub const pm_diagnostic_id_t_PM_ERR_WHILE_TERM: pm_diagnostic_id_t = 284;
pub const pm_diagnostic_id_t_PM_ERR_WRITE_TARGET_IN_METHOD: pm_diagnostic_id_t = 285;
pub const pm_diagnostic_id_t_PM_ERR_WRITE_TARGET_READONLY: pm_diagnostic_id_t = 286;
pub const pm_diagnostic_id_t_PM_ERR_WRITE_TARGET_UNEXPECTED: pm_diagnostic_id_t = 287;
pub const pm_diagnostic_id_t_PM_ERR_XSTRING_TERM: pm_diagnostic_id_t = 288;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_BINARY_OPERATOR: pm_diagnostic_id_t = 289;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_FIRST_ARGUMENT_MINUS: pm_diagnostic_id_t = 290;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_FIRST_ARGUMENT_PLUS: pm_diagnostic_id_t = 291;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_PREFIX_AMPERSAND: pm_diagnostic_id_t = 292;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_PREFIX_STAR: pm_diagnostic_id_t = 293;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_PREFIX_STAR_STAR: pm_diagnostic_id_t = 294;
pub const pm_diagnostic_id_t_PM_WARN_AMBIGUOUS_SLASH: pm_diagnostic_id_t = 295;
pub const pm_diagnostic_id_t_PM_WARN_COMPARISON_AFTER_COMPARISON: pm_diagnostic_id_t = 296;
pub const pm_diagnostic_id_t_PM_WARN_DOT_DOT_DOT_EOL: pm_diagnostic_id_t = 297;
pub const pm_diagnostic_id_t_PM_WARN_EQUAL_IN_CONDITIONAL: pm_diagnostic_id_t = 298;
pub const pm_diagnostic_id_t_PM_WARN_EQUAL_IN_CONDITIONAL_3_3: pm_diagnostic_id_t = 299;
pub const pm_diagnostic_id_t_PM_WARN_END_IN_METHOD: pm_diagnostic_id_t = 300;
pub const pm_diagnostic_id_t_PM_WARN_DUPLICATED_HASH_KEY: pm_diagnostic_id_t = 301;
pub const pm_diagnostic_id_t_PM_WARN_DUPLICATED_WHEN_CLAUSE: pm_diagnostic_id_t = 302;
pub const pm_diagnostic_id_t_PM_WARN_FLOAT_OUT_OF_RANGE: pm_diagnostic_id_t = 303;
pub const pm_diagnostic_id_t_PM_WARN_IGNORED_FROZEN_STRING_LITERAL: pm_diagnostic_id_t = 304;
pub const pm_diagnostic_id_t_PM_WARN_INDENTATION_MISMATCH: pm_diagnostic_id_t = 305;
pub const pm_diagnostic_id_t_PM_WARN_INTEGER_IN_FLIP_FLOP: pm_diagnostic_id_t = 306;
pub const pm_diagnostic_id_t_PM_WARN_INVALID_CHARACTER: pm_diagnostic_id_t = 307;
pub const pm_diagnostic_id_t_PM_WARN_INVALID_MAGIC_COMMENT_VALUE: pm_diagnostic_id_t = 308;
pub const pm_diagnostic_id_t_PM_WARN_INVALID_NUMBERED_REFERENCE: pm_diagnostic_id_t = 309;
pub const pm_diagnostic_id_t_PM_WARN_KEYWORD_EOL: pm_diagnostic_id_t = 310;
pub const pm_diagnostic_id_t_PM_WARN_LITERAL_IN_CONDITION_DEFAULT: pm_diagnostic_id_t = 311;
pub const pm_diagnostic_id_t_PM_WARN_LITERAL_IN_CONDITION_VERBOSE: pm_diagnostic_id_t = 312;
pub const pm_diagnostic_id_t_PM_WARN_SHAREABLE_CONSTANT_VALUE_LINE: pm_diagnostic_id_t = 313;
pub const pm_diagnostic_id_t_PM_WARN_SHEBANG_CARRIAGE_RETURN: pm_diagnostic_id_t = 314;
pub const pm_diagnostic_id_t_PM_WARN_UNEXPECTED_CARRIAGE_RETURN: pm_diagnostic_id_t = 315;
pub const pm_diagnostic_id_t_PM_WARN_UNREACHABLE_STATEMENT: pm_diagnostic_id_t = 316;
pub const pm_diagnostic_id_t_PM_WARN_UNUSED_LOCAL_VARIABLE: pm_diagnostic_id_t = 317;
pub const pm_diagnostic_id_t_PM_WARN_VOID_STATEMENT: pm_diagnostic_id_t = 318;
#[doc = " The diagnostic IDs of all of the diagnostics, used to communicate the types\n of errors between the parser and the user."]
pub type pm_diagnostic_id_t = ::std::os::raw::c_uint;
#[doc = " This struct represents a diagnostic generated during parsing.\n\n @extends pm_list_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_diagnostic_t {
    #[doc = " The embedded base node."]
    pub node: pm_list_node_t,
    #[doc = " The location of the diagnostic in the source."]
    pub location: pm_location_t,
    #[doc = " The ID of the diagnostic."]
    pub diag_id: pm_diagnostic_id_t,
    #[doc = " The message associated with the diagnostic."]
    pub message: *const ::std::os::raw::c_char,
    #[doc = " Whether or not the memory related to the message of this diagnostic is\n owned by this diagnostic. If it is, it needs to be freed when the\n diagnostic is freed."]
    pub owned: bool,
    #[doc = " The level of the diagnostic, see `pm_error_level_t` and\n `pm_warning_level_t` for possible values."]
    pub level: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_diagnostic_t"][::std::mem::size_of::<pm_diagnostic_t>() - 24usize];
    ["Alignment of pm_diagnostic_t"][::std::mem::align_of::<pm_diagnostic_t>() - 4usize];
    ["Offset of field: pm_diagnostic_t::node"]
        [::std::mem::offset_of!(pm_diagnostic_t, node) - 0usize];
    ["Offset of field: pm_diagnostic_t::location"]
        [::std::mem::offset_of!(pm_diagnostic_t, location) - 4usize];
    ["Offset of field: pm_diagnostic_t::diag_id"]
        [::std::mem::offset_of!(pm_diagnostic_t, diag_id) - 12usize];
    ["Offset of field: pm_diagnostic_t::message"]
        [::std::mem::offset_of!(pm_diagnostic_t, message) - 16usize];
    ["Offset of field: pm_diagnostic_t::owned"]
        [::std::mem::offset_of!(pm_diagnostic_t, owned) - 20usize];
    ["Offset of field: pm_diagnostic_t::level"]
        [::std::mem::offset_of!(pm_diagnostic_t, level) - 21usize];
};
#[doc = " For errors that should raise a syntax error."]
pub const pm_error_level_t_PM_ERROR_LEVEL_SYNTAX: pm_error_level_t = 0;
#[doc = " For errors that should raise an argument error."]
pub const pm_error_level_t_PM_ERROR_LEVEL_ARGUMENT: pm_error_level_t = 1;
#[doc = " For errors that should raise a load error."]
pub const pm_error_level_t_PM_ERROR_LEVEL_LOAD: pm_error_level_t = 2;
#[doc = " The levels of errors generated during parsing."]
pub type pm_error_level_t = ::std::os::raw::c_uint;
#[doc = " For warnings which should be emitted if $VERBOSE != nil."]
pub const pm_warning_level_t_PM_WARNING_LEVEL_DEFAULT: pm_warning_level_t = 0;
#[doc = " For warnings which should be emitted if $VERBOSE == true."]
pub const pm_warning_level_t_PM_WARNING_LEVEL_VERBOSE: pm_warning_level_t = 1;
#[doc = " The levels of warnings generated during parsing."]
pub type pm_warning_level_t = ::std::os::raw::c_uint;
#[doc = " A scope of locals surrounding the code that is being parsed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_options_scope {
    #[doc = " The number of locals in the scope."]
    pub locals_count: usize,
    #[doc = " The names of the locals in the scope."]
    pub locals: *mut pm_string_t,
    #[doc = " Flags for the set of forwarding parameters in this scope."]
    pub forwarding: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_options_scope"][::std::mem::size_of::<pm_options_scope>() - 12usize];
    ["Alignment of pm_options_scope"][::std::mem::align_of::<pm_options_scope>() - 4usize];
    ["Offset of field: pm_options_scope::locals_count"]
        [::std::mem::offset_of!(pm_options_scope, locals_count) - 0usize];
    ["Offset of field: pm_options_scope::locals"]
        [::std::mem::offset_of!(pm_options_scope, locals) - 4usize];
    ["Offset of field: pm_options_scope::forwarding"]
        [::std::mem::offset_of!(pm_options_scope, forwarding) - 8usize];
};
#[doc = " A scope of locals surrounding the code that is being parsed."]
pub type pm_options_scope_t = pm_options_scope;
#[doc = " The default value for parameters."]
pub const PM_OPTIONS_SCOPE_FORWARDING_NONE: u8 = 0;
#[doc = " When the scope is fowarding with the * parameter."]
pub const PM_OPTIONS_SCOPE_FORWARDING_POSITIONALS: u8 = 1;
#[doc = " When the scope is fowarding with the ** parameter."]
pub const PM_OPTIONS_SCOPE_FORWARDING_KEYWORDS: u8 = 2;
#[doc = " When the scope is fowarding with the & parameter."]
pub const PM_OPTIONS_SCOPE_FORWARDING_BLOCK: u8 = 4;
#[doc = " When the scope is fowarding with the ... parameter."]
pub const PM_OPTIONS_SCOPE_FORWARDING_ALL: u8 = 8;
#[doc = " The callback called when additional switches are found in a shebang comment\n that need to be processed by the runtime.\n\n @param options The options struct that may be updated by this callback.\n   Certain fields will be checked for changes, specifically encoding,\n   command_line, and frozen_string_literal.\n @param source The source of the shebang comment.\n @param length The length of the source.\n @param shebang_callback_data Any additional data that should be passed along\n   to the callback."]
pub type pm_options_shebang_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        options: *mut pm_options,
        source: *const u8,
        length: usize,
        shebang_callback_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " The current version of prism."]
pub const pm_options_version_t_PM_OPTIONS_VERSION_LATEST: pm_options_version_t = 0;
#[doc = " The vendored version of prism in CRuby 3.3.x."]
pub const pm_options_version_t_PM_OPTIONS_VERSION_CRUBY_3_3: pm_options_version_t = 1;
#[doc = " The vendored version of prism in CRuby 3.4.x."]
pub const pm_options_version_t_PM_OPTIONS_VERSION_CRUBY_3_4: pm_options_version_t = 2;
#[doc = " The version of Ruby syntax that we should be parsing with. This is used to\n allow consumers to specify which behavior they want in case they need to\n parse in the same way as a specific version of CRuby would have."]
pub type pm_options_version_t = ::std::os::raw::c_uint;
#[doc = " The options that can be passed to the parser."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_options {
    #[doc = " The callback to call when additional switches are found in a shebang\n comment."]
    pub shebang_callback: pm_options_shebang_callback_t,
    #[doc = " Any additional data that should be passed along to the shebang callback\n if one was set."]
    pub shebang_callback_data: *mut ::std::os::raw::c_void,
    #[doc = " The name of the file that is currently being parsed."]
    pub filepath: pm_string_t,
    #[doc = " The line within the file that the parse starts on. This value is\n 1-indexed."]
    pub line: i32,
    #[doc = " The name of the encoding that the source file is in. Note that this must\n correspond to a name that can be found with Encoding.find in Ruby."]
    pub encoding: pm_string_t,
    #[doc = " The number of scopes surrounding the code that is being parsed."]
    pub scopes_count: usize,
    #[doc = " The scopes surrounding the code that is being parsed. For most parses\n this will be NULL, but for evals it will be the locals that are in scope\n surrounding the eval. Scopes are ordered from the outermost scope to the\n innermost one."]
    pub scopes: *mut pm_options_scope_t,
    #[doc = " The version of prism that we should be parsing with. This is used to\n allow consumers to specify which behavior they want in case they need to\n parse exactly as a specific version of CRuby."]
    pub version: pm_options_version_t,
    #[doc = " A bitset of the various options that were set on the command line."]
    pub command_line: u8,
    #[doc = " Whether or not the frozen string literal option has been set.\n May be:\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_DISABLED\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_ENABLED\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_UNSET"]
    pub frozen_string_literal: i8,
    #[doc = " Whether or not the encoding magic comments should be respected. This is a\n niche use-case where you want to parse a file with a specific encoding\n but ignore any encoding magic comments at the top of the file."]
    pub encoding_locked: bool,
    #[doc = " When the file being parsed is the main script, the shebang will be\n considered for command-line flags (or for implicit -x). The caller needs\n to pass this information to the parser so that it can behave correctly."]
    pub main_script: bool,
    #[doc = " When the file being parsed is considered a \"partial\" script, jumps will\n not be marked as errors if they are not contained within loops/blocks.\n This is used in the case that you're parsing a script that you know will\n be embedded inside another script later, but you do not have that context\n yet. For example, when parsing an ERB template that will be evaluated\n inside another script."]
    pub partial_script: bool,
    #[doc = " Whether or not the parser should freeze the nodes that it creates. This\n makes it possible to have a deeply frozen AST that is safe to share\n between concurrency primitives."]
    pub freeze: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_options"][::std::mem::size_of::<pm_options>() - 56usize];
    ["Alignment of pm_options"][::std::mem::align_of::<pm_options>() - 4usize];
    ["Offset of field: pm_options::shebang_callback"]
        [::std::mem::offset_of!(pm_options, shebang_callback) - 0usize];
    ["Offset of field: pm_options::shebang_callback_data"]
        [::std::mem::offset_of!(pm_options, shebang_callback_data) - 4usize];
    ["Offset of field: pm_options::filepath"]
        [::std::mem::offset_of!(pm_options, filepath) - 8usize];
    ["Offset of field: pm_options::line"][::std::mem::offset_of!(pm_options, line) - 20usize];
    ["Offset of field: pm_options::encoding"]
        [::std::mem::offset_of!(pm_options, encoding) - 24usize];
    ["Offset of field: pm_options::scopes_count"]
        [::std::mem::offset_of!(pm_options, scopes_count) - 36usize];
    ["Offset of field: pm_options::scopes"][::std::mem::offset_of!(pm_options, scopes) - 40usize];
    ["Offset of field: pm_options::version"][::std::mem::offset_of!(pm_options, version) - 44usize];
    ["Offset of field: pm_options::command_line"]
        [::std::mem::offset_of!(pm_options, command_line) - 48usize];
    ["Offset of field: pm_options::frozen_string_literal"]
        [::std::mem::offset_of!(pm_options, frozen_string_literal) - 49usize];
    ["Offset of field: pm_options::encoding_locked"]
        [::std::mem::offset_of!(pm_options, encoding_locked) - 50usize];
    ["Offset of field: pm_options::main_script"]
        [::std::mem::offset_of!(pm_options, main_script) - 51usize];
    ["Offset of field: pm_options::partial_script"]
        [::std::mem::offset_of!(pm_options, partial_script) - 52usize];
    ["Offset of field: pm_options::freeze"][::std::mem::offset_of!(pm_options, freeze) - 53usize];
};
#[doc = " The options that can be passed to the parser."]
pub type pm_options_t = pm_options;
#[doc = " A bit representing whether or not the command line -a option was set. -a\n splits the input line $_ into $F."]
pub const PM_OPTIONS_COMMAND_LINE_A: u8 = 1;
#[doc = " A bit representing whether or not the command line -e option was set. -e\n allow the user to specify a script to be executed. This is necessary for\n prism to know because certain warnings are not generated when -e is used."]
pub const PM_OPTIONS_COMMAND_LINE_E: u8 = 2;
#[doc = " A bit representing whether or not the command line -l option was set. -l\n chomps the input line by default."]
pub const PM_OPTIONS_COMMAND_LINE_L: u8 = 4;
#[doc = " A bit representing whether or not the command line -n option was set. -n\n wraps the script in a while gets loop."]
pub const PM_OPTIONS_COMMAND_LINE_N: u8 = 8;
#[doc = " A bit representing whether or not the command line -p option was set. -p\n prints the value of $_ at the end of each loop."]
pub const PM_OPTIONS_COMMAND_LINE_P: u8 = 16;
#[doc = " A bit representing whether or not the command line -x option was set. -x\n searches the input file for a shebang that matches the current Ruby engine."]
pub const PM_OPTIONS_COMMAND_LINE_X: u8 = 32;
#[doc = " An internal hash table for a set of nodes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_node_hash_t {
    #[doc = " The array of nodes in the hash table."]
    pub nodes: *mut *mut pm_node_t,
    #[doc = " The size of the hash table."]
    pub size: u32,
    #[doc = " The space that has been allocated in the hash table."]
    pub capacity: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_node_hash_t"][::std::mem::size_of::<pm_node_hash_t>() - 12usize];
    ["Alignment of pm_node_hash_t"][::std::mem::align_of::<pm_node_hash_t>() - 4usize];
    ["Offset of field: pm_node_hash_t::nodes"]
        [::std::mem::offset_of!(pm_node_hash_t, nodes) - 0usize];
    ["Offset of field: pm_node_hash_t::size"]
        [::std::mem::offset_of!(pm_node_hash_t, size) - 4usize];
    ["Offset of field: pm_node_hash_t::capacity"]
        [::std::mem::offset_of!(pm_node_hash_t, capacity) - 8usize];
};
#[doc = " Certain sets of nodes (hash keys and when clauses) check for duplicate nodes\n to alert the user of potential issues. To do this, we keep a set of the nodes\n that have been seen so far, and compare whenever we find a new node.\n\n We bucket the nodes based on their type to minimize the number of comparisons\n that need to be performed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_static_literals_t {
    #[doc = " This is the set of IntegerNode and SourceLineNode instances."]
    pub integer_nodes: pm_node_hash_t,
    #[doc = " This is the set of FloatNode instances."]
    pub float_nodes: pm_node_hash_t,
    #[doc = " This is the set of RationalNode and ImaginaryNode instances."]
    pub number_nodes: pm_node_hash_t,
    #[doc = " This is the set of StringNode and SourceFileNode instances."]
    pub string_nodes: pm_node_hash_t,
    #[doc = " This is the set of RegularExpressionNode instances."]
    pub regexp_nodes: pm_node_hash_t,
    #[doc = " This is the set of SymbolNode instances."]
    pub symbol_nodes: pm_node_hash_t,
    #[doc = " A pointer to the last TrueNode instance that was inserted, or NULL."]
    pub true_node: *mut pm_node_t,
    #[doc = " A pointer to the last FalseNode instance that was inserted, or NULL."]
    pub false_node: *mut pm_node_t,
    #[doc = " A pointer to the last NilNode instance that was inserted, or NULL."]
    pub nil_node: *mut pm_node_t,
    #[doc = " A pointer to the last SourceEncodingNode instance that was inserted, or\n NULL."]
    pub source_encoding_node: *mut pm_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_static_literals_t"][::std::mem::size_of::<pm_static_literals_t>() - 88usize];
    ["Alignment of pm_static_literals_t"][::std::mem::align_of::<pm_static_literals_t>() - 4usize];
    ["Offset of field: pm_static_literals_t::integer_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, integer_nodes) - 0usize];
    ["Offset of field: pm_static_literals_t::float_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, float_nodes) - 12usize];
    ["Offset of field: pm_static_literals_t::number_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, number_nodes) - 24usize];
    ["Offset of field: pm_static_literals_t::string_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, string_nodes) - 36usize];
    ["Offset of field: pm_static_literals_t::regexp_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, regexp_nodes) - 48usize];
    ["Offset of field: pm_static_literals_t::symbol_nodes"]
        [::std::mem::offset_of!(pm_static_literals_t, symbol_nodes) - 60usize];
    ["Offset of field: pm_static_literals_t::true_node"]
        [::std::mem::offset_of!(pm_static_literals_t, true_node) - 72usize];
    ["Offset of field: pm_static_literals_t::false_node"]
        [::std::mem::offset_of!(pm_static_literals_t, false_node) - 76usize];
    ["Offset of field: pm_static_literals_t::nil_node"]
        [::std::mem::offset_of!(pm_static_literals_t, nil_node) - 80usize];
    ["Offset of field: pm_static_literals_t::source_encoding_node"]
        [::std::mem::offset_of!(pm_static_literals_t, source_encoding_node) - 84usize];
};
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_BEG: pm_lex_state_bit_t = 0;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_END: pm_lex_state_bit_t = 1;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_ENDARG: pm_lex_state_bit_t = 2;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_ENDFN: pm_lex_state_bit_t = 3;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_ARG: pm_lex_state_bit_t = 4;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_CMDARG: pm_lex_state_bit_t = 5;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_MID: pm_lex_state_bit_t = 6;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_FNAME: pm_lex_state_bit_t = 7;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_DOT: pm_lex_state_bit_t = 8;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_CLASS: pm_lex_state_bit_t = 9;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_LABEL: pm_lex_state_bit_t = 10;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_LABELED: pm_lex_state_bit_t = 11;
pub const pm_lex_state_bit_t_PM_LEX_STATE_BIT_FITEM: pm_lex_state_bit_t = 12;
#[doc = " This enum provides various bits that represent different kinds of states that\n the lexer can track. This is used to determine which kind of token to return\n based on the context of the parser."]
pub type pm_lex_state_bit_t = ::std::os::raw::c_uint;
pub const pm_lex_state_t_PM_LEX_STATE_NONE: pm_lex_state_t = 0;
pub const pm_lex_state_t_PM_LEX_STATE_BEG: pm_lex_state_t = 1;
pub const pm_lex_state_t_PM_LEX_STATE_END: pm_lex_state_t = 2;
pub const pm_lex_state_t_PM_LEX_STATE_ENDARG: pm_lex_state_t = 4;
pub const pm_lex_state_t_PM_LEX_STATE_ENDFN: pm_lex_state_t = 8;
pub const pm_lex_state_t_PM_LEX_STATE_ARG: pm_lex_state_t = 16;
pub const pm_lex_state_t_PM_LEX_STATE_CMDARG: pm_lex_state_t = 32;
pub const pm_lex_state_t_PM_LEX_STATE_MID: pm_lex_state_t = 64;
pub const pm_lex_state_t_PM_LEX_STATE_FNAME: pm_lex_state_t = 128;
pub const pm_lex_state_t_PM_LEX_STATE_DOT: pm_lex_state_t = 256;
pub const pm_lex_state_t_PM_LEX_STATE_CLASS: pm_lex_state_t = 512;
pub const pm_lex_state_t_PM_LEX_STATE_LABEL: pm_lex_state_t = 1024;
pub const pm_lex_state_t_PM_LEX_STATE_LABELED: pm_lex_state_t = 2048;
pub const pm_lex_state_t_PM_LEX_STATE_FITEM: pm_lex_state_t = 4096;
pub const pm_lex_state_t_PM_LEX_STATE_BEG_ANY: pm_lex_state_t = 577;
pub const pm_lex_state_t_PM_LEX_STATE_ARG_ANY: pm_lex_state_t = 48;
pub const pm_lex_state_t_PM_LEX_STATE_END_ANY: pm_lex_state_t = 14;
#[doc = " This enum combines the various bits from the above enum into individual\n values that represent the various states of the lexer."]
pub type pm_lex_state_t = ::std::os::raw::c_uint;
pub const pm_heredoc_quote_t_PM_HEREDOC_QUOTE_NONE: pm_heredoc_quote_t = 0;
pub const pm_heredoc_quote_t_PM_HEREDOC_QUOTE_SINGLE: pm_heredoc_quote_t = 39;
pub const pm_heredoc_quote_t_PM_HEREDOC_QUOTE_DOUBLE: pm_heredoc_quote_t = 34;
pub const pm_heredoc_quote_t_PM_HEREDOC_QUOTE_BACKTICK: pm_heredoc_quote_t = 96;
#[doc = " The type of quote that a heredoc uses."]
pub type pm_heredoc_quote_t = ::std::os::raw::c_uint;
pub const pm_heredoc_indent_t_PM_HEREDOC_INDENT_NONE: pm_heredoc_indent_t = 0;
pub const pm_heredoc_indent_t_PM_HEREDOC_INDENT_DASH: pm_heredoc_indent_t = 1;
pub const pm_heredoc_indent_t_PM_HEREDOC_INDENT_TILDE: pm_heredoc_indent_t = 2;
#[doc = " The type of indentation that a heredoc uses."]
pub type pm_heredoc_indent_t = ::std::os::raw::c_uint;
#[doc = " All of the information necessary to store to lexing a heredoc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_heredoc_lex_mode_t {
    #[doc = " A pointer to the start of the heredoc identifier."]
    pub ident_start: *const u8,
    #[doc = " The length of the heredoc identifier."]
    pub ident_length: usize,
    #[doc = " The type of quote that the heredoc uses."]
    pub quote: pm_heredoc_quote_t,
    #[doc = " The type of indentation that the heredoc uses."]
    pub indent: pm_heredoc_indent_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_heredoc_lex_mode_t"][::std::mem::size_of::<pm_heredoc_lex_mode_t>() - 16usize];
    ["Alignment of pm_heredoc_lex_mode_t"]
        [::std::mem::align_of::<pm_heredoc_lex_mode_t>() - 4usize];
    ["Offset of field: pm_heredoc_lex_mode_t::ident_start"]
        [::std::mem::offset_of!(pm_heredoc_lex_mode_t, ident_start) - 0usize];
    ["Offset of field: pm_heredoc_lex_mode_t::ident_length"]
        [::std::mem::offset_of!(pm_heredoc_lex_mode_t, ident_length) - 4usize];
    ["Offset of field: pm_heredoc_lex_mode_t::quote"]
        [::std::mem::offset_of!(pm_heredoc_lex_mode_t, quote) - 8usize];
    ["Offset of field: pm_heredoc_lex_mode_t::indent"]
        [::std::mem::offset_of!(pm_heredoc_lex_mode_t, indent) - 12usize];
};
#[doc = " When lexing Ruby source, the lexer has a small amount of state to tell which\n kind of token it is currently lexing. For example, when we find the start of\n a string, the first token that we return is a TOKEN_STRING_BEGIN token. After\n that the lexer is now in the PM_LEX_STRING mode, and will return tokens that\n are found as part of a string."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_lex_mode {
    pub mode: pm_lex_mode__bindgen_ty_1,
    pub as_: pm_lex_mode__bindgen_ty_2,
    #[doc = " The previous lex state so that it knows how to pop."]
    pub prev: *mut pm_lex_mode,
}
#[doc = " This state is used when any given token is being lexed."]
pub const pm_lex_mode_PM_LEX_DEFAULT: pm_lex_mode__bindgen_ty_1 = 0;
#[doc = " This state is used when we're lexing as normal but inside an embedded\n expression of a string."]
pub const pm_lex_mode_PM_LEX_EMBEXPR: pm_lex_mode__bindgen_ty_1 = 1;
#[doc = " This state is used when we're lexing a variable that is embedded\n directly inside of a string with the # shorthand."]
pub const pm_lex_mode_PM_LEX_EMBVAR: pm_lex_mode__bindgen_ty_1 = 2;
#[doc = " This state is used when you are inside the content of a heredoc."]
pub const pm_lex_mode_PM_LEX_HEREDOC: pm_lex_mode__bindgen_ty_1 = 3;
#[doc = " This state is used when we are lexing a list of tokens, as in a %w\n word list literal or a %i symbol list literal."]
pub const pm_lex_mode_PM_LEX_LIST: pm_lex_mode__bindgen_ty_1 = 4;
#[doc = " This state is used when a regular expression has been begun and we\n are looking for the terminator."]
pub const pm_lex_mode_PM_LEX_REGEXP: pm_lex_mode__bindgen_ty_1 = 5;
#[doc = " This state is used when we are lexing a string or a string-like\n token, as in string content with either quote or an xstring."]
pub const pm_lex_mode_PM_LEX_STRING: pm_lex_mode__bindgen_ty_1 = 6;
#[doc = " The type of this lex mode."]
pub type pm_lex_mode__bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " The data associated with this type of lex mode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pm_lex_mode__bindgen_ty_2 {
    pub list: pm_lex_mode__bindgen_ty_2__bindgen_ty_1,
    pub regexp: pm_lex_mode__bindgen_ty_2__bindgen_ty_2,
    pub string: pm_lex_mode__bindgen_ty_2__bindgen_ty_3,
    pub heredoc: pm_lex_mode__bindgen_ty_2__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_mode__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " This keeps track of the nesting level of the list."]
    pub nesting: usize,
    #[doc = " Whether or not interpolation is allowed in this list."]
    pub interpolation: bool,
    #[doc = " When lexing a list, it takes into account balancing the\n terminator if the terminator is one of (), [], {}, or <>."]
    pub incrementor: u8,
    #[doc = " This is the terminator of the list literal."]
    pub terminator: u8,
    #[doc = " This is the character set that should be used to delimit the\n tokens within the list."]
    pub breakpoints: [u8; 11usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_1>() - 20usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::nesting"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, nesting) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::interpolation"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, interpolation) - 4usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::incrementor"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, incrementor) - 5usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::terminator"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, terminator) - 6usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_1::breakpoints"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_1, breakpoints) - 7usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_mode__bindgen_ty_2__bindgen_ty_2 {
    #[doc = " This keeps track of the nesting level of the regular expression."]
    pub nesting: usize,
    #[doc = " When lexing a regular expression, it takes into account balancing\n the terminator if the terminator is one of (), [], {}, or <>."]
    pub incrementor: u8,
    #[doc = " This is the terminator of the regular expression."]
    pub terminator: u8,
    #[doc = " This is the character set that should be used to delimit the\n tokens within the regular expression."]
    pub breakpoints: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2__bindgen_ty_2"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_2>() - 16usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2__bindgen_ty_2"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_2>() - 4usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_2::nesting"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_2, nesting) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_2::incrementor"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_2, incrementor) - 4usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_2::terminator"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_2, terminator) - 5usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_2::breakpoints"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_2, breakpoints) - 6usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_mode__bindgen_ty_2__bindgen_ty_3 {
    #[doc = " This keeps track of the nesting level of the string."]
    pub nesting: usize,
    #[doc = " Whether or not interpolation is allowed in this string."]
    pub interpolation: bool,
    #[doc = " Whether or not at the end of the string we should allow a :,\n which would indicate this was a dynamic symbol instead of a\n string."]
    pub label_allowed: bool,
    #[doc = " When lexing a string, it takes into account balancing the\n terminator if the terminator is one of (), [], {}, or <>."]
    pub incrementor: u8,
    #[doc = " This is the terminator of the string. It is typically either a\n single or double quote."]
    pub terminator: u8,
    #[doc = " This is the character set that should be used to delimit the\n tokens within the string."]
    pub breakpoints: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2__bindgen_ty_3"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_3>() - 16usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2__bindgen_ty_3"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_3>() - 4usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::nesting"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, nesting) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::interpolation"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, interpolation) - 4usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::label_allowed"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, label_allowed) - 5usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::incrementor"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, incrementor) - 6usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::terminator"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, terminator) - 7usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_3::breakpoints"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_3, breakpoints) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_mode__bindgen_ty_2__bindgen_ty_4 {
    #[doc = " All of the data necessary to lex a heredoc."]
    pub base: pm_heredoc_lex_mode_t,
    #[doc = " This is the pointer to the character where lexing should resume\n once the heredoc has been completely processed."]
    pub next_start: *const u8,
    #[doc = " This is used to track the amount of common whitespace on each\n line so that we know how much to dedent each line in the case of\n a tilde heredoc."]
    pub common_whitespace: *mut usize,
    #[doc = " True if the previous token ended with a line continuation."]
    pub line_continuation: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2__bindgen_ty_4"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_4>() - 28usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2__bindgen_ty_4"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2__bindgen_ty_4>() - 4usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_4::base"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_4, base) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_4::next_start"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2__bindgen_ty_4, next_start) - 16usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_4::common_whitespace"][::std::mem::offset_of!(
        pm_lex_mode__bindgen_ty_2__bindgen_ty_4,
        common_whitespace
    ) - 20usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2__bindgen_ty_4::line_continuation"][::std::mem::offset_of!(
        pm_lex_mode__bindgen_ty_2__bindgen_ty_4,
        line_continuation
    ) - 24usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode__bindgen_ty_2"]
        [::std::mem::size_of::<pm_lex_mode__bindgen_ty_2>() - 28usize];
    ["Alignment of pm_lex_mode__bindgen_ty_2"]
        [::std::mem::align_of::<pm_lex_mode__bindgen_ty_2>() - 4usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2::list"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2, list) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2::regexp"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2, regexp) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2::string"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2, string) - 0usize];
    ["Offset of field: pm_lex_mode__bindgen_ty_2::heredoc"]
        [::std::mem::offset_of!(pm_lex_mode__bindgen_ty_2, heredoc) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_mode"][::std::mem::size_of::<pm_lex_mode>() - 36usize];
    ["Alignment of pm_lex_mode"][::std::mem::align_of::<pm_lex_mode>() - 4usize];
    ["Offset of field: pm_lex_mode::mode"][::std::mem::offset_of!(pm_lex_mode, mode) - 0usize];
    ["Offset of field: pm_lex_mode::as_"][::std::mem::offset_of!(pm_lex_mode, as_) - 4usize];
    ["Offset of field: pm_lex_mode::prev"][::std::mem::offset_of!(pm_lex_mode, prev) - 32usize];
};
#[doc = " When lexing Ruby source, the lexer has a small amount of state to tell which\n kind of token it is currently lexing. For example, when we find the start of\n a string, the first token that we return is a TOKEN_STRING_BEGIN token. After\n that the lexer is now in the PM_LEX_STRING mode, and will return tokens that\n are found as part of a string."]
pub type pm_lex_mode_t = pm_lex_mode;
#[doc = " The parser used to parse Ruby source."]
pub type pm_parser_t = pm_parser;
#[doc = " a null context, used for returning a value from a function"]
pub const pm_context_t_PM_CONTEXT_NONE: pm_context_t = 0;
#[doc = " a begin statement"]
pub const pm_context_t_PM_CONTEXT_BEGIN: pm_context_t = 1;
#[doc = " an ensure statement with an explicit begin"]
pub const pm_context_t_PM_CONTEXT_BEGIN_ENSURE: pm_context_t = 2;
#[doc = " a rescue else statement with an explicit begin"]
pub const pm_context_t_PM_CONTEXT_BEGIN_ELSE: pm_context_t = 3;
#[doc = " a rescue statement with an explicit begin"]
pub const pm_context_t_PM_CONTEXT_BEGIN_RESCUE: pm_context_t = 4;
#[doc = " expressions in block arguments using braces"]
pub const pm_context_t_PM_CONTEXT_BLOCK_BRACES: pm_context_t = 5;
#[doc = " expressions in block arguments using do..end"]
pub const pm_context_t_PM_CONTEXT_BLOCK_KEYWORDS: pm_context_t = 6;
#[doc = " an ensure statement within a do..end block"]
pub const pm_context_t_PM_CONTEXT_BLOCK_ENSURE: pm_context_t = 7;
#[doc = " a rescue else statement within a do..end block"]
pub const pm_context_t_PM_CONTEXT_BLOCK_ELSE: pm_context_t = 8;
#[doc = " a rescue statement within a do..end block"]
pub const pm_context_t_PM_CONTEXT_BLOCK_RESCUE: pm_context_t = 9;
#[doc = " a case when statements"]
pub const pm_context_t_PM_CONTEXT_CASE_WHEN: pm_context_t = 10;
#[doc = " a case in statements"]
pub const pm_context_t_PM_CONTEXT_CASE_IN: pm_context_t = 11;
#[doc = " a class declaration"]
pub const pm_context_t_PM_CONTEXT_CLASS: pm_context_t = 12;
#[doc = " an ensure statement within a class statement"]
pub const pm_context_t_PM_CONTEXT_CLASS_ENSURE: pm_context_t = 13;
#[doc = " a rescue else statement within a class statement"]
pub const pm_context_t_PM_CONTEXT_CLASS_ELSE: pm_context_t = 14;
#[doc = " a rescue statement within a class statement"]
pub const pm_context_t_PM_CONTEXT_CLASS_RESCUE: pm_context_t = 15;
#[doc = " a method definition"]
pub const pm_context_t_PM_CONTEXT_DEF: pm_context_t = 16;
#[doc = " an ensure statement within a method definition"]
pub const pm_context_t_PM_CONTEXT_DEF_ENSURE: pm_context_t = 17;
#[doc = " a rescue else statement within a method definition"]
pub const pm_context_t_PM_CONTEXT_DEF_ELSE: pm_context_t = 18;
#[doc = " a rescue statement within a method definition"]
pub const pm_context_t_PM_CONTEXT_DEF_RESCUE: pm_context_t = 19;
#[doc = " a method definition's parameters"]
pub const pm_context_t_PM_CONTEXT_DEF_PARAMS: pm_context_t = 20;
#[doc = " a defined? expression"]
pub const pm_context_t_PM_CONTEXT_DEFINED: pm_context_t = 21;
#[doc = " a method definition's default parameter"]
pub const pm_context_t_PM_CONTEXT_DEFAULT_PARAMS: pm_context_t = 22;
#[doc = " an else clause"]
pub const pm_context_t_PM_CONTEXT_ELSE: pm_context_t = 23;
#[doc = " an elsif clause"]
pub const pm_context_t_PM_CONTEXT_ELSIF: pm_context_t = 24;
#[doc = " an interpolated expression"]
pub const pm_context_t_PM_CONTEXT_EMBEXPR: pm_context_t = 25;
#[doc = " a for loop"]
pub const pm_context_t_PM_CONTEXT_FOR: pm_context_t = 26;
#[doc = " a for loop's index"]
pub const pm_context_t_PM_CONTEXT_FOR_INDEX: pm_context_t = 27;
#[doc = " an if statement"]
pub const pm_context_t_PM_CONTEXT_IF: pm_context_t = 28;
#[doc = " a lambda expression with braces"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_BRACES: pm_context_t = 29;
#[doc = " a lambda expression with do..end"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_DO_END: pm_context_t = 30;
#[doc = " an ensure statement within a lambda expression"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_ENSURE: pm_context_t = 31;
#[doc = " a rescue else statement within a lambda expression"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_ELSE: pm_context_t = 32;
#[doc = " a rescue statement within a lambda expression"]
pub const pm_context_t_PM_CONTEXT_LAMBDA_RESCUE: pm_context_t = 33;
#[doc = " the predicate clause of a loop statement"]
pub const pm_context_t_PM_CONTEXT_LOOP_PREDICATE: pm_context_t = 34;
#[doc = " the top level context"]
pub const pm_context_t_PM_CONTEXT_MAIN: pm_context_t = 35;
#[doc = " a module declaration"]
pub const pm_context_t_PM_CONTEXT_MODULE: pm_context_t = 36;
#[doc = " an ensure statement within a module statement"]
pub const pm_context_t_PM_CONTEXT_MODULE_ENSURE: pm_context_t = 37;
#[doc = " a rescue else statement within a module statement"]
pub const pm_context_t_PM_CONTEXT_MODULE_ELSE: pm_context_t = 38;
#[doc = " a rescue statement within a module statement"]
pub const pm_context_t_PM_CONTEXT_MODULE_RESCUE: pm_context_t = 39;
#[doc = " a multiple target expression"]
pub const pm_context_t_PM_CONTEXT_MULTI_TARGET: pm_context_t = 40;
#[doc = " a parenthesized expression"]
pub const pm_context_t_PM_CONTEXT_PARENS: pm_context_t = 41;
#[doc = " an END block"]
pub const pm_context_t_PM_CONTEXT_POSTEXE: pm_context_t = 42;
#[doc = " a predicate inside an if/elsif/unless statement"]
pub const pm_context_t_PM_CONTEXT_PREDICATE: pm_context_t = 43;
#[doc = " a BEGIN block"]
pub const pm_context_t_PM_CONTEXT_PREEXE: pm_context_t = 44;
#[doc = " a modifier rescue clause"]
pub const pm_context_t_PM_CONTEXT_RESCUE_MODIFIER: pm_context_t = 45;
#[doc = " a singleton class definition"]
pub const pm_context_t_PM_CONTEXT_SCLASS: pm_context_t = 46;
#[doc = " an ensure statement with a singleton class"]
pub const pm_context_t_PM_CONTEXT_SCLASS_ENSURE: pm_context_t = 47;
#[doc = " a rescue else statement with a singleton class"]
pub const pm_context_t_PM_CONTEXT_SCLASS_ELSE: pm_context_t = 48;
#[doc = " a rescue statement with a singleton class"]
pub const pm_context_t_PM_CONTEXT_SCLASS_RESCUE: pm_context_t = 49;
#[doc = " a ternary expression"]
pub const pm_context_t_PM_CONTEXT_TERNARY: pm_context_t = 50;
#[doc = " an unless statement"]
pub const pm_context_t_PM_CONTEXT_UNLESS: pm_context_t = 51;
#[doc = " an until statement"]
pub const pm_context_t_PM_CONTEXT_UNTIL: pm_context_t = 52;
#[doc = " a while statement"]
pub const pm_context_t_PM_CONTEXT_WHILE: pm_context_t = 53;
#[doc = " While parsing, we keep track of a stack of contexts. This is helpful for\n error recovery so that we can pop back to a previous context when we hit a\n token that is understood by a parent context but not by the current context."]
pub type pm_context_t = ::std::os::raw::c_uint;
#[doc = " This is a node in a linked list of contexts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_context_node {
    #[doc = " The context that this node represents."]
    pub context: pm_context_t,
    #[doc = " A pointer to the previous context in the linked list."]
    pub prev: *mut pm_context_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_context_node"][::std::mem::size_of::<pm_context_node>() - 8usize];
    ["Alignment of pm_context_node"][::std::mem::align_of::<pm_context_node>() - 4usize];
    ["Offset of field: pm_context_node::context"]
        [::std::mem::offset_of!(pm_context_node, context) - 0usize];
    ["Offset of field: pm_context_node::prev"]
        [::std::mem::offset_of!(pm_context_node, prev) - 4usize];
};
#[doc = " This is a node in a linked list of contexts."]
pub type pm_context_node_t = pm_context_node;
pub const pm_comment_type_t_PM_COMMENT_INLINE: pm_comment_type_t = 0;
pub const pm_comment_type_t_PM_COMMENT_EMBDOC: pm_comment_type_t = 1;
#[doc = " This is the type of a comment that we've found while parsing."]
pub type pm_comment_type_t = ::std::os::raw::c_uint;
#[doc = " This is a node in the linked list of comments that we've found while parsing.\n\n @extends pm_list_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_comment {
    #[doc = " The embedded base node."]
    pub node: pm_list_node_t,
    #[doc = " The location of the comment in the source."]
    pub location: pm_location_t,
    #[doc = " The type of comment that we've found."]
    pub type_: pm_comment_type_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_comment"][::std::mem::size_of::<pm_comment>() - 16usize];
    ["Alignment of pm_comment"][::std::mem::align_of::<pm_comment>() - 4usize];
    ["Offset of field: pm_comment::node"][::std::mem::offset_of!(pm_comment, node) - 0usize];
    ["Offset of field: pm_comment::location"]
        [::std::mem::offset_of!(pm_comment, location) - 4usize];
    ["Offset of field: pm_comment::type_"][::std::mem::offset_of!(pm_comment, type_) - 12usize];
};
#[doc = " This is a node in the linked list of comments that we've found while parsing.\n\n @extends pm_list_node_t"]
pub type pm_comment_t = pm_comment;
#[doc = " This is a node in the linked list of magic comments that we've found while\n parsing.\n\n @extends pm_list_node_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_magic_comment_t {
    #[doc = " The embedded base node."]
    pub node: pm_list_node_t,
    #[doc = " A pointer to the start of the key in the source."]
    pub key_start: *const u8,
    #[doc = " A pointer to the start of the value in the source."]
    pub value_start: *const u8,
    #[doc = " The length of the key in the source."]
    pub key_length: u32,
    #[doc = " The length of the value in the source."]
    pub value_length: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_magic_comment_t"][::std::mem::size_of::<pm_magic_comment_t>() - 20usize];
    ["Alignment of pm_magic_comment_t"][::std::mem::align_of::<pm_magic_comment_t>() - 4usize];
    ["Offset of field: pm_magic_comment_t::node"]
        [::std::mem::offset_of!(pm_magic_comment_t, node) - 0usize];
    ["Offset of field: pm_magic_comment_t::key_start"]
        [::std::mem::offset_of!(pm_magic_comment_t, key_start) - 4usize];
    ["Offset of field: pm_magic_comment_t::value_start"]
        [::std::mem::offset_of!(pm_magic_comment_t, value_start) - 8usize];
    ["Offset of field: pm_magic_comment_t::key_length"]
        [::std::mem::offset_of!(pm_magic_comment_t, key_length) - 12usize];
    ["Offset of field: pm_magic_comment_t::value_length"]
        [::std::mem::offset_of!(pm_magic_comment_t, value_length) - 16usize];
};
#[doc = " When the encoding that is being used to parse the source is changed by prism,\n we provide the ability here to call out to a user-defined function."]
pub type pm_encoding_changed_callback_t =
    ::std::option::Option<unsafe extern "C" fn(parser: *mut pm_parser_t)>;
#[doc = " When you are lexing through a file, the lexer needs all of the information\n that the parser additionally provides (for example, the local table). So if\n you want to properly lex Ruby, you need to actually lex it in the context of\n the parser. In order to provide this functionality, we optionally allow a\n struct to be attached to the parser that calls back out to a user-provided\n callback when each token is lexed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_lex_callback_t {
    #[doc = " This opaque pointer is used to provide whatever information the user\n deemed necessary to the callback. In our case we use it to pass the array\n that the tokens get appended into."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " This is the callback that is called when a token is lexed. It is passed\n the opaque data pointer, the parser, and the token that was lexed."]
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            parser: *mut pm_parser_t,
            token: *mut pm_token_t,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_lex_callback_t"][::std::mem::size_of::<pm_lex_callback_t>() - 8usize];
    ["Alignment of pm_lex_callback_t"][::std::mem::align_of::<pm_lex_callback_t>() - 4usize];
    ["Offset of field: pm_lex_callback_t::data"]
        [::std::mem::offset_of!(pm_lex_callback_t, data) - 0usize];
    ["Offset of field: pm_lex_callback_t::callback"]
        [::std::mem::offset_of!(pm_lex_callback_t, callback) - 4usize];
};
#[doc = " The type of shareable constant value that can be set."]
pub type pm_shareable_constant_value_t = u8;
pub const PM_SCOPE_SHAREABLE_CONSTANT_NONE: pm_shareable_constant_value_t = 0;
pub const PM_SCOPE_SHAREABLE_CONSTANT_LITERAL: pm_shareable_constant_value_t = 4;
pub const PM_SCOPE_SHAREABLE_CONSTANT_EXPERIMENTAL_EVERYTHING: pm_shareable_constant_value_t = 8;
pub const PM_SCOPE_SHAREABLE_CONSTANT_EXPERIMENTAL_COPY: pm_shareable_constant_value_t = 16;
#[doc = " This tracks an individual local variable in a certain lexical context, as\n well as the number of times is it read."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_local_t {
    #[doc = " The name of the local variable."]
    pub name: pm_constant_id_t,
    #[doc = " The location of the local variable in the source."]
    pub location: pm_location_t,
    #[doc = " The index of the local variable in the local table."]
    pub index: u32,
    #[doc = " The number of times the local variable is read."]
    pub reads: u32,
    #[doc = " The hash of the local variable."]
    pub hash: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_local_t"][::std::mem::size_of::<pm_local_t>() - 24usize];
    ["Alignment of pm_local_t"][::std::mem::align_of::<pm_local_t>() - 4usize];
    ["Offset of field: pm_local_t::name"][::std::mem::offset_of!(pm_local_t, name) - 0usize];
    ["Offset of field: pm_local_t::location"]
        [::std::mem::offset_of!(pm_local_t, location) - 4usize];
    ["Offset of field: pm_local_t::index"][::std::mem::offset_of!(pm_local_t, index) - 12usize];
    ["Offset of field: pm_local_t::reads"][::std::mem::offset_of!(pm_local_t, reads) - 16usize];
    ["Offset of field: pm_local_t::hash"][::std::mem::offset_of!(pm_local_t, hash) - 20usize];
};
#[doc = " This is a set of local variables in a certain lexical context (method, class,\n module, etc.). We need to track how many times these variables are read in\n order to warn if they only get written."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_locals {
    #[doc = " The number of local variables in the set."]
    pub size: u32,
    #[doc = " The capacity of the local variables set."]
    pub capacity: u32,
    #[doc = " The nullable allocated memory for the local variables in the set."]
    pub locals: *mut pm_local_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_locals"][::std::mem::size_of::<pm_locals>() - 12usize];
    ["Alignment of pm_locals"][::std::mem::align_of::<pm_locals>() - 4usize];
    ["Offset of field: pm_locals::size"][::std::mem::offset_of!(pm_locals, size) - 0usize];
    ["Offset of field: pm_locals::capacity"][::std::mem::offset_of!(pm_locals, capacity) - 4usize];
    ["Offset of field: pm_locals::locals"][::std::mem::offset_of!(pm_locals, locals) - 8usize];
};
#[doc = " This is a set of local variables in a certain lexical context (method, class,\n module, etc.). We need to track how many times these variables are read in\n order to warn if they only get written."]
pub type pm_locals_t = pm_locals;
#[doc = " The flags about scope parameters that can be set."]
pub type pm_scope_parameters_t = u8;
pub const PM_SCOPE_PARAMETERS_NONE: pm_scope_parameters_t = 0;
pub const PM_SCOPE_PARAMETERS_FORWARDING_POSITIONALS: pm_scope_parameters_t = 1;
pub const PM_SCOPE_PARAMETERS_FORWARDING_KEYWORDS: pm_scope_parameters_t = 2;
pub const PM_SCOPE_PARAMETERS_FORWARDING_BLOCK: pm_scope_parameters_t = 4;
pub const PM_SCOPE_PARAMETERS_FORWARDING_ALL: pm_scope_parameters_t = 8;
pub const PM_SCOPE_PARAMETERS_IMPLICIT_DISALLOWED: pm_scope_parameters_t = 16;
pub const PM_SCOPE_PARAMETERS_NUMBERED_INNER: pm_scope_parameters_t = 32;
pub const PM_SCOPE_PARAMETERS_NUMBERED_FOUND: pm_scope_parameters_t = 64;
#[doc = " This struct represents a node in a linked list of scopes. Some scopes can see\n into their parent scopes, while others cannot."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_scope {
    #[doc = " A pointer to the previous scope in the linked list."]
    pub previous: *mut pm_scope,
    #[doc = " The IDs of the locals in the given scope."]
    pub locals: pm_locals_t,
    #[doc = " This is a list of the implicit parameters contained within the block.\n These will be processed after the block is parsed to determine the kind\n of parameters node that should be used and to check if any errors need to\n be added."]
    pub implicit_parameters: pm_node_list_t,
    #[doc = " This is a bitfield that indicates the parameters that are being used in\n this scope. It is a combination of the PM_SCOPE_PARAMETERS_* constants.\n There are three different kinds of parameters that can be used in a\n scope:\n\n - Ordinary parameters (e.g., def foo(bar); end)\n - Numbered parameters (e.g., def foo; _1; end)\n - The it parameter (e.g., def foo; it; end)\n\n If ordinary parameters are being used, then certain parameters can be\n forwarded to another method/structure. Those are indicated by four\n additional bits in the params field. For example, some combinations of:\n\n - def foo(*); end\n - def foo(**); end\n - def foo(&); end\n - def foo(...); end"]
    pub parameters: pm_scope_parameters_t,
    #[doc = " The current state of constant shareability for this scope. This is\n changed by magic shareable_constant_value comments."]
    pub shareable_constant: pm_shareable_constant_value_t,
    #[doc = " A boolean indicating whether or not this scope can see into its parent.\n If closed is true, then the scope cannot see into its parent."]
    pub closed: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_scope"][::std::mem::size_of::<pm_scope>() - 32usize];
    ["Alignment of pm_scope"][::std::mem::align_of::<pm_scope>() - 4usize];
    ["Offset of field: pm_scope::previous"][::std::mem::offset_of!(pm_scope, previous) - 0usize];
    ["Offset of field: pm_scope::locals"][::std::mem::offset_of!(pm_scope, locals) - 4usize];
    ["Offset of field: pm_scope::implicit_parameters"]
        [::std::mem::offset_of!(pm_scope, implicit_parameters) - 16usize];
    ["Offset of field: pm_scope::parameters"]
        [::std::mem::offset_of!(pm_scope, parameters) - 28usize];
    ["Offset of field: pm_scope::shareable_constant"]
        [::std::mem::offset_of!(pm_scope, shareable_constant) - 29usize];
    ["Offset of field: pm_scope::closed"][::std::mem::offset_of!(pm_scope, closed) - 30usize];
};
#[doc = " This struct represents a node in a linked list of scopes. Some scopes can see\n into their parent scopes, while others cannot."]
pub type pm_scope_t = pm_scope;
#[doc = " A struct that represents a stack of boolean values."]
pub type pm_state_stack_t = u32;
#[doc = " This struct represents the overall parser. It contains a reference to the\n source file, as well as pointers that indicate where in the source it's\n currently parsing. It also contains the most recent and current token that\n it's considering."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_parser {
    #[doc = " The next node identifier that will be assigned. This is a unique\n identifier used to track nodes such that the syntax tree can be dropped\n but the node can be found through another parse."]
    pub node_id: u32,
    #[doc = " The current state of the lexer."]
    pub lex_state: pm_lex_state_t,
    #[doc = " Tracks the current nesting of (), [], and {}."]
    pub enclosure_nesting: ::std::os::raw::c_int,
    #[doc = " Used to temporarily track the nesting of enclosures to determine if a {\n is the beginning of a lambda following the parameters of a lambda."]
    pub lambda_enclosure_nesting: ::std::os::raw::c_int,
    #[doc = " Used to track the nesting of braces to ensure we get the correct value\n when we are interpolating blocks with braces."]
    pub brace_nesting: ::std::os::raw::c_int,
    #[doc = " The stack used to determine if a do keyword belongs to the predicate of a\n while, until, or for loop."]
    pub do_loop_stack: pm_state_stack_t,
    #[doc = " The stack used to determine if a do keyword belongs to the beginning of a\n block."]
    pub accepts_block_stack: pm_state_stack_t,
    pub lex_modes: pm_parser__bindgen_ty_1,
    #[doc = " The pointer to the start of the source."]
    pub start: *const u8,
    #[doc = " The pointer to the end of the source."]
    pub end: *const u8,
    #[doc = " The previous token we were considering."]
    pub previous: pm_token_t,
    #[doc = " The current token we're considering."]
    pub current: pm_token_t,
    #[doc = " This is a special field set on the parser when we need the parser to jump\n to a specific location when lexing the next token, as opposed to just\n using the end of the previous token. Normally this is NULL."]
    pub next_start: *const u8,
    #[doc = " This field indicates the end of a heredoc whose identifier was found on\n the current line. If another heredoc is found on the same line, then this\n will be moved forward to the end of that heredoc. If no heredocs are\n found on a line then this is NULL."]
    pub heredoc_end: *const u8,
    #[doc = " The list of comments that have been found while parsing."]
    pub comment_list: pm_list_t,
    #[doc = " The list of magic comments that have been found while parsing."]
    pub magic_comment_list: pm_list_t,
    #[doc = " An optional location that represents the location of the __END__ marker\n and the rest of the content of the file. This content is loaded into the\n DATA constant when the file being parsed is the main file being executed."]
    pub data_loc: pm_location_t,
    #[doc = " The list of warnings that have been found while parsing."]
    pub warning_list: pm_list_t,
    #[doc = " The list of errors that have been found while parsing."]
    pub error_list: pm_list_t,
    #[doc = " The current local scope."]
    pub current_scope: *mut pm_scope_t,
    #[doc = " The current parsing context."]
    pub current_context: *mut pm_context_node_t,
    #[doc = " The hash keys for the hash that is currently being parsed. This is not\n usually necessary because it can pass it down the various call chains,\n but in the event that you're parsing a hash that is being directly\n pushed into another hash with **, we need to share the hash keys so that\n we can warn for the nested hash as well."]
    pub current_hash_keys: *mut pm_static_literals_t,
    #[doc = " The encoding functions for the current file is attached to the parser as\n it's parsing so that it can change with a magic comment."]
    pub encoding: *const pm_encoding_t,
    #[doc = " When the encoding that is being used to parse the source is changed by\n prism, we provide the ability here to call out to a user-defined\n function."]
    pub encoding_changed_callback: pm_encoding_changed_callback_t,
    #[doc = " This pointer indicates where a comment must start if it is to be\n considered an encoding comment."]
    pub encoding_comment_start: *const u8,
    #[doc = " This is an optional callback that can be attached to the parser that will\n be called whenever a new token is lexed by the parser."]
    pub lex_callback: *mut pm_lex_callback_t,
    #[doc = " This is the path of the file being parsed. We use the filepath when\n constructing SourceFileNodes."]
    pub filepath: pm_string_t,
    #[doc = " This constant pool keeps all of the constants defined throughout the file\n so that we can reference them later."]
    pub constant_pool: pm_constant_pool_t,
    #[doc = " This is the list of newline offsets in the source file."]
    pub newline_list: pm_newline_list_t,
    #[doc = " We want to add a flag to integer nodes that indicates their base. We only\n want to parse these once, but we don't have space on the token itself to\n communicate this information. So we store it here and pass it through\n when we find tokens that we need it for."]
    pub integer_base: pm_node_flags_t,
    #[doc = " This string is used to pass information from the lexer to the parser. It\n is particularly necessary because of escape sequences."]
    pub current_string: pm_string_t,
    #[doc = " The line number at the start of the parse. This will be used to offset\n the line numbers of all of the locations."]
    pub start_line: i32,
    #[doc = " When a string-like expression is being lexed, any byte or escape sequence\n that resolves to a value whose top bit is set (i.e., >= 0x80) will\n explicitly set the encoding to the same encoding as the source.\n Alternatively, if a unicode escape sequence is used (e.g., \\\\u{80}) that\n resolves to a value whose top bit is set, then the encoding will be\n explicitly set to UTF-8.\n\n The _next_ time this happens, if the encoding that is about to become the\n explicitly set encoding does not match the previously set explicit\n encoding, a mixed encoding error will be emitted.\n\n When the expression is finished being lexed, the explicit encoding\n controls the encoding of the expression. For the most part this means\n that the expression will either be encoded in the source encoding or\n UTF-8. This holds for all encodings except US-ASCII. If the source is\n US-ASCII and an explicit encoding was set that was _not_ UTF-8, then the\n expression will be encoded as ASCII-8BIT.\n\n Note that if the expression is a list, different elements within the same\n list can have different encodings, so this will get reset between each\n element. Furthermore all of this only applies to lists that support\n interpolation, because otherwise escapes that could change the encoding\n are ignored.\n\n At first glance, it may make more sense for this to live on the lexer\n mode, but we need it here to communicate back to the parser for character\n literals that do not push a new lexer mode."]
    pub explicit_encoding: *const pm_encoding_t,
    #[doc = " When parsing block exits (e.g., break, next, redo), we need to validate\n that they are in correct contexts. For the most part we can do this by\n looking at our parent contexts. However, modifier while and until\n expressions can change that context to make block exits valid. In these\n cases, we need to keep track of the block exits and then validate them\n after the expression has been parsed.\n\n We use a pointer here because we don't want to keep a whole list attached\n since this will only be used in the context of begin/end expressions."]
    pub current_block_exits: *mut pm_node_list_t,
    #[doc = " The version of prism that we should use to parse."]
    pub version: pm_options_version_t,
    #[doc = " The command line flags given from the options."]
    pub command_line: u8,
    #[doc = " Whether or not we have found a frozen_string_literal magic comment with\n a true or false value.\n May be:\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_DISABLED\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_ENABLED\n  - PM_OPTIONS_FROZEN_STRING_LITERAL_UNSET"]
    pub frozen_string_literal: i8,
    #[doc = " Whether or not we are parsing an eval string. This impacts whether or not\n we should evaluate if block exits/yields are valid."]
    pub parsing_eval: bool,
    #[doc = " Whether or not we are parsing a \"partial\" script, which is a script that\n will be evaluated in the context of another script, so we should not\n check jumps (next/break/etc.) for validity."]
    pub partial_script: bool,
    #[doc = " Whether or not we're at the beginning of a command."]
    pub command_start: bool,
    #[doc = " Whether or not we're currently recovering from a syntax error."]
    pub recovering: bool,
    #[doc = " This is very specialized behavior for when you want to parse in a context\n that does not respect encoding comments. Its main use case is translating\n into the whitequark/parser AST which re-encodes source files in UTF-8\n before they are parsed and ignores encoding comments."]
    pub encoding_locked: bool,
    #[doc = " Whether or not the encoding has been changed by a magic comment. We use\n this to provide a fast path for the lexer instead of going through the\n function pointer."]
    pub encoding_changed: bool,
    #[doc = " This flag indicates that we are currently parsing a pattern matching\n expression and impacts that calculation of newlines."]
    pub pattern_matching_newlines: bool,
    #[doc = " This flag indicates that we are currently parsing a keyword argument."]
    pub in_keyword_arg: bool,
    #[doc = " Whether or not the parser has seen a token that has semantic meaning\n (i.e., a token that is not a comment or whitespace)."]
    pub semantic_token_seen: bool,
    #[doc = " True if the current regular expression being lexed contains only ASCII\n characters."]
    pub current_regular_expression_ascii_only: bool,
    #[doc = " By default, Ruby always warns about mismatched indentation. This can be\n toggled with a magic comment."]
    pub warn_mismatched_indentation: bool,
}
#[doc = " A stack of lex modes."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_parser__bindgen_ty_1 {
    #[doc = " The current mode of the lexer."]
    pub current: *mut pm_lex_mode_t,
    #[doc = " The stack of lexer modes."]
    pub stack: [pm_lex_mode_t; 4usize],
    #[doc = " The current index into the lexer mode stack."]
    pub index: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parser__bindgen_ty_1"]
        [::std::mem::size_of::<pm_parser__bindgen_ty_1>() - 152usize];
    ["Alignment of pm_parser__bindgen_ty_1"]
        [::std::mem::align_of::<pm_parser__bindgen_ty_1>() - 4usize];
    ["Offset of field: pm_parser__bindgen_ty_1::current"]
        [::std::mem::offset_of!(pm_parser__bindgen_ty_1, current) - 0usize];
    ["Offset of field: pm_parser__bindgen_ty_1::stack"]
        [::std::mem::offset_of!(pm_parser__bindgen_ty_1, stack) - 4usize];
    ["Offset of field: pm_parser__bindgen_ty_1::index"]
        [::std::mem::offset_of!(pm_parser__bindgen_ty_1, index) - 148usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parser"][::std::mem::size_of::<pm_parser>() - 396usize];
    ["Alignment of pm_parser"][::std::mem::align_of::<pm_parser>() - 4usize];
    ["Offset of field: pm_parser::node_id"][::std::mem::offset_of!(pm_parser, node_id) - 0usize];
    ["Offset of field: pm_parser::lex_state"]
        [::std::mem::offset_of!(pm_parser, lex_state) - 4usize];
    ["Offset of field: pm_parser::enclosure_nesting"]
        [::std::mem::offset_of!(pm_parser, enclosure_nesting) - 8usize];
    ["Offset of field: pm_parser::lambda_enclosure_nesting"]
        [::std::mem::offset_of!(pm_parser, lambda_enclosure_nesting) - 12usize];
    ["Offset of field: pm_parser::brace_nesting"]
        [::std::mem::offset_of!(pm_parser, brace_nesting) - 16usize];
    ["Offset of field: pm_parser::do_loop_stack"]
        [::std::mem::offset_of!(pm_parser, do_loop_stack) - 20usize];
    ["Offset of field: pm_parser::accepts_block_stack"]
        [::std::mem::offset_of!(pm_parser, accepts_block_stack) - 24usize];
    ["Offset of field: pm_parser::lex_modes"]
        [::std::mem::offset_of!(pm_parser, lex_modes) - 28usize];
    ["Offset of field: pm_parser::start"][::std::mem::offset_of!(pm_parser, start) - 180usize];
    ["Offset of field: pm_parser::end"][::std::mem::offset_of!(pm_parser, end) - 184usize];
    ["Offset of field: pm_parser::previous"]
        [::std::mem::offset_of!(pm_parser, previous) - 188usize];
    ["Offset of field: pm_parser::current"][::std::mem::offset_of!(pm_parser, current) - 200usize];
    ["Offset of field: pm_parser::next_start"]
        [::std::mem::offset_of!(pm_parser, next_start) - 212usize];
    ["Offset of field: pm_parser::heredoc_end"]
        [::std::mem::offset_of!(pm_parser, heredoc_end) - 216usize];
    ["Offset of field: pm_parser::comment_list"]
        [::std::mem::offset_of!(pm_parser, comment_list) - 220usize];
    ["Offset of field: pm_parser::magic_comment_list"]
        [::std::mem::offset_of!(pm_parser, magic_comment_list) - 232usize];
    ["Offset of field: pm_parser::data_loc"]
        [::std::mem::offset_of!(pm_parser, data_loc) - 244usize];
    ["Offset of field: pm_parser::warning_list"]
        [::std::mem::offset_of!(pm_parser, warning_list) - 252usize];
    ["Offset of field: pm_parser::error_list"]
        [::std::mem::offset_of!(pm_parser, error_list) - 264usize];
    ["Offset of field: pm_parser::current_scope"]
        [::std::mem::offset_of!(pm_parser, current_scope) - 276usize];
    ["Offset of field: pm_parser::current_context"]
        [::std::mem::offset_of!(pm_parser, current_context) - 280usize];
    ["Offset of field: pm_parser::current_hash_keys"]
        [::std::mem::offset_of!(pm_parser, current_hash_keys) - 284usize];
    ["Offset of field: pm_parser::encoding"]
        [::std::mem::offset_of!(pm_parser, encoding) - 288usize];
    ["Offset of field: pm_parser::encoding_changed_callback"]
        [::std::mem::offset_of!(pm_parser, encoding_changed_callback) - 292usize];
    ["Offset of field: pm_parser::encoding_comment_start"]
        [::std::mem::offset_of!(pm_parser, encoding_comment_start) - 296usize];
    ["Offset of field: pm_parser::lex_callback"]
        [::std::mem::offset_of!(pm_parser, lex_callback) - 300usize];
    ["Offset of field: pm_parser::filepath"]
        [::std::mem::offset_of!(pm_parser, filepath) - 304usize];
    ["Offset of field: pm_parser::constant_pool"]
        [::std::mem::offset_of!(pm_parser, constant_pool) - 316usize];
    ["Offset of field: pm_parser::newline_list"]
        [::std::mem::offset_of!(pm_parser, newline_list) - 332usize];
    ["Offset of field: pm_parser::integer_base"]
        [::std::mem::offset_of!(pm_parser, integer_base) - 348usize];
    ["Offset of field: pm_parser::current_string"]
        [::std::mem::offset_of!(pm_parser, current_string) - 352usize];
    ["Offset of field: pm_parser::start_line"]
        [::std::mem::offset_of!(pm_parser, start_line) - 364usize];
    ["Offset of field: pm_parser::explicit_encoding"]
        [::std::mem::offset_of!(pm_parser, explicit_encoding) - 368usize];
    ["Offset of field: pm_parser::current_block_exits"]
        [::std::mem::offset_of!(pm_parser, current_block_exits) - 372usize];
    ["Offset of field: pm_parser::version"][::std::mem::offset_of!(pm_parser, version) - 376usize];
    ["Offset of field: pm_parser::command_line"]
        [::std::mem::offset_of!(pm_parser, command_line) - 380usize];
    ["Offset of field: pm_parser::frozen_string_literal"]
        [::std::mem::offset_of!(pm_parser, frozen_string_literal) - 381usize];
    ["Offset of field: pm_parser::parsing_eval"]
        [::std::mem::offset_of!(pm_parser, parsing_eval) - 382usize];
    ["Offset of field: pm_parser::partial_script"]
        [::std::mem::offset_of!(pm_parser, partial_script) - 383usize];
    ["Offset of field: pm_parser::command_start"]
        [::std::mem::offset_of!(pm_parser, command_start) - 384usize];
    ["Offset of field: pm_parser::recovering"]
        [::std::mem::offset_of!(pm_parser, recovering) - 385usize];
    ["Offset of field: pm_parser::encoding_locked"]
        [::std::mem::offset_of!(pm_parser, encoding_locked) - 386usize];
    ["Offset of field: pm_parser::encoding_changed"]
        [::std::mem::offset_of!(pm_parser, encoding_changed) - 387usize];
    ["Offset of field: pm_parser::pattern_matching_newlines"]
        [::std::mem::offset_of!(pm_parser, pattern_matching_newlines) - 388usize];
    ["Offset of field: pm_parser::in_keyword_arg"]
        [::std::mem::offset_of!(pm_parser, in_keyword_arg) - 389usize];
    ["Offset of field: pm_parser::semantic_token_seen"]
        [::std::mem::offset_of!(pm_parser, semantic_token_seen) - 390usize];
    ["Offset of field: pm_parser::current_regular_expression_ascii_only"]
        [::std::mem::offset_of!(pm_parser, current_regular_expression_ascii_only) - 391usize];
    ["Offset of field: pm_parser::warn_mismatched_indentation"]
        [::std::mem::offset_of!(pm_parser, warn_mismatched_indentation) - 392usize];
};
pub const pm_pack_version_PM_PACK_VERSION_3_2_0: pm_pack_version = 0;
#[doc = " The version of the pack template language that we are parsing."]
pub type pm_pack_version = ::std::os::raw::c_uint;
pub const pm_pack_variant_PM_PACK_VARIANT_PACK: pm_pack_variant = 0;
pub const pm_pack_variant_PM_PACK_VARIANT_UNPACK: pm_pack_variant = 1;
#[doc = " The type of pack template we are parsing."]
pub type pm_pack_variant = ::std::os::raw::c_uint;
pub const pm_pack_type_PM_PACK_SPACE: pm_pack_type = 0;
pub const pm_pack_type_PM_PACK_COMMENT: pm_pack_type = 1;
pub const pm_pack_type_PM_PACK_INTEGER: pm_pack_type = 2;
pub const pm_pack_type_PM_PACK_UTF8: pm_pack_type = 3;
pub const pm_pack_type_PM_PACK_BER: pm_pack_type = 4;
pub const pm_pack_type_PM_PACK_FLOAT: pm_pack_type = 5;
pub const pm_pack_type_PM_PACK_STRING_SPACE_PADDED: pm_pack_type = 6;
pub const pm_pack_type_PM_PACK_STRING_NULL_PADDED: pm_pack_type = 7;
pub const pm_pack_type_PM_PACK_STRING_NULL_TERMINATED: pm_pack_type = 8;
pub const pm_pack_type_PM_PACK_STRING_MSB: pm_pack_type = 9;
pub const pm_pack_type_PM_PACK_STRING_LSB: pm_pack_type = 10;
pub const pm_pack_type_PM_PACK_STRING_HEX_HIGH: pm_pack_type = 11;
pub const pm_pack_type_PM_PACK_STRING_HEX_LOW: pm_pack_type = 12;
pub const pm_pack_type_PM_PACK_STRING_UU: pm_pack_type = 13;
pub const pm_pack_type_PM_PACK_STRING_MIME: pm_pack_type = 14;
pub const pm_pack_type_PM_PACK_STRING_BASE64: pm_pack_type = 15;
pub const pm_pack_type_PM_PACK_STRING_FIXED: pm_pack_type = 16;
pub const pm_pack_type_PM_PACK_STRING_POINTER: pm_pack_type = 17;
pub const pm_pack_type_PM_PACK_MOVE: pm_pack_type = 18;
pub const pm_pack_type_PM_PACK_BACK: pm_pack_type = 19;
pub const pm_pack_type_PM_PACK_NULL: pm_pack_type = 20;
pub const pm_pack_type_PM_PACK_END: pm_pack_type = 21;
#[doc = " A directive within the pack template."]
pub type pm_pack_type = ::std::os::raw::c_uint;
pub const pm_pack_signed_PM_PACK_UNSIGNED: pm_pack_signed = 0;
pub const pm_pack_signed_PM_PACK_SIGNED: pm_pack_signed = 1;
pub const pm_pack_signed_PM_PACK_SIGNED_NA: pm_pack_signed = 2;
#[doc = " The signness of a pack directive."]
pub type pm_pack_signed = ::std::os::raw::c_uint;
pub const pm_pack_endian_PM_PACK_AGNOSTIC_ENDIAN: pm_pack_endian = 0;
pub const pm_pack_endian_PM_PACK_LITTLE_ENDIAN: pm_pack_endian = 1;
pub const pm_pack_endian_PM_PACK_BIG_ENDIAN: pm_pack_endian = 2;
pub const pm_pack_endian_PM_PACK_NATIVE_ENDIAN: pm_pack_endian = 3;
pub const pm_pack_endian_PM_PACK_ENDIAN_NA: pm_pack_endian = 4;
#[doc = " The endianness of a pack directive."]
pub type pm_pack_endian = ::std::os::raw::c_uint;
pub const pm_pack_size_PM_PACK_SIZE_SHORT: pm_pack_size = 0;
pub const pm_pack_size_PM_PACK_SIZE_INT: pm_pack_size = 1;
pub const pm_pack_size_PM_PACK_SIZE_LONG: pm_pack_size = 2;
pub const pm_pack_size_PM_PACK_SIZE_LONG_LONG: pm_pack_size = 3;
pub const pm_pack_size_PM_PACK_SIZE_8: pm_pack_size = 4;
pub const pm_pack_size_PM_PACK_SIZE_16: pm_pack_size = 5;
pub const pm_pack_size_PM_PACK_SIZE_32: pm_pack_size = 6;
pub const pm_pack_size_PM_PACK_SIZE_64: pm_pack_size = 7;
pub const pm_pack_size_PM_PACK_SIZE_P: pm_pack_size = 8;
pub const pm_pack_size_PM_PACK_SIZE_NA: pm_pack_size = 9;
#[doc = " The size of an integer pack directive."]
pub type pm_pack_size = ::std::os::raw::c_uint;
pub const pm_pack_length_type_PM_PACK_LENGTH_FIXED: pm_pack_length_type = 0;
pub const pm_pack_length_type_PM_PACK_LENGTH_MAX: pm_pack_length_type = 1;
pub const pm_pack_length_type_PM_PACK_LENGTH_RELATIVE: pm_pack_length_type = 2;
pub const pm_pack_length_type_PM_PACK_LENGTH_NA: pm_pack_length_type = 3;
#[doc = " The type of length of a pack directive."]
pub type pm_pack_length_type = ::std::os::raw::c_uint;
pub const pm_pack_encoding_PM_PACK_ENCODING_START: pm_pack_encoding = 0;
pub const pm_pack_encoding_PM_PACK_ENCODING_ASCII_8BIT: pm_pack_encoding = 1;
pub const pm_pack_encoding_PM_PACK_ENCODING_US_ASCII: pm_pack_encoding = 2;
pub const pm_pack_encoding_PM_PACK_ENCODING_UTF_8: pm_pack_encoding = 3;
#[doc = " The type of encoding for a pack template string."]
pub type pm_pack_encoding = ::std::os::raw::c_uint;
pub const pm_pack_result_PM_PACK_OK: pm_pack_result = 0;
pub const pm_pack_result_PM_PACK_ERROR_UNSUPPORTED_DIRECTIVE: pm_pack_result = 1;
pub const pm_pack_result_PM_PACK_ERROR_UNKNOWN_DIRECTIVE: pm_pack_result = 2;
pub const pm_pack_result_PM_PACK_ERROR_LENGTH_TOO_BIG: pm_pack_result = 3;
pub const pm_pack_result_PM_PACK_ERROR_BANG_NOT_ALLOWED: pm_pack_result = 4;
pub const pm_pack_result_PM_PACK_ERROR_DOUBLE_ENDIAN: pm_pack_result = 5;
#[doc = " The result of parsing a pack template."]
pub type pm_pack_result = ::std::os::raw::c_uint;
#[doc = " This callback is called when a named capture group is found."]
pub type pm_regexp_name_callback_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const pm_string_t, data: *mut ::std::os::raw::c_void),
>;
#[doc = " This callback is called when a parse error is found."]
pub type pm_regexp_error_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const u8,
        end: *const u8,
        message: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lconv"][::std::mem::size_of::<lconv>() - 56usize];
    ["Alignment of lconv"][::std::mem::align_of::<lconv>() - 4usize];
    ["Offset of field: lconv::decimal_point"]
        [::std::mem::offset_of!(lconv, decimal_point) - 0usize];
    ["Offset of field: lconv::thousands_sep"]
        [::std::mem::offset_of!(lconv, thousands_sep) - 4usize];
    ["Offset of field: lconv::grouping"][::std::mem::offset_of!(lconv, grouping) - 8usize];
    ["Offset of field: lconv::int_curr_symbol"]
        [::std::mem::offset_of!(lconv, int_curr_symbol) - 12usize];
    ["Offset of field: lconv::currency_symbol"]
        [::std::mem::offset_of!(lconv, currency_symbol) - 16usize];
    ["Offset of field: lconv::mon_decimal_point"]
        [::std::mem::offset_of!(lconv, mon_decimal_point) - 20usize];
    ["Offset of field: lconv::mon_thousands_sep"]
        [::std::mem::offset_of!(lconv, mon_thousands_sep) - 24usize];
    ["Offset of field: lconv::mon_grouping"][::std::mem::offset_of!(lconv, mon_grouping) - 28usize];
    ["Offset of field: lconv::positive_sign"]
        [::std::mem::offset_of!(lconv, positive_sign) - 32usize];
    ["Offset of field: lconv::negative_sign"]
        [::std::mem::offset_of!(lconv, negative_sign) - 36usize];
    ["Offset of field: lconv::int_frac_digits"]
        [::std::mem::offset_of!(lconv, int_frac_digits) - 40usize];
    ["Offset of field: lconv::frac_digits"][::std::mem::offset_of!(lconv, frac_digits) - 41usize];
    ["Offset of field: lconv::p_cs_precedes"]
        [::std::mem::offset_of!(lconv, p_cs_precedes) - 42usize];
    ["Offset of field: lconv::p_sep_by_space"]
        [::std::mem::offset_of!(lconv, p_sep_by_space) - 43usize];
    ["Offset of field: lconv::n_cs_precedes"]
        [::std::mem::offset_of!(lconv, n_cs_precedes) - 44usize];
    ["Offset of field: lconv::n_sep_by_space"]
        [::std::mem::offset_of!(lconv, n_sep_by_space) - 45usize];
    ["Offset of field: lconv::p_sign_posn"][::std::mem::offset_of!(lconv, p_sign_posn) - 46usize];
    ["Offset of field: lconv::n_sign_posn"][::std::mem::offset_of!(lconv, n_sign_posn) - 47usize];
    ["Offset of field: lconv::int_p_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_p_cs_precedes) - 48usize];
    ["Offset of field: lconv::int_p_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_p_sep_by_space) - 49usize];
    ["Offset of field: lconv::int_n_cs_precedes"]
        [::std::mem::offset_of!(lconv, int_n_cs_precedes) - 50usize];
    ["Offset of field: lconv::int_n_sep_by_space"]
        [::std::mem::offset_of!(lconv, int_n_sep_by_space) - 51usize];
    ["Offset of field: lconv::int_p_sign_posn"]
        [::std::mem::offset_of!(lconv, int_p_sign_posn) - 52usize];
    ["Offset of field: lconv::int_n_sign_posn"]
        [::std::mem::offset_of!(lconv, int_n_sign_posn) - 53usize];
};
#[doc = " This function is used in pm_parse_stream to retrieve a line of input from a\n stream. It closely mirrors that of fgets so that fgets can be used as the\n default implementation."]
pub type pm_parse_stream_fgets_t = ::std::option::Option<
    unsafe extern "C" fn(
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        stream: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char,
>;
#[doc = " Returned if the encoding given to a slice query was invalid."]
pub const pm_string_query_t_PM_STRING_QUERY_ERROR: pm_string_query_t = -1;
#[doc = " Returned if the result of the slice query is false."]
pub const pm_string_query_t_PM_STRING_QUERY_FALSE: pm_string_query_t = 0;
#[doc = " Returned if the result of the slice query is true."]
pub const pm_string_query_t_PM_STRING_QUERY_TRUE: pm_string_query_t = 1;
#[doc = " Represents the results of a slice query."]
pub type pm_string_query_t = ::std::os::raw::c_int;
pub type mrc_bool = bool;
pub type mrc_int = i64;
pub type mrc_uint = u64;
pub type mrc_float = f64;
pub type mrc_sym = u32;
pub type mrc_code = u8;
#[doc = " \\class mrb_aspec\n\n Specifies the number of arguments a function takes\n\n Example: `MRB_ARGS_REQ(2) | MRB_ARGS_OPT(1)` for a method that expects 2..3 arguments"]
pub type mrc_aspec = u32;
pub const mrc_diagnostic_code_MRC_PARSER_WARNING: mrc_diagnostic_code = 0;
pub const mrc_diagnostic_code_MRC_PARSER_ERROR: mrc_diagnostic_code = 1;
pub const mrc_diagnostic_code_MRC_GENERATOR_WARNING: mrc_diagnostic_code = 2;
pub const mrc_diagnostic_code_MRC_GENERATOR_ERROR: mrc_diagnostic_code = 3;
pub type mrc_diagnostic_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_diagnostic_list {
    pub code: mrc_diagnostic_code,
    pub message: *mut ::std::os::raw::c_char,
    pub line: u32,
    pub column: u32,
    pub next: *mut mrc_diagnostic_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_diagnostic_list"][::std::mem::size_of::<mrc_diagnostic_list>() - 20usize];
    ["Alignment of mrc_diagnostic_list"][::std::mem::align_of::<mrc_diagnostic_list>() - 4usize];
    ["Offset of field: mrc_diagnostic_list::code"]
        [::std::mem::offset_of!(mrc_diagnostic_list, code) - 0usize];
    ["Offset of field: mrc_diagnostic_list::message"]
        [::std::mem::offset_of!(mrc_diagnostic_list, message) - 4usize];
    ["Offset of field: mrc_diagnostic_list::line"]
        [::std::mem::offset_of!(mrc_diagnostic_list, line) - 8usize];
    ["Offset of field: mrc_diagnostic_list::column"]
        [::std::mem::offset_of!(mrc_diagnostic_list, column) - 12usize];
    ["Offset of field: mrc_diagnostic_list::next"]
        [::std::mem::offset_of!(mrc_diagnostic_list, next) - 16usize];
};
pub type __jmp_buf = [::std::os::raw::c_ulong; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jb: __jmp_buf,
    pub __fl: ::std::os::raw::c_ulong,
    pub __ss: [::std::os::raw::c_ulong; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __jmp_buf_tag"][::std::mem::size_of::<__jmp_buf_tag>() - 164usize];
    ["Alignment of __jmp_buf_tag"][::std::mem::align_of::<__jmp_buf_tag>() - 4usize];
    ["Offset of field: __jmp_buf_tag::__jb"][::std::mem::offset_of!(__jmp_buf_tag, __jb) - 0usize];
    ["Offset of field: __jmp_buf_tag::__fl"][::std::mem::offset_of!(__jmp_buf_tag, __fl) - 32usize];
    ["Offset of field: __jmp_buf_tag::__ss"][::std::mem::offset_of!(__jmp_buf_tag, __ss) - 36usize];
};
pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type sigjmp_buf = jmp_buf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_jmpbuf {
    pub impl_: jmp_buf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_jmpbuf"][::std::mem::size_of::<mrc_jmpbuf>() - 164usize];
    ["Alignment of mrc_jmpbuf"][::std::mem::align_of::<mrc_jmpbuf>() - 4usize];
    ["Offset of field: mrc_jmpbuf::impl_"][::std::mem::offset_of!(mrc_jmpbuf, impl_) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_pool {
    pub c: *mut mrc_ccontext,
    pub pages: *mut mrc_pool_page,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_pool"][::std::mem::size_of::<mrc_pool>() - 8usize];
    ["Alignment of mrc_pool"][::std::mem::align_of::<mrc_pool>() - 4usize];
    ["Offset of field: mrc_pool::c"][::std::mem::offset_of!(mrc_pool, c) - 0usize];
    ["Offset of field: mrc_pool::pages"][::std::mem::offset_of!(mrc_pool, pages) - 4usize];
};
#[doc = " This is the base structure that represents a node in the syntax tree. It is\n embedded into every node type."]
pub type mrc_node = pm_node_t;
#[doc = " This struct represents the overall parser. It contains a reference to the\n source file, as well as pointers that indicate where in the source it's\n currently parsing. It also contains the most recent and current token that\n it's considering."]
pub type mrc_parser_state = pm_parser_t;
#[doc = " A list of constant IDs. Usually used to represent a set of locals."]
pub type mrc_constant_id_list = pm_constant_id_list_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_parse_result_t {
    pub parser: pm_parser_t,
    pub options: pm_options_t,
    pub input: pm_string_t,
    pub parsed: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pm_parse_result_t"][::std::mem::size_of::<pm_parse_result_t>() - 468usize];
    ["Alignment of pm_parse_result_t"][::std::mem::align_of::<pm_parse_result_t>() - 4usize];
    ["Offset of field: pm_parse_result_t::parser"]
        [::std::mem::offset_of!(pm_parse_result_t, parser) - 0usize];
    ["Offset of field: pm_parse_result_t::options"]
        [::std::mem::offset_of!(pm_parse_result_t, options) - 396usize];
    ["Offset of field: pm_parse_result_t::input"]
        [::std::mem::offset_of!(pm_parse_result_t, input) - 452usize];
    ["Offset of field: pm_parse_result_t::parsed"]
        [::std::mem::offset_of!(pm_parse_result_t, parsed) - 464usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_filename_table {
    pub filename: *const ::std::os::raw::c_char,
    pub start: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_filename_table"][::std::mem::size_of::<mrc_filename_table>() - 8usize];
    ["Alignment of mrc_filename_table"][::std::mem::align_of::<mrc_filename_table>() - 4usize];
    ["Offset of field: mrc_filename_table::filename"]
        [::std::mem::offset_of!(mrc_filename_table, filename) - 0usize];
    ["Offset of field: mrc_filename_table::start"]
        [::std::mem::offset_of!(mrc_filename_table, start) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_ccontext {
    pub mrb: *mut ::std::os::raw::c_void,
    pub jmp: *mut mrc_jmpbuf,
    pub p: *mut mrc_parser_state,
    pub options: *mut pm_options_t,
    pub slen: ::std::os::raw::c_int,
    pub filename: *mut ::std::os::raw::c_char,
    pub lineno: u16,
    pub target_class: *mut RClass,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub diagnostic_list: *mut mrc_diagnostic_list,
    pub scope_sp: u16,
    pub pool: *mut mrc_pool,
    pub filename_table: *mut mrc_filename_table,
    pub filename_table_length: u16,
    pub current_filename_index: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_ccontext"][::std::mem::size_of::<mrc_ccontext>() - 56usize];
    ["Alignment of mrc_ccontext"][::std::mem::align_of::<mrc_ccontext>() - 4usize];
    ["Offset of field: mrc_ccontext::mrb"][::std::mem::offset_of!(mrc_ccontext, mrb) - 0usize];
    ["Offset of field: mrc_ccontext::jmp"][::std::mem::offset_of!(mrc_ccontext, jmp) - 4usize];
    ["Offset of field: mrc_ccontext::p"][::std::mem::offset_of!(mrc_ccontext, p) - 8usize];
    ["Offset of field: mrc_ccontext::options"]
        [::std::mem::offset_of!(mrc_ccontext, options) - 12usize];
    ["Offset of field: mrc_ccontext::slen"][::std::mem::offset_of!(mrc_ccontext, slen) - 16usize];
    ["Offset of field: mrc_ccontext::filename"]
        [::std::mem::offset_of!(mrc_ccontext, filename) - 20usize];
    ["Offset of field: mrc_ccontext::lineno"]
        [::std::mem::offset_of!(mrc_ccontext, lineno) - 24usize];
    ["Offset of field: mrc_ccontext::target_class"]
        [::std::mem::offset_of!(mrc_ccontext, target_class) - 28usize];
    ["Offset of field: mrc_ccontext::diagnostic_list"]
        [::std::mem::offset_of!(mrc_ccontext, diagnostic_list) - 36usize];
    ["Offset of field: mrc_ccontext::scope_sp"]
        [::std::mem::offset_of!(mrc_ccontext, scope_sp) - 40usize];
    ["Offset of field: mrc_ccontext::pool"][::std::mem::offset_of!(mrc_ccontext, pool) - 44usize];
    ["Offset of field: mrc_ccontext::filename_table"]
        [::std::mem::offset_of!(mrc_ccontext, filename_table) - 48usize];
    ["Offset of field: mrc_ccontext::filename_table_length"]
        [::std::mem::offset_of!(mrc_ccontext, filename_table_length) - 52usize];
    ["Offset of field: mrc_ccontext::current_filename_index"]
        [::std::mem::offset_of!(mrc_ccontext, current_filename_index) - 54usize];
};
impl mrc_ccontext {
    #[inline]
    pub fn capture_errors(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_capture_errors(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn capture_errors_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_capture_errors_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dump_result(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dump_result(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dump_result_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dump_result_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_exec(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_exec(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_exec_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_exec_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn keep_lv(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keep_lv(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn keep_lv_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_keep_lv_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_optimize(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_optimize(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_optimize_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_optimize_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_ext_ops(&self) -> mrc_bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_ext_ops(&mut self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_ext_ops_raw(this: *const Self) -> mrc_bool {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_ext_ops_raw(this: *mut Self, val: mrc_bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        capture_errors: mrc_bool,
        dump_result: mrc_bool,
        no_exec: mrc_bool,
        keep_lv: mrc_bool,
        no_optimize: mrc_bool,
        no_ext_ops: mrc_bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let capture_errors: u8 = unsafe { ::std::mem::transmute(capture_errors) };
            capture_errors as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dump_result: u8 = unsafe { ::std::mem::transmute(dump_result) };
            dump_result as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_exec: u8 = unsafe { ::std::mem::transmute(no_exec) };
            no_exec as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let keep_lv: u8 = unsafe { ::std::mem::transmute(keep_lv) };
            keep_lv as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let no_optimize: u8 = unsafe { ::std::mem::transmute(no_optimize) };
            no_optimize as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let no_ext_ops: u8 = unsafe { ::std::mem::transmute(no_ext_ops) };
            no_ext_ops as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const irep_pool_type_IREP_TT_STR: irep_pool_type = 0;
pub const irep_pool_type_IREP_TT_SSTR: irep_pool_type = 2;
pub const irep_pool_type_IREP_TT_INT32: irep_pool_type = 1;
pub const irep_pool_type_IREP_TT_INT64: irep_pool_type = 3;
pub const irep_pool_type_IREP_TT_BIGINT: irep_pool_type = 7;
pub const irep_pool_type_IREP_TT_FLOAT: irep_pool_type = 5;
#[doc = " Compiled mruby scripts."]
pub type irep_pool_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mrc_pool_value {
    pub tt: u32,
    pub u: mrc_pool_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mrc_pool_value__bindgen_ty_1 {
    pub str_: *const ::std::os::raw::c_char,
    pub i32_: i32,
    pub i64_: i64,
    pub f: mrc_float,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_pool_value__bindgen_ty_1"]
        [::std::mem::size_of::<mrc_pool_value__bindgen_ty_1>() - 8usize];
    ["Alignment of mrc_pool_value__bindgen_ty_1"]
        [::std::mem::align_of::<mrc_pool_value__bindgen_ty_1>() - 8usize];
    ["Offset of field: mrc_pool_value__bindgen_ty_1::str_"]
        [::std::mem::offset_of!(mrc_pool_value__bindgen_ty_1, str_) - 0usize];
    ["Offset of field: mrc_pool_value__bindgen_ty_1::i32_"]
        [::std::mem::offset_of!(mrc_pool_value__bindgen_ty_1, i32_) - 0usize];
    ["Offset of field: mrc_pool_value__bindgen_ty_1::i64_"]
        [::std::mem::offset_of!(mrc_pool_value__bindgen_ty_1, i64_) - 0usize];
    ["Offset of field: mrc_pool_value__bindgen_ty_1::f"]
        [::std::mem::offset_of!(mrc_pool_value__bindgen_ty_1, f) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_pool_value"][::std::mem::size_of::<mrc_pool_value>() - 16usize];
    ["Alignment of mrc_pool_value"][::std::mem::align_of::<mrc_pool_value>() - 8usize];
    ["Offset of field: mrc_pool_value::tt"][::std::mem::offset_of!(mrc_pool_value, tt) - 0usize];
    ["Offset of field: mrc_pool_value::u"][::std::mem::offset_of!(mrc_pool_value, u) - 8usize];
};
pub const mrc_catch_type_MRC_CATCH_RESCUE: mrc_catch_type = 0;
pub const mrc_catch_type_MRC_CATCH_ENSURE: mrc_catch_type = 1;
pub type mrc_catch_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_irep_catch_handler {
    pub type_: u8,
    pub begin: [u8; 4usize],
    pub end: [u8; 4usize],
    pub target: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_irep_catch_handler"][::std::mem::size_of::<mrc_irep_catch_handler>() - 13usize];
    ["Alignment of mrc_irep_catch_handler"]
        [::std::mem::align_of::<mrc_irep_catch_handler>() - 1usize];
    ["Offset of field: mrc_irep_catch_handler::type_"]
        [::std::mem::offset_of!(mrc_irep_catch_handler, type_) - 0usize];
    ["Offset of field: mrc_irep_catch_handler::begin"]
        [::std::mem::offset_of!(mrc_irep_catch_handler, begin) - 1usize];
    ["Offset of field: mrc_irep_catch_handler::end"]
        [::std::mem::offset_of!(mrc_irep_catch_handler, end) - 5usize];
    ["Offset of field: mrc_irep_catch_handler::target"]
        [::std::mem::offset_of!(mrc_irep_catch_handler, target) - 9usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_irep {
    pub nlocals: u16,
    pub nregs: u16,
    pub clen: u16,
    pub flags: u8,
    pub iseq: *const mrc_code,
    pub pool: *const mrc_pool_value,
    pub syms: *const mrc_sym,
    pub reps: *const *const mrc_irep,
    pub lv: *mut mrc_sym,
    pub debug_info: *mut mrc_irep_debug_info,
    pub ilen: u32,
    pub plen: u16,
    pub slen: u16,
    pub rlen: u16,
    pub refcnt: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_irep"][::std::mem::size_of::<mrc_irep>() - 44usize];
    ["Alignment of mrc_irep"][::std::mem::align_of::<mrc_irep>() - 4usize];
    ["Offset of field: mrc_irep::nlocals"][::std::mem::offset_of!(mrc_irep, nlocals) - 0usize];
    ["Offset of field: mrc_irep::nregs"][::std::mem::offset_of!(mrc_irep, nregs) - 2usize];
    ["Offset of field: mrc_irep::clen"][::std::mem::offset_of!(mrc_irep, clen) - 4usize];
    ["Offset of field: mrc_irep::flags"][::std::mem::offset_of!(mrc_irep, flags) - 6usize];
    ["Offset of field: mrc_irep::iseq"][::std::mem::offset_of!(mrc_irep, iseq) - 8usize];
    ["Offset of field: mrc_irep::pool"][::std::mem::offset_of!(mrc_irep, pool) - 12usize];
    ["Offset of field: mrc_irep::syms"][::std::mem::offset_of!(mrc_irep, syms) - 16usize];
    ["Offset of field: mrc_irep::reps"][::std::mem::offset_of!(mrc_irep, reps) - 20usize];
    ["Offset of field: mrc_irep::lv"][::std::mem::offset_of!(mrc_irep, lv) - 24usize];
    ["Offset of field: mrc_irep::debug_info"]
        [::std::mem::offset_of!(mrc_irep, debug_info) - 28usize];
    ["Offset of field: mrc_irep::ilen"][::std::mem::offset_of!(mrc_irep, ilen) - 32usize];
    ["Offset of field: mrc_irep::plen"][::std::mem::offset_of!(mrc_irep, plen) - 36usize];
    ["Offset of field: mrc_irep::slen"][::std::mem::offset_of!(mrc_irep, slen) - 38usize];
    ["Offset of field: mrc_irep::rlen"][::std::mem::offset_of!(mrc_irep, rlen) - 40usize];
    ["Offset of field: mrc_irep::refcnt"][::std::mem::offset_of!(mrc_irep, refcnt) - 42usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_insn_data {
    pub insn: u8,
    pub a: u32,
    pub b: u16,
    pub cc: u16,
    pub addr: *const mrc_code,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mrc_insn_data"][::std::mem::size_of::<mrc_insn_data>() - 16usize];
    ["Alignment of mrc_insn_data"][::std::mem::align_of::<mrc_insn_data>() - 4usize];
    ["Offset of field: mrc_insn_data::insn"][::std::mem::offset_of!(mrc_insn_data, insn) - 0usize];
    ["Offset of field: mrc_insn_data::a"][::std::mem::offset_of!(mrc_insn_data, a) - 4usize];
    ["Offset of field: mrc_insn_data::b"][::std::mem::offset_of!(mrc_insn_data, b) - 8usize];
    ["Offset of field: mrc_insn_data::cc"][::std::mem::offset_of!(mrc_insn_data, cc) - 10usize];
    ["Offset of field: mrc_insn_data::addr"][::std::mem::offset_of!(mrc_insn_data, addr) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_binary_header {
    pub binary_ident: [u8; 4usize],
    pub major_version: [u8; 2usize],
    pub minor_version: [u8; 2usize],
    pub binary_size: [u8; 4usize],
    pub compiler_name: [u8; 4usize],
    pub compiler_version: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_binary_header"][::std::mem::size_of::<rite_binary_header>() - 20usize];
    ["Alignment of rite_binary_header"][::std::mem::align_of::<rite_binary_header>() - 1usize];
    ["Offset of field: rite_binary_header::binary_ident"]
        [::std::mem::offset_of!(rite_binary_header, binary_ident) - 0usize];
    ["Offset of field: rite_binary_header::major_version"]
        [::std::mem::offset_of!(rite_binary_header, major_version) - 4usize];
    ["Offset of field: rite_binary_header::minor_version"]
        [::std::mem::offset_of!(rite_binary_header, minor_version) - 6usize];
    ["Offset of field: rite_binary_header::binary_size"]
        [::std::mem::offset_of!(rite_binary_header, binary_size) - 8usize];
    ["Offset of field: rite_binary_header::compiler_name"]
        [::std::mem::offset_of!(rite_binary_header, compiler_name) - 12usize];
    ["Offset of field: rite_binary_header::compiler_version"]
        [::std::mem::offset_of!(rite_binary_header, compiler_version) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_section_header {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_section_header"][::std::mem::size_of::<rite_section_header>() - 8usize];
    ["Alignment of rite_section_header"][::std::mem::align_of::<rite_section_header>() - 1usize];
    ["Offset of field: rite_section_header::section_ident"]
        [::std::mem::offset_of!(rite_section_header, section_ident) - 0usize];
    ["Offset of field: rite_section_header::section_size"]
        [::std::mem::offset_of!(rite_section_header, section_size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_section_irep_header {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
    pub rite_version: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_section_irep_header"]
        [::std::mem::size_of::<rite_section_irep_header>() - 12usize];
    ["Alignment of rite_section_irep_header"]
        [::std::mem::align_of::<rite_section_irep_header>() - 1usize];
    ["Offset of field: rite_section_irep_header::section_ident"]
        [::std::mem::offset_of!(rite_section_irep_header, section_ident) - 0usize];
    ["Offset of field: rite_section_irep_header::section_size"]
        [::std::mem::offset_of!(rite_section_irep_header, section_size) - 4usize];
    ["Offset of field: rite_section_irep_header::rite_version"]
        [::std::mem::offset_of!(rite_section_irep_header, rite_version) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_section_debug_header {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_section_debug_header"]
        [::std::mem::size_of::<rite_section_debug_header>() - 8usize];
    ["Alignment of rite_section_debug_header"]
        [::std::mem::align_of::<rite_section_debug_header>() - 1usize];
    ["Offset of field: rite_section_debug_header::section_ident"]
        [::std::mem::offset_of!(rite_section_debug_header, section_ident) - 0usize];
    ["Offset of field: rite_section_debug_header::section_size"]
        [::std::mem::offset_of!(rite_section_debug_header, section_size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_section_lv_header {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_section_lv_header"][::std::mem::size_of::<rite_section_lv_header>() - 8usize];
    ["Alignment of rite_section_lv_header"]
        [::std::mem::align_of::<rite_section_lv_header>() - 1usize];
    ["Offset of field: rite_section_lv_header::section_ident"]
        [::std::mem::offset_of!(rite_section_lv_header, section_ident) - 0usize];
    ["Offset of field: rite_section_lv_header::section_size"]
        [::std::mem::offset_of!(rite_section_lv_header, section_size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rite_binary_footer {
    pub section_ident: [u8; 4usize],
    pub section_size: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rite_binary_footer"][::std::mem::size_of::<rite_binary_footer>() - 8usize];
    ["Alignment of rite_binary_footer"][::std::mem::align_of::<rite_binary_footer>() - 1usize];
    ["Offset of field: rite_binary_footer::section_ident"]
        [::std::mem::offset_of!(rite_binary_footer, section_ident) - 0usize];
    ["Offset of field: rite_binary_footer::section_size"]
        [::std::mem::offset_of!(rite_binary_footer, section_size) - 4usize];
};
pub type __builtin_va_list = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_pool_page {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RClass {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mrc_irep_debug_info {
    pub _address: u8,
}
